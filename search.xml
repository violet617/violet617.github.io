<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/13/hello-world/"/>
      <url>/2023/09/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MQ知识点</title>
      <link href="/2023/05/15/MQ%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/05/15/MQ%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要是用MQ"><a href="#为什么要是用MQ" class="headerlink" title="为什么要是用MQ"></a>为什么要是用MQ</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>核心：解耦、异步、削峰<ol><li>解耦：A系统发送数据到BCD三个系统，通过接口调用发送。如果此时E系统也想要这个数据呢？C系统不想要这个数据了呢？A系统的负责人直接崩溃，因为现在A系统跟其他各种乱七八糟的系统严重耦合在了一起。A系统产生了一条比较关键的数据，很多系统都需要A系统将这个数据发送过来。如果使用MQ，A系统将这条数据发送到MQ里去，哪个系统需要数据自己就去MQ里消费，哪个系统不需要这条数据了，就取消对MQ消息的消费。这样下来，A系统就不用去考虑给谁发送数据了，不需要维护这个代码，也不用考虑别的系统是否调用成功、失败超时等情况。核心思想就是舍弃同步调用其他接口，使用MQ异步化解耦。</li><li>异步：A系统接收到一个请求，需要在自己本地写库，还需要在BCD三个系统写库。自己本地写库要3ms，BCD三个系统分别写库要300ms、400ms、500ms。最终总延时接近<code>1.2s</code>，给用户的体验极差。用户通过浏览器发起请求，如果使用MQ，假如A系统连续发送3条消息到MQ队列中耗时5ms，那么A系统从接受一个请求到返回响应给用户，总时长是<code>3 + 5 = 8ms</code></li><li>削峰：减少高峰时期对服务器的压力</li></ol></li></ul>              </div>            </details><h1 id="MQ有什么优缺点"><a href="#MQ有什么优缺点" class="headerlink" title="MQ有什么优缺点"></a>MQ有什么优缺点</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>优点上面已经说了：解耦、异步、削峰</li><li>缺点如下：<ol><li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，那么整套系统都崩溃了。</li><li>系统复杂度提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li><li>一致性问题：A系统处理完了直接返回成功了，用户就真的以为你这个请求成功了。但是问题是：要是BCD三个系统里，BC两个系统写库成功了，D系统写库失败了，那么此时数据就会出现不一致性问题。</li></ol></li></ul>              </div>            </details><h1 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>从吞吐量来说，Kafka和RocketMQ支持高吞吐，ActiveMQ和RabbitMQ比它们低一个数量级。对于延迟量来说，RabbitMQ是最低的</li><li>从社区活跃度来说，RabbitMQ是首选</li><li>持久化消息比较：ActiveMQ和RabbitMQ都支持。持久化消息主要是指我们的机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。</li><li>综合技术实现：可靠性、灵活的路由、集群、事务、高可用队列、消息排序、问题追踪、可视化管理工具、插件系统等。RabbitMQ和Kafka最好</li><li>高并发：毋庸置疑，RabbitMQ最高，原因是它的实现语言是天生具备高并发高可用的erlang语言</li></ol>              </div>            </details><h1 id="如何保证高可用"><a href="#如何保证高可用" class="headerlink" title="如何保证高可用"></a>如何保证高可用</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>RabbitMQ是基于主从做高可用性的，RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式。<ol><li>单机模式：就是Demo级别的，一般就是本地启动玩玩儿的，生产环境没人用单机模式</li><li>普通集群模式：在多台机器上启动多个RabbitMQ实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据（元数据可以认为是queue的一些配置信息，通过元数据可以找到queue所在实例）。在消费消息的时候，如果连接到了别的RabbitMQ实例，那么这个示例会从queue所在的实例上拉取数据过来。这个方案主要是为了提高吞吐量的，让集群中的多个节点来服务某个queue的读写操作。</li><li>镜像集群模式：这种模式才是所谓的RabbitMQ高可用模式。跟普通集群不一样的是，在镜像集群模式下，你创建的queue，无论是元数据还是queue里的消息，都会存在于多个实例上，就是说，每个RabbitMQ节点都有这个queue的完整镜像，包含queue的全部数据。每次写消息到queue的时候，都会自动把消息同步到多个实例的queue上。RabbitMQ的管理控制台可以在后台增加一个集群模式的策略，可以要求数据同步到所有节点，也可以要求同步到指定数量的节点，再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的好处在于，任何一个机器宕机了，其他机器还有包含了这个queue的完整数据，别的消费者可以到其他的节点上去消费数据。坏处在于，1.性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重。2. 扩展性差：如果某个 Queue 负载很重，即便加机器，新增的机器也包含了这个 Queue 的所有数据，并没有办法线性扩展你的 Queue。</li></ol></li></ul>              </div>            </details><h1 id="如何保证消息传输的可靠传输？消息丢失怎么办？"><a href="#如何保证消息传输的可靠传输？消息丢失怎么办？" class="headerlink" title="如何保证消息传输的可靠传输？消息丢失怎么办？"></a>如何保证消息传输的可靠传输？消息丢失怎么办？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>首先这个消息丢失，有三处都可能发生<ol><li><code>生产者丢失</code>：生产者将数据发送到RabbitMQ的时候，由于网络的原因，可能数据半路就丢了。此时可以选择使用RabbitMQ提供的事务功能，就是生产者发送数据之前开启RabbitMQ事务channel.txSelect，然后发送消息，如果消息没有被RabbitMQ接收到，那么生产者会收到异常报错，此时可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。吞吐量会下来，因为太耗性能。所以一般来说，如果你要确保写RabbitMQ的消息别丢，在生产者那里设置开启confirm模式，每次写消息都会分配一个唯一id，如果写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你说这个消息ok了。如果RabbitMQ没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间没有接收到这个消息的回调，那么你可以重发。</li><li><code>MQ中丢失</code>：这种情况必须开启RabbitMQ的持久化，就是消息写入之后会持久化到硬盘，哪怕RabbitMQ自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢失。设置持久化有两个步骤：第一个是创建queue的时候将其设置为持久化，这样可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据。第二个是发送消息的时候，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。必须同时设置这两个持久化才行，</li><li><code>消费端丢失</code>：消费的时候，刚消费到，还没处理，此时服务挂了，服务重启了，那么就尴尬了，RabbitMQ人为你消费了，这数据就丢了。这个时候需要使用RabbitMQ提供的ack机制，简单来说就是，关闭RabbitMQ的自动ack，然后在服务处理消息完毕后再手动ack，这样的话，如果消息还没处理完，那么就不会ack，消息就不会丢了。<br><img src="https://s1.ax1x.com/2023/06/26/pCUeRD1.png" alt=""></li></ol></li></ul>              </div>            </details><h1 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>拆分多个 Queue，每个 Queue一个 Consumer；或者就一个 Queue 但是对应一个 Consumer，然后这个 Consumer 内部用内存队列做排队，然后分发给底层不同的 Worker 来处理。</li></ul>              </div>            </details><h1 id="大量消息在MQ里长时间积压，该如何解决？"><a href="#大量消息在MQ里长时间积压，该如何解决？" class="headerlink" title="大量消息在MQ里长时间积压，该如何解决？"></a>大量消息在MQ里长时间积压，该如何解决？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>一般这个时候，只能临时紧急扩容了，具体操作步骤思路如下<ol><li>先修复consumer的问题，确保其恢复消费速度，然后将现有的consumer都停掉。</li><li>新建一个topic，partition是原来的10倍，临时建立好原先10倍的queue数量。</li><li>写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue。</li><li>接着临时用10倍的机器来部署consumer，每一批consumer消费一个临时queue数据，这样的做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据。</li><li>等快速消费完积压数据后，得回复原先部署的架构，重新用原先的consumer机器来消费消息。</li></ol></li></ul>              </div>            </details><h1 id="MQ中规定消息过期失效了怎么办？"><a href="#MQ中规定消息过期失效了怎么办？" class="headerlink" title="MQ中规定消息过期失效了怎么办？"></a>MQ中规定消息过期失效了怎么办？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>如果使用的是RabbitMQ，RabbitMQ是可以设置过期时间的（TTL）。如果消息在queue中积压超过一定时间就会被RabbitMQ给清理掉，这个数据就没了。此时的问题就不是数据大量积压在MQ里，而是大量的数据会直接搞丢。这个情况下，解决方案就不是增加consumer消费积压的信息了，而是需要批量重导，当大量积压的时候，直接将数据写到数据库，等过了高峰期之后在将这批数据一点一点查出来，重新写入到MQ中，将丢的数据补回来。</li></ul>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis知识点</title>
      <link href="/2023/05/12/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/05/12/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h1><details class="folding-tag" cyan><summary></summary>              <div class='content'>              <ul><li>使用缓存的目的就是提升读写性能。在实际的业务场景下，更多的是为了提升读性能，带来更好的性能和并发量。Redis的读写性能比MySQL好的多，我们就可以把MySQL中的热点数据缓存到Redis，提升读取性能，同时减轻了MySQL的读取压力。</li></ul>              </div>            </details><h1 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h1><details class="folding-tag" cyan><summary></summary>              <div class='content'>              <ul><li>Redis是一个高性能的内存数据存储系统，也可以称为键值存储系统。它支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等，还提供了一些高级功能，如发布订阅、事务、Lua脚本等。Redis的特点是数据存储在内存中，可以快速读写，同时支持数据持久化到磁盘中。Redis还具有分布式特性，可以通过分片和赋值来实现高可用和高扩展性。</li><li>Redis主要应用于缓存、会话存储、消息队列、排行榜等场景，具有快速、稳定、可靠等优点。由于其出色的性能和易用性，Redis已经成为最受欢迎的内存数据库之一。</li></ul>              </div>            </details><h1 id="使用Redis有哪些好处？"><a href="#使用Redis有哪些好处？" class="headerlink" title="使用Redis有哪些好处？"></a>使用Redis有哪些好处？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>使用Redis有以下几个好处<ol><li>高性能：Redis将数据存储在内存中，读写速度非常快，可以达到几十万甚至上百万QPS，特别适合高并发场景。</li><li>数据结构丰富：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，可以满足不同场景下的需求。</li><li>持久化：Redis支持将数据持久化到磁盘中，以保证数据的安全性和可恢复性。</li><li>分布式特性：Redis支持分片和复制，可以实现高可用和高扩展性，支持数据在多台服务器之间的共享。</li><li>丰富的功能：Redis提供了许多高级功能，如事务、Lua脚本、发布订阅、过期策略等，可以满足更加复杂的业务需求。</li></ol></li></ul>              </div>            </details><h1 id="为什么要是用Redis而不是用Memcached呢？"><a href="#为什么要是用Redis而不是用Memcached呢？" class="headerlink" title="为什么要是用Redis而不是用Memcached呢？"></a>为什么要是用Redis而不是用Memcached呢？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis和Memcached都是流行的内存缓存系统，它们都可以在内存中快速读写数据，但是在一些方面有所不同，下面是Redis相较于Memcached的一些优点<ol><li>数据结构更丰富：Redis支持多种数据结构，例如字符串、哈希、列表、集合、有序集合等，这些数据结构可以直接映射到实际的数据模型中，方便业务开发和数据处理。</li><li>多种持久化方式：Redis支持多种持久化方式，包括哦RDB（快照）和AOF（日志），这些持久化方式可以保证数据的安全性和可恢复性。</li><li>多种复制方式：Redis支持主从复制和哨兵模式，可以实现高可用和自动故障转移，而Memcached则需要通过第三方工具来实现高可用。</li><li>更好的性能：Redis在读写性能和并发能力上相较于Memcached更好，尤其是在多核CPU环境下，Redis可以充分利用多核的优势，提高系统的吞吐量。</li><li>更丰富的功能：Redis提供了更丰富的功能，如事务、Lua脚本、发布订阅、过期策略等，可以满足更加负载的业务需求。</li></ol></li></ul>              </div>            </details><h1 id="说说Redis线程模型"><a href="#说说Redis线程模型" class="headerlink" title="说说Redis线程模型"></a>说说Redis线程模型</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis采用单线程模型，也就是说所有的请求都由同一个线程来处理。这个线程主要负责网络IO、请求解析、命令执行和数据返回等业务。Redis内部通过事件驱动机制来实现异步IO操作，包括文件事件和时间事件。具体来说，Redis在启动时会创建一个事件处理器，来监听客户端套接字的读写事件，并在事件发生时触发响应的回调函数来处理事件。</li><li>Redis单线程模型的优点是代码简洁、易于维护和调试，同时可以避免多线程并发带来的同步和锁的问题。此外，Redis还采用了多路复用机制，可以将多个客户端的请求合并到一起，减少IO操作的次数，提高系统的吞吐量和响应速度。</li><li>当然，Redis的单线程模型也存在一些缺点，如无法充分利用多核CPU的优势，容易受到单点故障的影响等。为了解决这些问题，Redis引入了多个进程和多个实例的方案，如主从复制、哨兵模式和集群模式等。这些方案可以提高系统的可用性和扩展性，同时保持了Redis简洁、高效的特点。</li></ul>              </div>            </details><h1 id="为什么Redis单线程模型效率也能那么高？"><a href="#为什么Redis单线程模型效率也能那么高？" class="headerlink" title="为什么Redis单线程模型效率也能那么高？"></a>为什么Redis单线程模型效率也能那么高？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>C语言实现，效率高</li><li>纯内存操作</li><li>基于非阻塞的IO复用模型机制</li><li>单线程的话可以避免多线程的频繁上下文切换问题</li><li>丰富的数据结构，全程采用哈希结构，读取速度非常快，对数据存储进行了一些优化，例如压缩表、跳表等。</li></ol>              </div>            </details><h1 id="为什么Redis需要把所有数据放到内存中？"><a href="#为什么Redis需要把所有数据放到内存中？" class="headerlink" title="为什么Redis需要把所有数据放到内存中？"></a>为什么Redis需要把所有数据放到内存中？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis之所以将所有数据都放在内存中，是因为它设计的目标是高性能、高吞吐量和低延迟，而内存访问的速度比磁盘访问的速度快很多。如果数据存储在硬盘中，磁盘I/O会严重影响Redis的性能。而且Redis还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。</li></ul>              </div>            </details><h1 id="Redis的同步机制了解吗？"><a href="#Redis的同步机制了解吗？" class="headerlink" title="Redis的同步机制了解吗？"></a>Redis的同步机制了解吗？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis支持主从同步和从从同步，而在进行第一次主从同步时，需要现在主节点上执行BGSAVE命令，将当前内存中的数据持久化道磁盘上生成RDB文件，并且将主节点需要将后续修改操作记录到内存缓冲区中。在这个过程中，主节点会将生成的RDB文件发送给从节点，从节点接收并加载RDB文件到自己的内存中。加载完成后，从节点会通知主节点，将主节点在复制期间产生的命令同步到从节点，以此完成主从同步过程。</li></ul>              </div>            </details><h1 id="pipeline有什么好处，为什么要是用Pipeline？"><a href="#pipeline有什么好处，为什么要是用Pipeline？" class="headerlink" title="pipeline有什么好处，为什么要是用Pipeline？"></a>pipeline有什么好处，为什么要是用Pipeline？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>使用Pipeline的好处在于可以将多次I/O往返的时间缩短为一次，从而提高Redis的吞吐量和性能。Pipeline允许客户端将多个Redis命令打包成一次请求发送给Redis服务器，Redis服务器收到后，将多个命令按顺序执行，并将执行结果按照请求的顺序返回给客户端，这样就避免了每次请求都要进行网络通信的开销。</li></ul>              </div>            </details><h1 id="说一下Redis有什么优点和缺点？"><a href="#说一下Redis有什么优点和缺点？" class="headerlink" title="说一下Redis有什么优点和缺点？"></a>说一下Redis有什么优点和缺点？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>优点：<ol><li>高性能：Redis使用C语言编写，采用单线程模型，将数据全部存储在内存中，加上异步I/O和时间驱动机制等优化，使得Redis在读写数据时的性能非常高。</li><li>数据结构丰富：Redis支持多种数据结构，如字符串、列表、哈希表、集合、有序集合等，这些数据结构可以满足不同的业务需求。</li><li>持久化机制：Redis提供了两张持久化机制，即RDB和AOF，可以将内存中的数据持久化到磁盘上，保证了数据的可靠性和安全性。</li><li>高可用性：Redis提供了主从复制和Sentinel机制，可以实现数据的高可用性和容错能力。</li></ol></li><li>缺点：<ol><li>内存受限：Redis将所有数据存储在内存中，如果数据量很大，会受到内存大小的限制，不适合存储大规模数据。</li><li>持久化机制可能带来性能损失：由于Redis提供了持久化机制，数据需要同步到磁盘上，真会导致写入性能的下降。 </li><li>单线程模型可能存在瓶颈：尽管Redis采用了单线程模型，但是在极端情况下，可能会出现性能瓶颈，影响系统性能。</li><li>不支持多机数据共享：Redis不支持多机数据共享，需要使用其他技术如主从复制和Sentinel机制来实现高可用性和容错能力。</li></ol></li></ul>              </div>            </details><h1 id="Redis缓存刷新策略有哪些？"><a href="#Redis缓存刷新策略有哪些？" class="headerlink" title="Redis缓存刷新策略有哪些？"></a>Redis缓存刷新策略有哪些？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis提供了以下几种缓存刷新策略<ol><li>基于过期时间：可以设置key的过期时间，当过期时间到达后，Redis会自动删除该key。</li><li>基于LRU算法：Redis使用LRU算法来淘汰最近最少使用的key，以保留热点数据。</li><li>基于LFU算法：Redis使用LFU算法来淘汰最不经常使用的key，以保留热点数据。</li><li>基于手动刷新：可以手动删除缓存中的key，或者通过发送通知来通知客户端删除key。</li><li>基于定时刷新：可以定时清空缓存，或者定时刷新缓存中的数据，以保持数据的及时性。</li></ol></li></ul>              </div>            </details><h1 id="Redis持久化方式有哪些？有什么区别？"><a href="#Redis持久化方式有哪些？有什么区别？" class="headerlink" title="Redis持久化方式有哪些？有什么区别？"></a>Redis持久化方式有哪些？有什么区别？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis提供两种持久化机制：RDB和AOF。</li><li>RDB(Redis DataBase)持久化：会将Redis在内存中的数据快照保存到磁盘上，形成一个RDB文件，该文件包含了Redis在某个时间点上的数据快照<ul><li>优点：<ol><li>只有一个dump.rdb文件，方便持久化     </li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，I/O最大化</li><li>数据集较大时，比AOF的启动效率更高。</li></ol></li><li>缺点：<ol><li>数据安全性较低，RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失，因此这种方式更适合数据要求不严谨的时候。</li></ol></li></ul></li><li>AOF(Append Only File)持久化：是将Redis写操作记录到一个文件中，每次Redis执行一条写命令，就将该命令写入AOF文件中，这样可以保证每条命令都能被保存下来。AOF文件可以进行追加和重写操作，当文件太大时，Redis会自动进行重写，将多次修改合并成一条，以减少磁盘占用空间。<ul><li>优点：<ol><li>数据安全：AOF持久化可以配置<code>appendfsync</code>属性，它可以指定AOF文件的刷盘策略。默认情况下<code>appendfsync</code>的值为<code>everysec</code>。即每秒中将AOF缓存中的数据写入磁盘一次。但是，用户也可以将<code>appendfsync</code>的值设置为<code>always</code>，这样每次执行写操作都会立即将AOF缓存中的数据写入磁盘。这样即使Redis发生异常情况。只要AOF文件中已经记录了相应的写操作，就可以通过AOF文件来恢复数据。</li><li>数据一致性：AOF持久化是通过append模式写入文件的，即每次写操作都是追加到AOF文件末尾。因此，即使Redis在写入AOF文件的过程中宕机，AOF文件也不会损坏，而是只会丢失一部分的数据。当Redis重新启动是，会通过redis-check-aof工具将AOF文件中不一致的数据进行修复，保证数据的一致性。需要注意的是，使用AOF持久化时，如果Redis频繁执行写操作，那么AOF文件可能会非常大，可能影响性能。因此，用户可以通过配置AOF重写规则，定期对AOF文件进行压缩，以减小文件大小。</li></ol></li><li>缺点：<ol><li>AOF文件比RDB文件大，且恢复速度慢。</li><li>数据集较大时，比RDB启动效率低。</li></ol></li></ul></li><li>Redis支持同时使用RDB和AOF持久化机制。在使用时，Redis会先尝试使用AOF文件来恢复数据，如果AOF文件不存在或者恢复失败，Redis会尝试使用RDB文件来恢复数据。同时使用两种持久化机制可以在保证数据完整性的同时提高恢复速度。</li></ul>              </div>            </details><h1 id="持久化有两种，那么该怎么选择呢？"><a href="#持久化有两种，那么该怎么选择呢？" class="headerlink" title="持久化有两种，那么该怎么选择呢？"></a>持久化有两种，那么该怎么选择呢？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>不要仅仅使用RDB，因为那样会导致丢失很多数据。虽然RDB持久化机制的忒但是可以生成数据的快照，这样在恢复数据的时候非常快速。但是RDB持久化只在发生故障时执行，如果Redis崩溃或意外关闭，可能会丢失最近执行的一些命令。因此，建议使用AOF持久化来记录Redis执行的所有写操作，并将RDB持久化用于冷备。</li><li>也不要仅仅使用AOF，虽然AOF持久化机制可以记录Redis执行的所有写操作，因此在数据恢复方面会比RDB更加健壮，但是它也存在一些问题。如果仅使用AOF进行冷备，那么在恢复数据时，它可能会比RDB持久化慢。如果只使用AOF持久化，那么可能会因为AOF文件过大导致性能下降。</li><li>Redis支持同时使用AOF和RDB持久化机制。使用AOF持久化可以保证数据不丢失，并作为数据恢复的首选，使用RDB持久化作为冷备，以提供快速数据恢复选项。这种方式可以利用AOF和RDB持久化机制的优点来提高数据安全性和恢复速度。</li><li>如果同时使用RDB和AOF持久化机制，在Redis重启时，会使用AOF来重构数据，因为AOF中的数据更加完整。</li></ol>              </div>            </details><h1 id="怎么使用Redis实现消息队列？"><a href="#怎么使用Redis实现消息队列？" class="headerlink" title="怎么使用Redis实现消息队列？"></a>怎么使用Redis实现消息队列？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis可以使用list结构作为队列来实现消息队列，使用rpush生产消息，使用lpop消费消息。当lpop没有消息的时候，需要适当的sleep一会儿再重试。但是也可以使用blpop命令来阻塞住，直到消息到来，避免了sleep操作。</li><li>如果需要实现生产一次消费多次的场景，可以使用pub/sub主题订阅者模式，实现<code>1:N</code>的消息队列。</li><li>但是pub/sub的缺点是在消费者下线的情况下，生产的消息会丢失。因此，如果需要更可靠的消息队列，需要使用专业的消息队列，例如RabbitMQ。</li><li>此外，Redis还可以使用sortedset结构来实现延时队列。使用时间戳作为score，消息内容作为key，调用zadd来生产消息。消费者可以使用zrangebyscore指令获取N秒之前的数据，然后轮询进行处理。</li></ul>              </div>            </details><h1 id="说说你对Redis事务的理解"><a href="#说说你对Redis事务的理解" class="headerlink" title="说说你对Redis事务的理解"></a>说说你对Redis事务的理解</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>什么是Redis事务？<ul><li>Redis中的事务是一组命令的集合，是Redis的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会被序列化、按顺序地执行，服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。Redis事务通过MULTI、EXEC、DISCARD、WATCH等命令来实现的。</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">MULTI</td><td style="text-align:center">开启一个事务</td></tr><tr><td style="text-align:center">EXEC</td><td style="text-align:center">提交事务，从命令队列中取出提交的操作命令，进行实际执行</td></tr><tr><td style="text-align:center">DISCARD</td><td style="text-align:center">放弃一个事务，清空命令队列</td></tr><tr><td style="text-align:center">WATCH</td><td style="text-align:center">检测一个或多个键的值在事务执行期间是否发生变化，如果发生变化，那么当前事务放弃执行</td></tr></tbody></table></div><ul><li>Redis事务的注意点有哪些？<ol><li>Redis事务是不支持回滚的。</li><li>Redis服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断，直到事务命令全部执行完毕才会执行其他客户端的命令。</li></ol></li><li>Redis事务为什么不支持回滚？<ul><li>Redis的事务不支持回滚，但是执行的命令如果有语法错误，Redis会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行剩下的命令。这样做的原因是因为回滚需要增加很多工作，而不支持回滚可以保持简单、快速的特性。</li></ul></li></ul>              </div>            </details><h1 id="Redis为什么设计成单线程的？"><a href="#Redis为什么设计成单线程的？" class="headerlink" title="Redis为什么设计成单线程的？"></a>Redis为什么设计成单线程的？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis的单线程设计是其高性能的重要原因之一。Redis单线程的设计思想主要是为了避免多线程带来的上下文切换、锁竞争等开销。从而提高Redis的效率和性能。</li><li>具体来说，Redis单线程的设计主要有以下几个方面的考虑：<ol><li>避免上下文切换：在多线程环境下，线程的切换会涉及到上下文的切换，这个切换本身就就会消耗CPU资源和时间。而Redis单线程的设计可以避免这种上下文切换的开销，从而提高Redis的性能。</li><li>避免锁竞争：在多线程环境下，线程之间共享数据时需要使用锁来保证数据的一致性和可靠性。而所本身也会带来开销和竞争，降低Redis的效率和性能。而Redis单线程的设计可以避免这种锁竞争的开销，从而提高Redis的性能。</li><li>减少内存分配：在多线程环境下，线程之间需要共享内存，而内存共享会涉及到内存分配和管理的开销。而Redis单线程的设计可以避免这种内存分配的开销，从而提高Redis的效率和性能。</li></ol></li></ul>              </div>            </details><h1 id="什么是Bigkey？会存在什么影响？"><a href="#什么是Bigkey？会存在什么影响？" class="headerlink" title="什么是Bigkey？会存在什么影响？"></a>什么是Bigkey？会存在什么影响？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Bigkey指的是Redis中的大键，即占用内存较多的键值对。造成的影响如下：<ol><li>内存占用：Bigkey会占用大量的内存资源，导致Redis内存不足，从而影响Redis的性能和可用性。</li><li>网络传输：Bigkey会增加网络传输的负担，因为在进行数据备份和复制的时候，需要将Bigkey的数据全部传输，从而增加了网络带宽的使用。</li><li>超时阻塞：由于Bigkey占用的空间较大，所以Redis在对其操作时，可能会消耗过长的时间，导致客户端超时阻塞。因为Redis采用单线程模型，当处理一个大key时，其他请求必须等待该操作完成后才能执行，而这个操作可能会需要较长的时间，从而导致阻塞。为了避免这种情况的发生，可以对bigkey进行拆分或优化。</li><li>内存碎片：Bigkey会导致Redis中出现内存碎片，从而影响Redis的内存使用效率，导致Redis内存占用率上升。</li></ol></li></ul>              </div>            </details> <h1 id="说说Redis哈希槽的概念"><a href="#说说Redis哈希槽的概念" class="headerlink" title="说说Redis哈希槽的概念"></a>说说Redis哈希槽的概念</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis哈希槽是Redis集群中用来实现数据分片的一种机制，可以将所有的键均匀地分布到多个节点上，以实现高可用和高性能分布式数据存储。</li><li>具体来说，Redis集群将整个数据集分为16384个哈希槽，每个节点负责其中的一部分哈希槽，节点之间通过Gossip协议进行通信，维护整个集群的状态。当一个客户端想要访问一个键时，Redis会根据键名计算出该键对应的哈希值，然后找到哈希槽的编号，再根据哈希槽的映射关系，将请求路由到对应节点上。</li></ul>              </div>            </details><h1 id="Redis常见性能问题和解决方案有哪些？"><a href="#Redis常见性能问题和解决方案有哪些？" class="headerlink" title="Redis常见性能问题和解决方案有哪些？"></a>Redis常见性能问题和解决方案有哪些？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>网络延迟：Redis的性能很大程度上受限于网络延迟，因此需要尽可能减少网络传输次数和数据量，避免过多的网络IO操作<ul><li>解决方案：可以使用Redis的Pipline特性，将多个请求打包发送，减少网络传输的次数；也可以使用Redis的批量操作命令，将多个数据一次性提交，减少网络传输的数据量。</li></ul></li><li>大量的数据读写：Redis的单线程模型会在高并发读写的情况下出现性能瓶颈，导致响应时间变长。<ul><li>解决方案：可以使用Redis的主从复制和集群特性，将数据分布在多个节点上，增加系统的读写并发能力。</li></ul></li><li>慢查询：当Redis中存在大量慢查询操作时，会影响Redis的整体性能。<ul><li>解决方案：可以使用Redis的slowlog功能，记录Redis的慢查询操作，并使用Redis的监控工具进行监控，及时发现慢查询问题。</li></ul></li><li>内存使用过多：Redis需要将所有的数据存储在内存中，当数据量过大时，会占用大量的内存资源，导致Redis的性能下降。<ul><li>解决方案：可以使用Redis的持久化功能，将数据写入磁盘中，以释放内存空间；也可以使用Redis的内存优化技巧，如删除不必要的数据、合理使用Redis的数据结构等。</li></ul></li><li>阻塞操作：当Redis执行某些操作时，会阻塞其他操作的执行，从而影响Redis的整体性能。<ul><li>解决方案：可以使用Redis的异步操作特性，将阻塞操作转化为异步操作，以提高Redis的性能和吞吐量。</li></ul></li></ol>              </div>            </details><h1 id="如果Redis中有1亿个key，其中有10w个key是以某个固定的已知前缀开头的，如何将它们全部找出来？"><a href="#如果Redis中有1亿个key，其中有10w个key是以某个固定的已知前缀开头的，如何将它们全部找出来？" class="headerlink" title="如果Redis中有1亿个key，其中有10w个key是以某个固定的已知前缀开头的，如何将它们全部找出来？"></a>如果Redis中有1亿个key，其中有10w个key是以某个固定的已知前缀开头的，如何将它们全部找出来？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>我们可以使用keys命令或scan命令，然而在数据量庞大的环境下，不推荐使用keys命令。<ol><li>keys命令是遍历查询的，时间复杂度为O(n)，数据量越大查询时间越长，且Redis是单线程的，使用keys命令会导致线程阻塞一段时间，从而导致Redis会出现假死问题，直到keys命令执行完毕才能恢复，这在生产环境下是不可接受的。此外，keys命令没有分页功能，会一次性查询出所有符合条件的key值，输出的信息非常多。</li><li>相对来说，scan命令比keys命令更适合生产环境。sacn命令可以实现和keys命令相同的匹配功能，但是在执行过程中不会阻塞线程，并且查询的数据可能存在重复，需要客户端去重。因为scan命令是通过游标方式查询的，所以不会导致Redis出现假死问题。Redis在查询过程中会把游标返回给客户端，单词返回控制且游标不为0，则说明遍历还没有结束，客户端继续遍历查询。但是，scan命令在检索的过程中，被删除的元素是不会被查询出来的，如果在迭代过程中有元素被修改，scan命令也不能保证查询出对应的元素。相对来说，scan命令查找花费的时间会比keys命令长。<div class="note info no-icon flat"><ul><li>补充：假死问题<ul><li>Redis假死问题是指当Redis实例在进行某些耗时操作时（例如遍历所有key），由于Redis是单线程的，所以这个操作会导致Redis线程被阻塞，从而导致Redis无法处理其他请求，造成Redis服务不可用的状态。在这种情况下，Redis似乎已经死了，但其实Redis线程仍在执行操作，只是无法处理其他请求而已。因此，这种状态被称为Redis假死问题。避免Redis假死问题的常见方法是使用Redis提供的异步命令和管道技术，以避免在生产环境中会使用遍历所有key的操作。</li></ul></li></ul></div></li></ol></li></ul>              </div>            </details><h1 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>如果大量缓存同时失效，会导致大量的请求直接访问数据库，容易造成数据库崩溃或者降低数据库的性能，进而影响整个系统的稳定性。</li><li>为了预防这种情况的发生，我们最好在设计数据过期时间的时候，都加上一个随机值，让过期时间更加分散，从而尽量避免大量的key在同一时刻失效。</li></ul>              </div>            </details><h1 id="什么情况下可能会导致Redis阻塞？"><a href="#什么情况下可能会导致Redis阻塞？" class="headerlink" title="什么情况下可能会导致Redis阻塞？"></a>什么情况下可能会导致Redis阻塞？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis可能出现阻塞的情况包括：<ol><li>Redis主线程在执行阻塞命令（如<code>BRPOP</code>、<code>BLPOP</code>、<code>BRPOPLPUSH</code>、<code>SUBSCRIBE</code>等）时，会阻塞其他客户端的请求，直到命令执行完毕才能继续处理其他请求。</li><li>Redis主线程在执行某些耗时的命令（如<code>SORT</code>、<code>KEYS</code>等）时，也会阻塞其他客户端的请求，同样需要等待命令执行完毕后才能继续处理其他请求。</li><li>Redis内存使用达到最大限制时，执行写操作（如<code>SET</code>、<code>INCR</code>等）可能会导致Redis阻塞。这是因为Redis需要执行内存回收操作以释放内存空间，如果回收操作耗时过长，就会导致Redis阻塞。</li><li>Redis主从同步过程中，如果主库无法及时响应从库的同步请求，就会导致从库阻塞，无法继续进行数据同步。</li></ol></li><li>对于这些阻塞情况，可以采取一些措施来避免或减少阻塞的影响，例如<ol><li>尽可能使用非阻塞命令，例如<code>LPUSH</code>和<code>RPOP</code>代替<code>BLPOP</code>，使用Lua脚本实现多个操作的原子性等。</li><li>尽量避免使用耗时的命令或对大数据集进行操作，如果必须使用，可以考虑将这些操作放在后台进行。</li><li>设置合理的内存使用上限，同时使用内存淘汰策略来控制内存使用情况。</li><li>配置合理的主从架构，避免主库过于繁忙，导致从库同步阻塞。</li></ol></li></ul>              </div>            </details> <h1 id="怎么提高缓存命中率？"><a href="#怎么提高缓存命中率？" class="headerlink" title="怎么提高缓存命中率？"></a>怎么提高缓存命中率？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>提高缓存命中率可以采取以下措施：<ol><li>预热缓存：在系统启动的时候，将一些热点数据提前加载到缓存中，可以避免在系统运行时出现缓存穿透和缓存雪崩的情况。</li><li>增加缓存容量：增加缓存容量可以缓存更多的数据，从而提高缓存命中率。</li><li>优化缓存设计：合理的缓存设计是提高缓存命中率的前提，包括选择合适的数据结构、缓存过期时间、缓存的key命名等。</li><li>使用多级缓存：多级缓存可以将热点数据缓存在更快速、容量更小的缓存中，减少从慢速缓存或者数据库中读取数据的次数。</li><li>缓存穿透处理：针对一些缓存中不存在，但是经常被查询的数据，可以采取布隆过滤器或设置空值等方式来进行预判，避免缓存穿透的情况。</li><li>建立读写分离的架构：将读请求和写请求分别处理，读请求可以直接从缓存中读取数据，写请求更新数据库后再更新缓存，从而避免缓存和数据库的一致性问题。</li></ol></li></ul>              </div>            </details><h1 id="Redis如何解决key冲突？"><a href="#Redis如何解决key冲突？" class="headerlink" title="Redis如何解决key冲突？"></a>Redis如何解决key冲突？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>如果两个key的名字相同，后一个key会覆盖前一个key。因此，为了避免key冲突，最好为每一个key取一个独特的、易于辨识的名称。</li><li>通常可以使用业务名和参数来区key，这样可以避免key冲突，同时也方便业务逻辑的管理和维护。</li></ul>              </div>            </details><h1 id="Redis报内存不足怎么处理？"><a href="#Redis报内存不足怎么处理？" class="headerlink" title="Redis报内存不足怎么处理？"></a>Redis报内存不足怎么处理？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>可以考虑以下几种处理方式：<ol><li>增加物理内存：增加Redis所在服务器的物理内存，可以让Redis有更多的空间来存储数据。</li><li>减少数据量：可以删除一些已经不再使用的数据，或者将一些数据进行持久化，以释放内存。设置缓存淘汰策略，提高内存的使用效率。</li><li>修改Redis配置：可以调整Redis配置文件中的一些参数，如maxmemory等，增加Redis可用内存。</li><li>使用Redis集群：可以将数据分散在多个Redis节点中，每个节点存储一部分数据，从而减少单个Redis实例的内存使用量。</li></ol></li></ul>              </div>            </details> <h1 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级都了解吗？"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级都了解吗？" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级都了解吗？"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级都了解吗？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>简述其概念如下<ol><li>缓存雪崩：指在某个时间段内缓存集体过期失效或缓存服务重启，导致大量请求都落到数据库上，从而导致数据库崩溃的情况。</li><li>缓存穿透：指查询一个不存在的数据，由于缓存没有命中，导致所有的请求都会到数据库上，造成数据库压力过大，严重的可能会导致数据库宕机。</li><li>缓存预热：指系统上线后，将相关的缓存数据直接加载到缓存系统中，避免在用户请求过程中因没有预先加载而导致缓存穿透的现象。</li><li>缓存更新：指对数据库中的数据更新时，同时更新缓存中的数据，保证缓存数据和数据库的一致性。</li><li>缓存降级：指在缓存失效或缓存访问异常时，为了保证系统的可用性，通过一些机制，将请求转发到其他服务或者直接返回默认值，从而避免系统崩溃或者因为缓存故障导致业务受损。</li></ol></li><li>常见的Redis缓存降级策略包括：<ol><li>熔断降级：当Redis缓存故障或者超时时，系统会进入熔断状态，所有请求奖杯转发到备用服务或者直接返回默认值。</li><li>限流降级：当Redis缓存无法处理所有请求时，系统会采用限流策略，限制访问流量，保护系统资源，避免系统崩溃。</li><li>数据降级：当Redis缓存故障时，系统可以返回默认值，避免因缓存故障导致业务受损。</li></ol></li></ul>              </div>            </details><h1 id="热点数据和冷数据是什么？"><a href="#热点数据和冷数据是什么？" class="headerlink" title="热点数据和冷数据是什么？"></a>热点数据和冷数据是什么？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>热点数据和冷数据是根据数据被访问的频率来进行划分的。<ul><li>热点数据值的是被频繁访问的数据，通常是系统的核心数据，例如热门商品、热门文章、热门活动等，这些数据的访问量非常高，如果没有得到有效的缓存优化，系统将会面临严重的性能问题。</li><li>冷数据则相反，指的是不经常被访问的数据，它们的数据访问频率较低，例如旧的文章、过期的活动等。</li></ul></li><li>了解热点数据和冷数据对于缓存设计和优化非常重要，因为不同的数据需要采用不同的缓存策略。<ul><li>例如对于热点数据需要采用缓存预热、缓存更新等策略来保证缓存的命中率，而对于冷数据则可以采用懒加载等策略来避免不必要的缓存开销。</li></ul></li></ul>              </div>            </details><h1 id="Memcached和Redis的区别都有哪些？"><a href="#Memcached和Redis的区别都有哪些？" class="headerlink" title="Memcached和Redis的区别都有哪些？"></a>Memcached和Redis的区别都有哪些？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Memcached和Redis是两种常用的缓存系统，它们的区别如下：<ol><li>数据类型：Redis支持更丰富的数据类型，包括字符串、哈希、列表、集合、有序集合等，而Memcached仅支持简单的键值对存储。</li><li>持久化：Redis支持数据的持久化，可以将数据写入磁盘，而Memcached不支持数据的持久化。</li><li>分布式支持：Memcached天生支持分布式，多个节点可以组成一个集群，而Redis的分布式支持需要通过集群、分片等方式实现。</li><li>性能：在单机环境下，Redis的性能通常比Memcached更好，但在分布式环境下，由于网络通信开销的增加，两者的性能差距可能会减小。</li><li>缓存策略：Redis支持更多的缓存策略，比如LRU（最近最少使用）、LFU（最少使用）、随机等，而Memcached仅支持LRU。</li><li>应用场景：Redis更适合需要丰富数据类型、支持持久化、缓存策略较多、单机性能较好的场景；而Memcached更适合需要高速读写、分布式支持、缓存策略相对简单的场景。</li></ol></li></ul>              </div>            </details><h1 id="Redis的数据类型，以及每种数据类型的使用场景？"><a href="#Redis的数据类型，以及每种数据类型的使用场景？" class="headerlink" title="Redis的数据类型，以及每种数据类型的使用场景？"></a>Redis的数据类型，以及每种数据类型的使用场景？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>常见的几种数据类型和使用场景如下：<ol><li>字符串(String)：字符串类型是Redis最基本的数据结构，一个键最大能存储512MB。<ul><li>使用场景：适用于计数器、分布式锁、缓存等常见。</li></ul></li><li>列表(List)：列表是链表结构，可以在头部和尾部添加元素。<ul><li>使用场景：可以做简单的消息队列功能。利用Irange命令，做基于Redis的分页功能。</li></ul></li><li>集合(Set)：集合是通过哈希表实现的无序集合，每个元素都是独一无二的。<ul><li>使用场景：适用于好友关系、共同好友等去重和计算交集、并集、差集的场景。</li></ul></li><li>哈希(Hash)：哈希结构类似于关联数组，由字段和值组成。<ul><li>使用场景：适用于对象缓存。</li></ul></li><li>有序集合(Sorted Set)：有序集合类似于集合，不同的是每个元素都会关联一个权重(score)，按照权重进行排序。<ul><li>使用场景：排行榜、带权重的任务队列等场景。</li></ul></li><li>位图(BitMap)：用于存储二进制位的数据结构，可以进行位运算，支持高效的位图计算。<ul><li>使用场景：用户签到记录。</li></ul></li><li>地理位置(Geo)：用于存储地理位置信息的数据结构。<ul><li>使用场景：附近的酒店、餐厅。</li></ul></li><li>HyperLogLog：用于进行基数计数的数据结构，支持高效的对大量元素进行去重统计。<ul><li>使用场景：网站的UV统计。</li></ul></li></ol></li></ul>              </div>            </details><h1 id="Redis的过期策略以及内存淘汰机制"><a href="#Redis的过期策略以及内存淘汰机制" class="headerlink" title="Redis的过期策略以及内存淘汰机制"></a>Redis的过期策略以及内存淘汰机制</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis的过期策略和内存淘汰机制如下：<ol><li>过期策略：Redis中可以设置key的过期时间，过期时间到期后，key将会自动被删除。Redis提供了两种不同的过期策略：<ul><li>定时删除：在设置key过期的同时，创建一个定时器，当过期时间到达时，就会立即删除该key。</li><li>惰性删除：再获取某个key的值时，先检查该key是否过期，如果过期就删除，否则返回该key的值。</li><li>Redis默认使用惰性删除策略。</li></ul></li><li>内存淘汰机制：当Redis内存达到了最大限制时，需要从内存中删除一些数据。Redis提供了多种内存淘汰机制：<ul><li>noeviction：当内存空间不足以容纳新写入数据时，新写入操作会报错，这种方式不会删除任何数据，应该只用于特殊场景。</li><li>allkeys-lru：当内存空间不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（LRU算法）。这是Redis默认的淘汰策略。</li><li>allkeys-random：从所有key中随机选择一些进行删除。</li><li>volatile-lru：当内存空间不足以容纳新写入数据时，再设置了过期时间的键空间中，移除最近最少使用的key（LRU算法）。</li><li>volatile-ramdom：从设置了过期时间的key中随机选择一些进行删除。</li><li>volatile-ttl：从设置了过期时间的key中，根据过期时间的先后顺序进行删除，越早过期的越优先删除。</li></ul></li></ol></li></ul>              </div>            </details><h1 id="为什么Redis的操作是原子性的，怎么保证原子性？"><a href="#为什么Redis的操作是原子性的，怎么保证原子性？" class="headerlink" title="为什么Redis的操作是原子性的，怎么保证原子性？"></a>为什么Redis的操作是原子性的，怎么保证原子性？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis的操作是原子性的，是因为Redis是单线程的，Redis中的所有操作都是在一个单线程中执行，这样就可以避免并发的环境下多个线程同时修改同一个键值对的问题。在Redis中，任何一个操作都是原子性的，要么执行成功，要么执行不成功。如果一个操作包含多个步骤，那么这些步骤会被当成一个整体，要么全部执行成功，要么全部不执行。</li><li>Redis保证原子性的方式主要有两种：事务和Lua脚本。在事务中，Redis会将多个命令打包成一个事务进行执行，事务中的所有命令都会在一次操作中被执行，要么全部执行成功，要么全部不执行。而Lua脚本则可以将多个操作打包成一个原子性的操作进行执行，这个操作要么全部执行成功，要么全部不执行。另外，Redis还提供了一些原子性操作，例如INCR、DECR等，这些操作都是原子性的。</li><li>在并发环境下，如果多个线程同时执行get和set命令，可能会出现竞争条件，从而导致数据不一致的问题。但是如果使用Redis提供的原子性操作INCR，则不会存在这种问题，因为INCR命令是原子性的。</li><li>因此可以使用Redis事务或者Redis+Lua的方式保证多个命令在并发中的原子性，或者使用Redis提供的原子性操作。</li></ul>              </div>            </details><h1 id="面试模拟"><a href="#面试模拟" class="headerlink" title="面试模拟"></a>面试模拟</h1><ul><li>面试官：什么是缓存穿透？怎么解决？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>emm，我想一下<ul><li>缓存穿透是指查询一个不存在的数据，如果从存储层查询不到数据，则不会写入缓存，此时就会导致每次请求这个不存在的数据，都会到DB里去查询，可能会导致DB挂掉，这种情况大概率是遭到了攻击。</li><li>解决方案的话，一般可以缓存空数据，即缓存这个不存在的数据。另外一种解决方案就是使用布隆过滤器</li></ul></li></ul>              </div>            </details></li><li>面试官：好的，那你能介绍一下布隆过滤器吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，是这样<ul><li>布隆过滤器主要是用于检索一个元素绝对不在集合中或可能在集合中。它的底层主要是先去初始化一个比较大的数组，里面存放二进制的0或1，在一开始都是0，当一个key来了之后经过3个哈希函数的计算，模于数组长度找到数据的下标，然后把下标位置的0改为1，这样的话，三个数组下标的位置就能标明一个key的存在，查找的过程也是一样的。</li><li>当然这个也是有缺点的，布隆过滤器可能存在一些误判，我们一般是可以设置这个误判率的，大概不会超过5%，因为哈希冲突不可能避免，所以这个误判是必然存在的，要不然就增加数组长度。但其实5%的误判率一般项目也是能接受的，不至于高并发下压倒数据库。<br><img src="https://s1.ax1x.com/2023/07/23/pCq6DtP.png" alt=""></li><li>用上图来举个例子<ol><li>初始化布隆过滤器为 16 位，每一位初始值都为 0。</li><li>将 <code>Fredy</code> 录入布隆过滤器，经过三个哈希函数的计算，将第 1、3、7 位设为 1。</li><li>将 <code>Eli</code> 录入布隆过滤器，经过三个哈希函数的计算，将第 10、12、15 位设为 1。</li><li>查询 <code>Tom</code>，经过三个哈希函数的计算，得到第 0、2、5 位，这三个位置上的数字都是 0。根据布隆过滤器的规则，可以判断 <code>Tom</code> 绝对不在数据库中。</li><li>查询 <code>Lily</code>，经过三个哈希函数的计算，得到第 7、12、15 位，这三个位置上的数字都是 1。这里需要澄清一点：虽然这三个位置上的数字都是 1，但布隆过滤器只能判断 <code>Lily</code> 可能存在于数据库中，而不能确定 <code>Lily</code> 真的在数据库中。因为这三个位上的 1 可能是由 <code>Fredy</code> 和 <code>Eli</code> 共同组成的，所以存在一定的误判率。</li><li>当布隆过滤器判断数据一定不存在，就不用查询数据库，直接返回不存在的结果。当布隆过滤器判断可能存在，那么查询数据库，以确认元素是否真的存在。</li></ol></li></ul></li></ul>              </div>            </details></li><li>面试官：什么是缓存击穿？怎么解决？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>emm，我想想<ul><li>缓存击穿是指在缓存中设置了过期时间的某个key，在某个时间点这个key正好过期，导致缓存失效，恰好此时有大量病发情趣同时访问该key，这些请求会直接访问后端数据库，造成数据库压力骤增，严重影响系统性能，甚至直接压垮数据库。</li><li>解决方案的话，我了解的有两种<ul><li>方案一：使用互斥锁<ol><li>当缓存失效时，不立即去加载数据库，而是先使用Redis的<code>SETNX</code>(Set if Not Exists)命令去设置一个互斥锁，只有一个请求能够成功设置互斥锁，其他请求会在这一步被阻塞</li><li>成功设置互斥锁的请求，再去加载数据库，并将加载的数据回设到缓存中</li></ol></li><li>方案二：逻辑过期<ol><li>在设置缓存key的同时，额外存储一个过期时间字段到缓存中，但是不给当前key设置过期时间</li><li>当查询请求到达时，首先从缓存中取出数据，并且额外判断一下存储key的过期时间字段，若过期则认为缓存失效</li><li>当缓存失效时，开启另外一个线程进行数据的异步加载和缓存更新，当前请求直接返回缓存中的旧数据，但这部分数据可能不是最新</li><li>这种方案一定程度上保证了高可用性，避免了大量请求直接打到数据库。</li></ol></li></ul></li><li>当然两种方案各有利弊<ul><li>方案一使用了互斥锁，保证了数据的强一致性，到哪性能可能会受到锁的竞争影响，而且需要考虑死锁的问题</li><li>方案二优先考虑的是高可用和性能，但不能保证强一致性，有可能会出现缓存和数据库数据不一致的情况。</li><li>实际使用中根据我们的需求来选择要保证一致性还是可用性。</li></ul></li></ul></li></ul>              </div>            </details></li><li>面试官：什么是缓存雪崩？怎么解决？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>缓存雪崩是指换成那种设置了相同的过期时间，导致大量缓存在同一时刻同时失效，进而导致所有的请求直接转发到了后端数据库，导致数据库瞬时压力过大，可能直接压垮数据库。它与缓存击穿的区别在于，缓存雪崩是很多key同时失效，而缓存击穿是某一个key缓存失效</li><li>解决方案主要是在设置缓存的时候，可以给每个缓存的过期时间加上一个随机值，例如在原有的失效时间基础上，再加上一个1~5分钟的随机值。</li></ul>              </div>            </details></li><li>面试官：Redis作为缓存，MySQL的数据如何与Redis进行同步呢？（双写一致性问题）</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，这个需要分为两种情况。<ul><li>保证强一致性：使用读写锁。<ul><li>如果是需要保证强一致性的话，可以采用Redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写、读读都互斥，这样能保证在写数据的同时不会让其他线程来读数据，避免其他线程读到脏数据。这里需要注意读方法和写方法上需要使用同一把锁。</li><li>排他锁的底层使用的也是setnx，保证同时只有一个线程操作被锁住的方法</li></ul></li><li>然后不追求强一致性，数据同步可以有一定的延时。<ul><li>可以采用阿里的canal组件来实现数据同步：不需要更改业务代码，部署一个canal服务，canal服务会把自己伪装成MySQL的一个从节点，当MySQL数据更新以后，canal会读取binlog数据，然后通过canal的客户端获取到数据，更新缓存即可。</li></ul></li></ul></li></ul>              </div>            </details></li><li>面试官：Redis作为缓存，数据的持久化是怎么做的呢？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在Redis中提供了两种数据持久化的方法<ol><li>RDB<ul><li>RDB是一个快照文件，它是把Redis内存存储的数据写到磁盘上，当Redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。</li></ul></li><li>AOF  <ul><li>AOF的含义是追加文件，当Redis操作写命令的时候，都会存储到这个文件中，当Redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。</li></ul></li></ol></li></ul>              </div>            </details></li><li>面试官：那这两种方式，哪种恢复的比较快呢？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><p>RDB因为是二进制文件，在保存的时候体积也是比较小的，所以恢复的比较快，但是它有可能会丢失数据，因为Redis内部设置了触发RDB的机制，所以可能会丢失一段时间的缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 900秒内，如果至少有1个key发生了变化，则触发一次持久化操作</span><br><span class="line">save 300 10     # 300秒内，10个key变化</span><br><span class="line">save 60 10000   # 60秒内，10000个key变化</span><br></pre></td></tr></table></figure></li><li><p>AOF恢复的速度慢一些，但是它丢失数据的风险要小很多，在Redis的配置文件中也可以配置AOF的刷盘策略，采用everysec的话，最多丢失一秒的数据</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">刷盘时机</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">Always</td><td style="text-align:center">同步刷盘</td><td style="text-align:center">可靠性高，几乎不丢数据</td><td style="text-align:center">性能影响大</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒刷盘</td><td style="text-align:center">性能适中</td><td style="text-align:center">最多丢失1秒数据</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">操作系统控制</td><td style="text-align:center">性能最好</td><td style="text-align:center">可靠性较差，可能丢失大量数据</td></tr></tbody></table></div><ul><li>实际环境中，都是结合使用RDB和AOF来使用的。</li></ul>              </div>            </details></li><li>面试官：Redis的数据过期策略有哪些？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，Redis提供了两种数据过期删除策略<ul><li>第一种是惰性删除，在设置key过期时间后，我们不去管它，当我们需要使用该key时，我们再检查其是否过期，如果过期，我们就删除它，没过期，我们就返回该key。这种方法的缺点是，如果有大量冷数据，长时间不会被使用到，会占用内存空间，不会被及时清理掉。</li><li>第二种是定期删除，每隔一段时间，我们就对一些key进行检查，删除里面已经过期的key。定期清理的两种模式<ol><li>SLOW模式是定时任务，执行频率默认为10HZ，每次不超过25ms，不过也可以通过Redis的配置文件来手动配置</li><li>FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms</li></ol></li><li>Redis的过期删除策略，一般都是结合这二者一起来使用的。</li></ul></li></ul>              </div>            </details></li><li>面试官：Redis的数据淘汰策略有哪些？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，Redis支持八种不同的策略来选择要删除的key<ol><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰，LRU的意思是最近最少使用</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰，LFU的意思是最少频率使用</li><li>volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰</li></ol></li></ul>              </div>            </details></li><li>面试官：假如数据库中有1000w数据，Redis中只能缓存20w条数据，如何保证Redis中的数据都是热点数据</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，这个问题可以从Redis的数据淘汰策略来考虑，如果需要保留热点数据，那么可以根据最近最少使用来淘汰数据，即LRU算法，这样剩下的就是热点数据了。</li></ul>              </div>            </details></li><li>面试官：Redis内存用完了会发生什么？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，这个问题得看配置的Redis数据淘汰策略是什么，如果是默认的配置，Redis内存用完以后直接报错，可以根据自己的需求来设置数据淘汰策略，我一般都是使用的LRU来淘汰数据。</li></ul>              </div>            </details></li><li>面试官：Redis的分布式锁如何实现</li><li><p>候选人：</p><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，Redis中提供了一个SETNX命令，即Set if Not Exists<ul><li>由于Redis是单线程的，所以使用该命令后，只能有一个客户端对某一个key设置值，在没有过期或删除该key之前，其他客户端是不能设置这个key的</li></ul></li></ul>              </div>            </details></li><li><p>面试官：那你是如何控制Redis实现分布式锁的有效时长呢？</p></li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，采用Redis的SETNX命令确实不太好控制这个时长，但是可以采用Redis的一个框架，Redisson来实现。<ul><li>在Redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成时，Redisson的看门狗机制会每隔一段时间来检查当前业务是否还持有锁，如果持有锁，就增加锁的持久时间，当业务执行完成之后手动释放锁即可。</li></ul></li></ul>              </div>            </details></li><li>面试官：Redis集群有哪些方案？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Redis提供的集群方案有三种：主从复制、哨兵模式、Redis分片集群</li></ul>              </div>            </details></li><li>面试官：那你来介绍一下主从同步</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>嗯，是这样的，单节点的Redis并发能力有限，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写入数据，从节点负责读数据，主节点写入数据之后，需要将数据同步到从节点中。</li></ul>              </div>            </details></li><li>面试官：那你继续说一下主从同步的流程吧</li><li><p>候选人：</p><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>主从同步分为两个阶段，一个是全量同步，一个是增量同步<ul><li>全量同步是指从节点第一次与主节点建立连接的时候<ol><li>从节点请求主节点同步数据，从节点会携带自己的replication id和offset偏移量</li><li>主节点判断是否是第一次请求，判断的依据是，主节点与从节点是否是同一个replication id，然后不是，那主节点就会把自己的replication id和offset发送给从节点，让主节点和从节点的信息保持一致</li><li>与此同时，主节点会执行bgsave，生成RDB文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发来的RDB文件，这样就保持了一致。</li><li>如果在从节点执行RDB文件的期间，仍有请求到了主节点，那么主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就保证了主节点和从节点数据完全一致，后期再进行同步数据的时候，都是依赖于这个日志文件。这个就是全量同步</li></ol></li><li>增量同步是指，当从节点服务重启之后，数据不一致了，这个时候，从节点会请求主节点同步数据，主节点还是先判断是不是第一次请求，判断的语句还是replication id，不是第一次请求的话，就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步。</li></ul></li></ul>              </div>            </details></li><li><p>面试官：怎么保证Redis的高并发高可用</p></li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>首先可以搭建主从集群，再加上使用Redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障回复、通知；如果主节点故障，哨兵会将一个从节点提升为主节点，当故障实例恢复正常之后，也是以最新的主节点为主。同时哨兵也充当Redis客户端的服务发现来源，当集群发生故障转移的时候，会将最新消息推送给Redis客户端，所以一般项目都会采用哨兵模式来保证Redis的高并发高可用</li></ul>              </div>            </details></li><li>面试官：Redis是单线程的，为什么还那么快？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>首先Redis完全是基于内存的，内存的读写速度是非常快的，并且Redis是由C语言编写的</li><li>采用单线程，可以避免不必要的上下文切换的竞争条件</li><li>使用I/O多路复用模型，非阻塞IO<ul><li>I/O多路复用指的是利用单个线程来监听多个socket，并在某个socket就绪的时候，得到通知，从而避免无效的等待，充分利用CPU资源。目前I/O多路复用都是采用的epoll模式实现，它会通知用户进程socket就绪的同时，把已就绪的socket写入用户空间，不需要挨个遍历socket来判断是否就绪。提升了性能。</li></ul></li><li>Redis的网络模型使用I/O多路复用结合事件处理器来应对多个socket请求，例如，提供了连接应答处理器、命令回复处理器、命令请求处理器。<ul><li>Redis因为是基于内存的，内存读写速度非常快，所以性能瓶颈不在内存，而是在网络I/O，具体是在命令的解析这一块，假如很多的客户端都来读数据，那么他们都会携带自己的命令，Redis需要接收网络请求的数据，转化为Redis命令，那么Redis此时可能就忙不过来了。在Redis 6.0之后引入了多线程，用于解析网络请求。但是真正去执行命令的时候，还是使用的单线程。</li></ul></li></ol>              </div>            </details></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven知识点</title>
      <link href="/2023/05/08/Maven%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/05/08/Maven%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Maven？"><a href="#什么是Maven？" class="headerlink" title="什么是Maven？"></a>什么是Maven？</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>              <ul><li>Maven是一个开源的项目管理和构建工具，用于帮助开发人员自动化构建、测试和部署Java项目。它提供了一个标准化的项目结构和一套强大的构建规则，以及丰富的插件生态系统，使得项目的构建和依赖管理变得简单和可靠。</li><li>Maven的核心概念包括项目对象模型（Project Object Model，POM）、坐标、依赖管理和生命周期。项目对象模型是一个XML文件，描述了项目的基本信息、依赖信息、插件配置等。</li><li>依赖管理功能可以让开发人员方便的生命和管理项目所依赖的外部库和模块。生命周期定义了一系列的构建阶段和插件目标，开发人员可以根据需求执行不同的构建任务。</li></ul>              </div>            </details><h1 id="Maven能为我们解决什么问题？"><a href="#Maven能为我们解决什么问题？" class="headerlink" title="Maven能为我们解决什么问题？"></a>Maven能为我们解决什么问题？</h1><details class="folding-tag" cyan><summary>  </summary>    <div class='content'>              <ol><li>添加第三方jar包<ul><li>使用Maven之前，我们都是手动复制jar包到项目的<code>WEB-INF/lib</code>下，每个项目都会有一份，造成大量重复文件。而Maven将jar包放在本地仓库中统一管理，需要jar包只需要用坐标的方式引用即可。</li></ul></li><li>jar包之间的依赖关系<ul><li>jar包之间往往是不独立的，很多jar包需要在其他jar包的支持下才能够正常工作，成为jar包之间的依赖关系，如果我们手动去导入，要知道jar包之间的依赖关系并一一导入，这样是极其麻烦而且容易出错的。如果我们使用maven，它能够将当前jar包所依赖的其他所有jar包全部导入。</li></ul></li><li>获取第三方jar包<ul><li>开发过程中我们需要用到很多jar包，每个jar包在官网的获取方式不尽相同，给工作带来了额外的困扰。但是使用Maven可以以坐标的方式依赖一个jar包，Maven从中央仓库进行下载，并同时下载这个jar包依赖的其他jar包</li></ul></li><li>将项目拆分为过个工程模块<ul><li>随着项目的规模越来越大，已经不可能通过package结构来划分模块，必须将项目拆分为多个工程协同开发。</li></ul></li></ol>    </div></details><h1 id="说说Maven有什么优缺点？"><a href="#说说Maven有什么优缺点？" class="headerlink" title="说说Maven有什么优缺点？"></a>说说Maven有什么优缺点？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>优点<ol><li>简化了项目依赖管理</li><li>易于上手，对于新手来说，了解几个常用命令即可满足日常工作需求</li><li>便于与持续集成工具（jenkins）整合</li><li>便于项目升级，无论是项目本身还是项目使用的依赖</li><li>maven有很多插件，便于功能扩展，例如生产站点、自动发布版本等</li></ol></li><li>缺点<ul><li>Maven是一个庞大的构建系统，学习难度大，入门容易但精通难</li><li>Maven采用约定大于配置的策略，虽然上手容易，但一旦出现问题，很难调试（例如网络环境较差，导致很多repository无法访问）</li></ul></li></ul>              </div>            </details><h1 id="什么是Maven的坐标？"><a href="#什么是Maven的坐标？" class="headerlink" title="什么是Maven的坐标？"></a>什么是Maven的坐标？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Maven坐标是用于唯一标识一个项目或模块的信息，它由一组固定的属性组成，包括groupId、artifactId和Version<ul><li>groupId(组织名称)：用于表示项目所属的组织或团队，一般情况下，它的命名是翻转的域名（com.example），但也可以根据实际需求来自定义。</li><li>artifactId(项目组织)：artifactId是指项目的唯一标识符，用于区分不同的项目。它通常是项目的名称，用于在仓库中唯一标识一个项目，在同一个groupId下，不同的项目应该有不同的artifactId</li><li>version(版本号)：version表示项目的版本号。它用于区分不同版本的项目，以便在依赖管理和构建过程中正确选择和使用。版本号可以采用标准的数字格式（例如1.0、2.1.7）或其他约定的格式。</li></ul></li><li>通过组合这些属性，Maven的坐标提供了一种唯一标识的定位项目的方式。在依赖管理中，其他项目可以通过引用该坐标来声明对该项目的依赖。Maven会根据这些坐标信息，自动下载并引入所需的依赖项。</li></ul>              </div>            </details><h1 id="讲一下maven的生命周期"><a href="#讲一下maven的生命周期" class="headerlink" title="讲一下maven的生命周期"></a>讲一下maven的生命周期</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th style="text-align:center">阶段</th><th style="text-align:center">处理</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">validate</td><td style="text-align:center">验证项目</td><td style="text-align:center">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td style="text-align:center">compile</td><td style="text-align:center">执行编译</td><td style="text-align:center">源代码编译在此阶段完成</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center">测试</td><td style="text-align:center">使用适当的单元测试框架(例JUnit)运行测试</td></tr><tr><td style="text-align:center">package</td><td style="text-align:center">打包</td><td style="text-align:center">创建JAR/WAR包如在 pom,xml 中定义提及的包</td></tr><tr><td style="text-align:center">verify</td><td style="text-align:center">检查</td><td style="text-align:center">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td style="text-align:center">install</td><td style="text-align:center">安装</td><td style="text-align:center">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td style="text-align:center">deploy</td><td style="text-align:center">部署</td><td style="text-align:center">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table></div>              </div>            </details><h1 id="说说你熟悉哪些maven命令？"><a href="#说说你熟悉哪些maven命令？" class="headerlink" title="说说你熟悉哪些maven命令？"></a>说说你熟悉哪些maven命令？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th style="text-align:center">Maven 命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">mvn archetype:generate</td><td style="text-align:center">创建 Maven 项目</td></tr><tr><td style="text-align:center">mvn compile</td><td style="text-align:center">编译源代码</td></tr><tr><td style="text-align:center">mvn deploy</td><td style="text-align:center">发布项目</td></tr><tr><td style="text-align:center">mvn test-compile</td><td style="text-align:center">编译测试源代码</td></tr><tr><td style="text-align:center">mvn test</td><td style="text-align:center">运行应用程序中的单元测试</td></tr><tr><td style="text-align:center">mvn site</td><td style="text-align:center">生成项目相关信息的网站</td></tr><tr><td style="text-align:center">mvn clean</td><td style="text-align:center">清除项目目录中的生成结果</td></tr><tr><td style="text-align:center">mvn package</td><td style="text-align:center">根据项目生成的 JAR</td></tr><tr><td style="text-align:center">mvn install</td><td style="text-align:center">在本地 Repository 中安装 JAR</td></tr><tr><td style="text-align:center">mvn eclipse:eclipse</td><td style="text-align:center">生成 Eclipse 项目文件</td></tr><tr><td style="text-align:center">mvn jetty:run</td><td style="text-align:center">启动 Jetty 服务</td></tr><tr><td style="text-align:center">mvn tomcat:run</td><td style="text-align:center">启动 Tomcat 服务</td></tr><tr><td style="text-align:center">mvn clean package -Dmaven.test.skip=true</td><td style="text-align:center">清除以前的包后重新打包，跳过测试类</td></tr></tbody></table></div>              </div>            </details><h1 id="如何解决依赖传递引起的版本冲突？"><a href="#如何解决依赖传递引起的版本冲突？" class="headerlink" title="如何解决依赖传递引起的版本冲突？"></a>如何解决依赖传递引起的版本冲突？</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <p>可以通过在依赖项声明中使用<code>&lt;exclusions&gt;</code>标签来排除特定的传递依赖项。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>example-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>conflicting-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>conflicting-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>              </div>            </details><h1 id="说说maven的依赖原则"><a href="#说说maven的依赖原则" class="headerlink" title="说说maven的依赖原则"></a>说说maven的依赖原则</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>最短路径原则（依赖传递的路径越短越优先）</li><li>pom文件申明顺序优先（路径长度一样，则先申明的优先）</li><li>覆写原则（当前pom文件里申明的直接覆盖父工程传过来的）</li></ol>              </div>            </details>            <h1 id="说说依赖的解析机制"><a href="#说说依赖的解析机制" class="headerlink" title="说说依赖的解析机制"></a>说说依赖的解析机制</h1><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>读取POM文件：Maven首先读取项目的POM文件，其中包含了项目依赖的配置信息。</li><li>解析依赖坐标：Maven解析POM文件中的依赖坐标，包括groupId、artifactId和version等信息，这些坐标唯一标识了一个依赖项。</li><li>检查本地仓库：Maven首先检查本地仓库（通常位于用户目录的.m2目录下），看是否已经存在所需的依赖项。如果已经存在，并且版本匹配，则直接使用本地仓库中的依赖项，无需下载。</li><li>下载依赖项：如果本地仓库中不存在所需的依赖项，或者版本不匹配，Maven会尝试从配置的远程仓库（如Maven中央仓库）下载依赖项。Maven会根据依赖坐标构建远程仓库的URL，下载相应的JAR文件。</li><li>解析依赖关系：Maven解析依赖项的传递关系。它会检查所下载的依赖项的POM文件，找到他们的传递依赖项，并重复以上步骤来解析和下载传递依赖项。</li><li>版本冲突解决：当存在多个依赖项的不同版本时，Maven使用冲突解决机制来确定最终使用的版本。通常会选择路径最短的依赖项（最短路径原则）或者根据POM文件中声明顺序选择优先的版本。</li><li>构建依赖树：Maven根据解析结果构建一个依赖树，表示项目的依赖关系和层次结构。这个依赖树包括直接依赖和传递依赖。</li><li>传递依赖管理：Maven会将解析的依赖项添加到项目的类路径中，以便在编译、测试和运行时使用。它还会管理传递依赖的范围和冲突解决。</li></ol>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis知识点</title>
      <link href="/2023/05/05/MyBatis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/05/05/MyBatis%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ol><li>什么是MyBatis<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>MyBatis是一款基于Java的持久层框架，它提供了一种简单的方式来映射数据库操作到Java对象。它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态SQL，可以严格控制SQL执行性能，灵活度高</li><li>MyBatis可以使用XML或注解来配置映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有JDBC代码和手动设置参数以获取结果集</li><li>通过XML文件或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中的SQL的动态参数进行映射生成最终执行的SQL语句，最后由MyBatis框架执行SQL并将结果映射为Java对象并返回</li></ul>              </div>            </details></li><li>说说MyBatis的优点和缺点<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>优点  <ol><li>基于SQL语句编程，相当灵活，不会对应用程序或数据库的现有设计造成任何影响，SQL写在XML里，解除SQL与程序代码的耦合（用注解写就另说了），便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li><li>提供应设标签，支持对象与数据库的ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护</li></ol></li><li>缺点<ol><li>SQL语句编写的工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li><li>XML配置较为繁琐，MyBatis的配置文件中需要编写大量的XML代码来描述SQL语句和映射关系，这可能会使配置文件显得较为繁琐</li></ol></li></ul>              </div>            </details></li><li><code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>的区别是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在MyBatis中，<code>#&#123;&#125;</code>和<code>$&#123;&#125;</code>都是用来表示参数占位符的。不过它们的使用方式略有不同<ul><li><code>#&#123;&#125;</code>在SQL语句中表示一个占位符，它可以防止SQL注入攻击，并且可以自动进行参数类型转换。在执行SQL语句时，MyBatis会将参数值以安全的方式设置到SQL语句中。底层使用的是<code>PreparedStatement</code>，<code>#&#123;&#125;</code>占位符替换为<code>?</code></li><li><code>$&#123;&#125;</code>在SQL语句中也表示一个占位符，但它不会对参数进行任何处理，直接将参数值拼接到SQL语句中，因此容易引发SQL注入攻击。底层使用的是<code>Statement</code></li></ul></li></ul>              </div>            </details></li><li>当实体类中的属性名和表中的字段名不一致时怎么办<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>通过在查询的SQL语句中定义字段名的别名，让其别名与实体类的属性名一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectorder”</span> <span class="attr">parametertype</span>=<span class="string">”int”</span> <span class="attr">resultetype</span>=<span class="string">”com.example.domain.order”</span>&gt;</span></span><br><span class="line">    select order_id as id, order_no as orderno ,order_price as price form orders where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用resultMap定义字段和属性的映射关系<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderresultmap&quot;</span>&gt;</span></span><br><span class="line">    select * from orders where order_id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">”me.gacl.domain.order”</span> <span class="attr">id</span>=<span class="string">”orderresultmap”</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用id属性来映射主键字段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">”id”</span> <span class="attr">column</span>=<span class="string">”order_id”</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> = <span class="string">“orderno”</span> <span class="attr">column</span> =<span class="string">”order_no”/</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”price”</span> <span class="attr">column</span>=<span class="string">”order_price”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>              </div>            </details></li><li>MyBatis是如何进行分页的？分页插件的原理是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果及执行的内存分页，而非物理分页。可以在SQL内直接拼写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页，例如在原有SQL后面拼写limit</li><li>分页插件的基本原理是使用MyBatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，然后重写SQL，根据dialect方言，添加对应的物理分页语句和物理分页参数</li></ul>              </div>            </details></li><li>MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>MyBatis将SQL查询结果封装为目标对象并返回，主要通过以下两个步骤完成<ol><li>执行SQL查询语句，获取ResultSet结果集</li><li>根据目标对象的映射方式，将ResultSet结果集中的数据映射到目标对象中</li></ol></li><li>MyBatis支持以下几种映射方式   <ol><li>使用SQL列的别名功能，将列名的别名命名为对象的属性名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">as</span> userName <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> #&#123;userId&#125;</span><br></pre></td></tr></table></figure></li><li>resultMap映射：指定目标对象和ResultSet结果集中各列之间的映射关系<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_age&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul>              </div>            </details></li><li>如何执行批量插入<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>首先创建一个简单的insert语句<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">”insertname”</span>&gt;</span></span><br><span class="line">    insert into names (name) values (#&#123;value&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Java代码中实现批量插入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;fred&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;barney&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;betty&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;wilma&quot;</span>);</span><br><span class="line"> </span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    NameMapper mapper = sqlSession.getMapper(NameMapper.class);</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        mapper.insertName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li>XML映射文件中，除了常见的select、insert、update、delete标签外，还有哪些标签<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>&lt;resultMap&gt;</code>：用于定义查询结果与Java对象的映射关系，可以自定义属性的映射关系，包括一对一、一对多等复杂映射关系</li><li><code>&lt;sql&gt;</code>：用于定义可重用的SQL片段，可以将SQL片段抽象出来，供多个SQL语句使用</li><li><code>&lt;include&gt;</code>：用于包含其他XML文件中定义的SQL片段，可以实现SQL的复用</li><li><code>&lt;if&gt;</code>：用于在SQL语句中添加条件判断，可以根据参数动态生成SQL语句</li><li><code>&lt;where&gt;</code>：用于将多个条件组合成一个WHERE子句，避免生成无用的WHERE子句</li><li><code>&lt;foreach&gt;</code>：用于遍历集合或数组，并将元素拼接成SQL语句中的IN子句</li><li><code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code>：用于实现复杂的条件判断，类似Java中的if-else语句</li><li><code>&lt;trim&gt;</code>：用于对SQL语句进行字符串处理，如去除逗号、括号等</li></ol>              </div>            </details></li><li>MyBatis实现一对一有几种方式？具体怎么操作的<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>MyBatis实现一对一有以下两种方式<ol><li>使用<code>&lt;resultMap&gt;</code>标签定义一对一映射关系<ul><li>例如，我们有一个Order类和一个User类，一个订单只属于一个用户，因此Order类中包含一个User对象作为属性。在XML映射问建中，我们可以定义一个<code>&lt;resultMap&gt;</code>标签，定义Order类与User类之间的映射关系<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getUserById&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在上面的<resultMap>标签中，我们使用<association>标签定义Order类中的user属性与User类之间的映射关系。其中，property属性指定Order类中的user属性，javaType属性指定User类的类型，select属性指定通过getUserById查询用户信息的SQL语句。</li></ul></li><li>使用嵌套查询<ul><li>使用嵌套查询可以在查询订单的同时查询用户信息，将查询结果组装成一个Order对象，例如我们在XML映射文件中定义以下SQL语句<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrderById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">    select o.id, o.name, o.user_id, u.username, u.phone, u.address</span><br><span class="line">    from orders o</span><br><span class="line">    join users u on o.user_id = u.id</span><br><span class="line">    where o.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在上面的SQL语句中，我们通过join语句关联了<code>orders</code>表和<code>users</code>表，并查询了订单和用户的信息。在<code>&lt;select&gt;</code>标签中，我们通过<code>resultMap</code>属性指定了将查询结果映射到Order对象上的<code>&lt;resultMap&gt;</code>标签。在<code>&lt;resultMap&gt;</code>标签中，我们通过<code>&lt;association&gt;</code>标签定义了<code>Order</code>对象和<code>User</code>对象之间的映射关系。</li></ul></li></ol></li></ul>              </div>            </details></li><li>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的是一对一，collection指的是一对多查询。在MyBatis配置文件中，可以配置是否启用延迟加载：<code>lazyLoadingEnable=true|false</code></li><li>MyBatis实现延迟加载的原理是使用代理对象，代理对象在访问对象时触发延迟加载，从而实现按需加载<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在MyBatis中，延迟加载的实现主要有两种方式 <ol><li>延迟加载嵌套查询：在XML映射文件中，我们可以通过使用<code>select</code>标签定义一个嵌套查询，当需要使用到延迟加载对象时，MyBatis会根据该嵌套查询获取相关的数据。例如，以下代码演示了如何通过嵌套查询实现延迟加载 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">    select u.id, u.name, o.id as order_id, o.name as order_name, o.user_id as user_id</span><br><span class="line">    from users u</span><br><span class="line">    left join orders o on o.user_id = u.id</span><br><span class="line">    where u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在上面的XML映射文件中，我们定义了一个<code>User</code>对象和一个<code>Order</code>对象之间的一对多关系，使用<code>collection</code>标签定义<code>User</code>对象中的<code>order</code>属性，其中通过<code>&lt;association&gt;</code>标签的<code>fetchType=lazy</code>属性实现了延迟加载</li></ul></li><li>延迟加载代理对象：它的原理是，通过CGLIB动态代理生成了一个目标对象的代理对象。当我们调用代理对象的方法时，代理对象内部的拦截器方法会先被执行，这个拦截器会检查当前对象是否已经加载了关联对象。如果没有加载，拦截器会执行预先保存好的查询语句，从数据库中查询关联对象的数据，并将查询结果映射为Java对象。接着，代理对象的拦截器会将查询到的关联对象设置到目标对象中，然后继续执行我们最初调用的方法，以便返回正确的结果。<ul><li>举个例子：假设我们有一个User对象，它包含一个Order对象的引用。我们在访问User对象的getOrder()方法时，如果关联的Order对象还没有被加载，拦截器会执行查询语句，从数据库中查询Order对象的数据，然后拦截器会将查询到的Order对象设置到User对象中的order属性中。最后拦截器返回Order对象，让我们可以正常地范文它的属性或方法</li><li>这样我们就可以通过延迟加载来优化数据库访问，只有需要时才回去查询关联对象，而不是每次访问对象时都进行查询</li></ul></li></ol></li></ul>              </div>            </details></li><li>说说MyBatis的缓存机制<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>MyBatis的缓存机制主要分为一级缓存和二级缓存<ul><li>一级缓存指的是SqlSession级别的缓存，它默认是开启的，同一个SqlSession内部的多次查询操作，如果查询的参数和查询语句都相同，那么第一次查询时查询结果会被缓存到一级缓存中，后续的查询操作会直接从缓存中获取结果，而不会再去查询数据库。一级缓存的生命周期与SqlSession的生命周期相同，当SqlSession被关闭时，一级缓存也会被清空</li><li>二级缓存指的是Mapper级别的缓存，它需要手动开启。开启二级缓存后，查询操作的结果会被缓存到内存或者其他缓存存储设备中，当下次再次查询相同的数据时，会优先从缓存中获取数据，而不是再次查询数据库。不同的SqlSession之间可以共享二级缓存，因此当多个SqlSession操作同一个Mapper时，他们之间共享一个二级缓存，二级缓存的缓存时间是无限制的，但是它的缓存策略是基于LRU(最近最少使用)算法的<div class="note warning no-icon flat"><ul><li>需要注意的是，二级缓存中的缓存数据是需要被序列化和反序列化的，因此当我们在Mapper中使用自定义类型时，需要确保这些类型支持序列化操作</li></ul></div></li><li>为了提高缓存命中率，MyBatis还提供了缓存清空机制，可以通过在Mapper中配置<code>flushCache=&quot;true&quot;</code>来清空缓存。此外，MyBatis还支持基于注解的缓存配置，可以通过在Mapper接口或方法上添加<code>@CacheNamespace</code>或者<code>@CacheNamespaceRef</code>注解来配置缓存</li></ul></li><li>当开启缓存后，数据的查询执行流程为：二级缓存 -&gt; 一级缓存 -&gt; 数据库</li><li>但是MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻</li><li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis等分布式缓存可能成本更低，安全性也更高</li></ul>              </div>            </details></li><li>JDBC编程有哪些步骤<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>JDBC是Java数据库连接的标准API，用于连接和操作关系型数据库。JDBC编程的基本步骤如下<ol><li>加载数据库驱动程序。使用<code>Class.forName()</code>方法加载对应的数据库驱动程序，如<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>加载MySQL数据库驱动程序</li><li>创建数据库连接，使用<code>DriverManager.getConnection()</code>方法创建数据库连接，需要指定数据库连接字符串、用户名、密码等连接信息，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DirverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>创建Statement或者PreparedStatement对象，用于执行SQL语句<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection.createStatement();</span><br><span class="line">Connection.prepareStatement();</span><br></pre></td></tr></table></figure></li><li>执行SQL语句，使用Statement或PreparedStatement对象的<code>execute()</code>、<code>executeQuery()</code>、<code>executeUpdate()</code>等方法执行SQL语句</li><li>处理查询结果，如果执行的是查询语句，需要使用ResultSet对象获取查询结果</li><li>关闭ResultSet、Statement、Connection独享。释放占用的资源，防止出现内存泄漏</li></ol></li></ul>              </div>            </details></li><li>MyBatis中见过什么设计模式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>工厂模式：MyBatis中的SqlSessionFactory和SqlSession都是通过工厂模式创建的，SqlSessionFactoryBuilder类的作用就是创建SqlSessionFactory对象。</li><li>代理模式：MyBatis中的Mapper接口实现类是通过JDK动态代理实现的。在执行Mapper接口中的方法时，实际上是通过动态代理生成一个代理对象，代理对象调用方法是会自动执行相应的SQL语句</li><li>装饰器模式：MyBatis中的插件就是通过装饰器模式实现的，插件可以在不修改原有代码的基础上，增强或修改原有功能</li><li>享元模式：MyBatis中的缓存就是使用了享元模式，通过缓存已经查询过的数据，避免重复查询数据库</li><li>观察者模式：MyBatis中的拦截器就是使用了观察者模式，拦截器可以在SQL执行前后进行一些额外操作</li></ol>              </div>            </details></li><li>MyBatis中例如UserMapper.java是接口，为什么没有实现类还能调用<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在MyBatis中，Mapper接口是由MyBatis框架动态生成的。当我们定义一个Mapper接口时，MyBatis会根据接口的定义和XML映射文件中的配置信息，动态生成一个接口的实现类，并将其注册到Spring容器中，供应用程序使用</li><li>MyBatis使用了Java动态代理技术来生成Mapper接口的实现类。当应用程序调用Mapper接口中的方法时，实际上是调用了Mapper接口的代理对象的方法。代理对象会根据方法名和参数类型等信息，动态生成相应的SQL语句，并将其执行。由于动态代理是在运行时生成的，因此不需要Mapper接口的实现类</li><li>这种通过接口定义方法，而不需要手动实现的方式，成为面向接口编程。它可以降低代码的耦合度，使得应用程序更加灵活和可扩展</li></ul>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud知识点</title>
      <link href="/2023/04/30/SpringCloud%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/04/30/SpringCloud%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ol><li>微服务是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>微服务是一种架构风格，它将一个大型应用程序拆分成一组小型、自治的服务，每个服务都运行在自己的进程中，通过轻量级的通信机制来相互协作，以达到高度灵活、可伸缩、可维护和可测试的目的。</li><li>每个服务都可以独立地开发、部署和扩展，并且可以使用不同的编程语言和技术栈来实现。微服务架构的核心思想是将应用程序按照业务功能划分出一组小的服务，每个服务都有自己的数据存储和业务逻辑，而服务之间通过网络通信协作完成整个应用的功能。</li></ul>              </div>            </details></li><li>你知道哪些RPC框架<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>RPC(远程过程调用)框架是一种用于实现分布式中不同进程或不同计算机之间通信的技术，我这里只了解Dubbo和Feign<ol><li>Dubbo：阿里巴巴开源的高性能RPC框架，支持多种协议和注册中心，提供丰富的监控和治理功能</li><li>Spring Cloud Feign：基于Netflix Feign的Spring Cloud组件，支持声明式REST调用和负载均衡</li><li>gRPC：Google开源的高性能RPC框架，支持多种编程语言，基于Protocol Buffers进行序列化和反序列化</li><li>Thrift：Facebook开源的跨语言RPC框架，支持多种语言和数据格式，具有良好的性能和扩展性</li><li>Hessian：Caucho Technology开源的轻量级RPC框架，支持多种语言和数据格式，易于使用和部署</li><li>Apache CXF：Apache基金会的开源RPC框架，支持多种协议和数据格式，提供丰富的安全和SOAP支持</li><li>Apache DubboX：Dubbo的扩展版本，支持更多的协议和注册中心，提供更多的功能和扩展点</li><li>Apache Avro：Apache基金会的开源RPC框架，支持多种语言和数据格式，具有较好的性能和跨语言支持</li></ol></li></ul>              </div>            </details></li><li><p>SpringCloud和Dubbo有什么区别</p><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring Cloud和Dubbo都是用于构建分布式系统的框架，但它们有一些区别，主要体现在以下几个方面<ol><li>技术选型：SpringCloud采用了Spring全家桶作为技术栈，包括SpringBoot、SpringCloud Netflix、SpringCloud Config等，而Dubbo采用了Netty、Zookeeper、Hessian等技术</li><li>生态环境：SpringCloud是基于Spring生态环境构建的，拥有丰富的第三方库和工具，而Dubbo是阿里巴巴自主研开发的生态环境，相对较为封闭</li><li>协议支持：Dubbo支持多种协议，包括Dubbo、HTTP、REST等，而SpringCloud则主要只是HTTP和REST协议</li><li>注册中心：Dubbo的注册中心采用Zookeeper，而SpringCloud支持多种注册中心，包括Eureka、Consul、Zookeeper等</li><li>功能特性：Dubbo在服务治理、负载均衡、容错、监控等方面具有更为丰富和成熟的功能特性，而SpringCloud则更加注重开发体验和易用性，提供了更多的快速开发和集成解决方案</li></ol></li></ul>              </div>            </details></li><li><p>SpringCloud由什么组成</p><details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringCloud是基于SpringBoot的微服务架构框架，由多个子项目组成，包括   <ol><li>SpringCloud Config：提供集中式配置管理，支持Git、SVN等多种配置源</li><li>SpringCloud Netflix：提供对Netflix OSS组件的集成，包括Eureka服务注册中心、Zuul网管、Hystrix断路器等</li><li>SpringCloud Gateway：基于Spring WebFlux的网关服务，提供动态路由、负载均衡、安全控制等功能</li><li>SpringCloud OpenFeign：基于Netflix Feign的声明式REST客户端，简化服务调用的开发</li><li>SpringCloud Bus：基于消息代理的事件总线，用于实现配置刷新、服务状态同步等功能</li><li>SpringCloud Sleuth：提供分布式追踪解决方案，支持Zipkin、ELK等多种追踪系统</li><li>SpringCloud Stream：基于Spring Integration的消息中渐渐框架，支持多种消息代理，包括RabbitMQ、Kafka等</li><li>SpringCloud Security：提供基于OAuth2的安全控制解决方案，支持都中身份认证方式</li></ol></li><li>此外，SpringCloud还提供了一些其他的子项目，包括SpringCloud Task、SpringCloud Data Flow、SpringCloud Function等，用于解决特定的问题和场景。这些子项目可以根据实际需求进行选择和集成，以构建出符合自己需求的微服务架构</li></ul>              </div>            </details></li><li>什么是配置中心<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>配置中心是一种集中式管理配置信息的解决方案，用于管理分布式系统中的配置信息。在微服务架构中，由于服务数量众多，每个服务器都需要一些配置信息，如数据库连接、缓存配置、日记级别等，这些配置信息都需要被管理和更新，而配置中心就是为了解决这个问题而出现的</li><li>通常情况下，配置中心会提供一个Web界面，让管理员或开发者可以在上面修改配置信息，然后配置中心会将这些配置信息推送给各个微服务。这种方式可以大大简化配置管理的工作，并提高配置信息的可维护性和可读性。</li></ul>              </div>            </details></li><li>为什么要使用配置中心<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>使用配置中心的好处主要有以下几点<ol><li>集中化管理：将配置信息集中存储在一个地方，方便管理员或开发者管理和修改，减少手动修改配置文件</li><li>动态更新：配置中心可以支持动态更新配置信息，当配置信息发生变化时，配置中心可以自动推送更新到各个微服务，不需要重新启动应用</li><li>灵活性：配置中心支持多种配置文件格式，可以根据实际需求选择合适的格式，而且支持多种存储方式，如Git、SVN等版本控制系统</li><li>安全性：配置中心可以提供安全控制功能，如访问权限控制、数据加密等，保证配置信息的安全性</li><li>可扩展性：配置中心可以根据实际需求进行扩展，如增加高可用性、数据备份等功能</li></ol></li></ul>              </div>            </details></li><li>配置中心一般都会配置什么内容<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>数据库连接信息：数据库IP、端口、用户名、密码等</li><li>缓存配置信息：缓存服务器IP、端口、缓存策略等</li><li>服务调用地址：包括各个微服务的调用地址、端口等</li><li>日志级别：用于控制各个服务的日志级别</li><li>应用配置信息：应用名、版本号、环境等</li><li>业务参数信息：用于控制业务逻辑的参数，如超时时间、重试次数等</li><li>安全配置信息：包括访问权限控制、数据加密等安全配置</li></ol>              </div>            </details></li><li>SpringCloud有什么优势<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringCloud是基于SpringBoot的微服务开发框架，它提供了一系列的组件和工具，用于构建分布式系统中的微服务架构，其主要优势包括<ol><li>易用性：SpringCloud提供了一系列简单易用的组件和工具，开发者可以快速构建分布式系统中的微服务架构，大大提高了开发效率</li><li>高可靠性：SpringCloud提供了一系列容错和故障恢复机制，包括服务发现、熔断、限流、负载均衡等，可以帮助开发者构建高可靠、高可用的分布式系统</li><li>可扩展性：SpringCloud支持各种开源技术和标准，如Nerflix OSS、Consul、Zookeeper、Ribbon、Feign等，可以方便地扩展和集成其他技术组件，以满足不同的也无需求</li><li>可管理性：SpringCloud提供了多种监控和管理工具，如Hystrix DashBoard、Turbine、Zipkin等，可以方便地监控和管理分布式系统中的微服务</li><li>社区支持：SpringCloud拥有庞大的社区支持，开发者可以从社区中获取各种资源和解决方案，以解决分布式系统中的各种问题。</li></ol></li></ul>              </div>            </details></li><li>项目中为什么要定义bootstrap.yml文件<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringBoot应用在启动时，会先加载bootstrap.yml文件，再加载application.yml文件，因此可以在bootstrap.yml中定义一些应用程序的基础配置，例如连接配置中心的相关配置。</li><li>在分布式系统中，使用bootstrap.yml中的配置信息连接到配置中心，可以从配置中心获取应用程序的配置信息，并将配置信息动态地推送到各个应用程序中，从而实现配置信息的动态更新和统一管理。</li><li>同时bootstrap.yml中的配置具有更高的优先级，可以覆盖application.yml中的配置。因此可以将一些重要的配置信息放在bootstrap.yml中，确保其优先生效</li></ul>              </div>            </details></li><li>什么是Nacos<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Nacos(Naming and Configuration Service)，是一个支持配置管理、服务发现和动态DNS服务的开源平台，由阿里巴巴开源。它可以帮助开发人员快速构建微服务应用。</li><li>Nacos提供了服务注册与发现、配置管理、服务治理等功能，可以用于支持微服务架构中的服务注册、配置管理和动态路由等需求。其主要功能包括<ol><li>服务注册与发现：Nacos可以帮助微服务应用完成服务的注册与发现，提供了多种服务注册方式，并支持动态服务发现</li><li>配置管理：Nacos可以作为配置中心，帮助微服务应用完成配置的统一管理，提供了多种配置格式和挂历方式，支持动态刷新配置</li><li>服务路由与调用：Nacos支持动态路由和负载均衡；可以帮助微服务应用实现服务之间的调用</li><li>服务监控与治理：Nacos提供了服务的健康检查、流量控制、降级和容错等功能，可以帮助开发人员实现服务的高可用和自动化治理</li></ol></li></ul>              </div>            </details></li><li>微服务是否可以读取共享配置<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>微服务可以读取共享配置。共享配置是指将一些公共的配置信息抽离出来，放到配置中心进行统一管理，不同的微服务可以根据自身需求通过配置中心来获取这些共享配置信息，这样就可以避免在每个微服务应用中都单独管理一份相同的配置，提高了配置的可维护性和统一性</li><li>例如Redis连接信息、日志级别等都可以作为共享配置信息，存储在配置中心。</li></ul>              </div>            </details> </li><li>Ribbon的作用<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Ribbon是一个客户端负载均衡框架，可以将请求分摊到多个服务实例上，从而提高系统的可用性和性能。Ribbon是SpringCloud的一部分，通常与Eureka、Zookeeper等注册中心配合使用</li><li>Ribbon的主要作用有两个<ol><li>服务实例的选择：Ribbon可以根据一定的规则（如随机、轮询、加权轮询等）选择合适的服务实例，从而实现负载均衡</li><li>请求的重试：Ribbon还可以实现请求的重试机制，在某些情况下，由于网络等原因，请求可能会失败，此时Ribbon会根据一定的规则（如最大重试次数、重试间隔等）进行重试，从而提高请求的成功率。</li></ol></li></ul>              </div>            </details></li><li>Ribbon的原理<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Ribbon的原理比较简单，主要包括以下几个步骤<ol><li>获取服务列表：客户端向注册中心（如Eureka、Zookeeper等）获取服务列表</li><li>选择服务实例：根据一定的负载均衡算法（如轮询、随机、加权查询等），从服务列表中选择一个服务实例</li><li>发送请求：客户端向所选的服务实例发送请求，并等待响应结果</li><li>处理响应：如果服务实例返回响应结果，则客户端处理响应结果，并根据需要进行重试</li></ol></li></ul>              </div>            </details></li><li>Ribbon和Nginx的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Ribbon和Nginx都是负载均衡的工具，但它们有一些区别<ol><li>应用场景不用：Nginx通常用于反向代理和静态文件服务，适用于Web服务器、缓存、HTTP负载均衡、反向代理等场景。而Ribbon通常用于微服务架构中，适用于客户端负载均衡的场景</li><li>工作原理不同：Nginx是通过将客户端请求分发到不同的后端服务器上来实现负载均衡的，而Ribbon则是在客户端上进行负载均衡。Ribbon会从注册中心获取服务列表，并选择一个合适的服务实例来处理客户端请求</li><li>功能不同：Nginx支持HTTP、TCP、UDP协议，可以进行反向大力、负载均衡、缓存等功能。而Ribbon则只支持HTTP和TCP协议，主要用于客户端负载均衡</li><li>部署方式不同；Nginx通常是以独立进程的方式运行，可以通过配置文件进行管理。而Ribbon则是作为客户端集成到应用程序中，与应用程序一起部署</li></ol></li></ul>              </div>            </details></li><li>Feign的作用<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Feign是一个声明式、模块化的HTTP客户端，它可以让开发者更加方便地调用HTTP API。在SpringCloud微服务架构中，Feign通常用于简化服务间的HTTP调用，并且与Ribbon负载均衡结合使用，提供更加稳定和高效的服务调用</li><li>使用Feign时，只需要定义一个接口，然后使用注解来描述接口中的方法和参数。Feign会根据这些注解自动构建出HTTP请求，并且处理响应结果。这样就避免了手动构建HTTP请求的麻烦，并且可以提高代码的可读性和可维护性</li><li>Feign的主要作用有<ol><li>简化服务间的HTTP调用，提高开发效率</li><li>集成了Ribbon负载均衡，提供更加稳定和高效的服务调用</li><li>可以自动将HTTP请求转换为Java方法调用，并将响应结果转换为Java对象</li><li>支持自定义解码器、拦截器、错误处理等功能，具有良好的扩展性</li></ol></li><li>总之，Feign是一个非常实用的HTTP客户端库，在SpringCloud微服务架构中具有重要的作用，可以简化服务间的HTTP调用，提高开发效率和代码质量</li></ul>              </div>            </details></li><li>SpringCloud有几种调用接口的方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在SpringCloud微服务架构中，常见的调用接口的方式有以下几种<ol><li>RestTemplate：Spring提供的RESTful风格的HTTP客户端，可以用于调用HTTP接口，支持HTTP GET、POST、PUT、DELETE等请求方式。使用RestTemplate需要手动构建HTTP请求和解析响应结果</li><li>Feign：一个声明式、模板化的HTTP客户端，可以让开发者更加方便地调用HTTP API。使用Feign时，之需要定义一个接口，然后使用注解来描述接口中的方法和参数。Feign会根据这些注解自动构建出HTTP请求，并且处理响应结果</li><li>WebClient：Spring 5.0引入的响应式Web客户端，可以用于调用HTTP接口，并且支持异步非阻塞的HTTP请求和响应。WebClient支持GET、POST、PUT、DELETE等请求方式，并且支持基于Flux和Mono的响应式编程</li><li>Gateway：SpringCloud Gateway是一个基于Spring WebFlux的API网关，可以用于对外暴露API接口，并且可以通过路由、过滤器等方式进行自定义扩展。Gateway支持HTTP请求转发、负载均衡、熔断、限流等功能，可以哟用于构建高可用、高性能的为服务架构。</li></ol></li><li>总之，SpringCloud提供了多种调用接口的方式，可以根据具体的业务场景和需求来选择合适的方式进行调用。RestTemplate、Feign、WebClient适用于传统的非响应式的HTTP接口调用，而Gateway适用于API网关的场景</li></ul>              </div>            </details></li><li>Ribbon和Feign调用服务的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Ribbon和Feign都是SpringCloud中用于调用服务的组件，二者的区别如下  <ol><li>使用方式不同：Ribbon是一个负载均衡组件，需要手动创建RestTemplate并添加负载均衡器，然后使用RestTemplate调用服务，而Feign是一个声明式的HTTP客户端，使用注解来描述需要调用的服务接口，Feign会自动根据注解生成实现，并且已经集成了Ribbon，可以自动实现负载均衡</li><li>对服务注册中心的依赖不同：Ribbon需要依赖Eureka或其他服务注册中心来获取服务列表，然后进行负载均衡。而Feign可以直接调用服务，也可以使用服务注册中心来实现负载均衡</li><li>粒度不同：Ribbon是一个底层组件，可以用于实现更细粒度的服务调用逻辑，例如在代码中手动选择服务实例，或者时间自定义的负载均衡策略。而Feign是一个高层组件，对于服务调用的实现和逻辑已经封装好了，通常只需要使用注解来描述接口，不需要关心具体的调用逻辑</li></ol></li><li>综上所述，Ribbon和Feign都可以用于服务调用和负载均衡，二者在使用方式、服务注册中心依赖和粒度等方面存在一些差异，根据实际的业务场景和需求来选择合适的组件进行服务调用</li></ul>              </div>            </details></li><li>说说什么是服务雪崩<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>服务雪崩通常是由于某个服务出现了故障或者过载，导致对依赖该服务的请求都超时或失败，进而引发连锁反应。此时如果没有合适的容错机制和限流措施，那么整个系统可能会因为过度的请求而崩溃。</li><li>为了避免服务雪崩，可以采取以下措施：<ol><li>服务的容错机制：例如对服务进行熔断、降级等，保证出错的服务不会对其他服务造成影响。</li><li>服务的限流措施：例如通过限制并发请求、流量控制等方式来保证系统的稳定性。</li><li>服务的高可用性：通过部署多个服务实例和负载均衡等方式来保证服务的可用性。</li><li>监控和预警机制：及时发现服务故障并采取相应的措施，避免故障扩散。</li></ol></li></ul>              </div>            </details></li><li>Hystrix断路器是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Hystrix是Netflix开源的一款容错框架，用于处理分布式系统中的延迟和容错问题。它主要是为了解决服务雪崩效应而设计的，提供了断路器模式，使得在一个微服务调用失败或延迟过长时，能够通过断路器来快速地切换到备用的逻辑或服务，从而保证整个服务的稳定心和可靠性</li><li>Hystrix的核心原理是在服务调用中添加一个拦截器，在拦截器中对服务的调用进行监控和控制，当服务调用失败或者超时时，会启动熔断器，直接返回一个快速失败的响应，避免因连锁反应导致服务雪崩的问题。同时Hystrix还提供了可视化的监控面板，方便开发者进行实时监控和调试</li></ul>              </div>            </details></li><li>什么是服务降级、服务熔断、服务隔离<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>服务降级、服务熔断、服务隔离都是为服务架构中常见的容错机制，用于保证系统的稳定性和可靠性</li><li>服务降级是指当下系统出现异常或负载过高时，通过调整系统的运行策略，优先保证系统的核心功能，而暂时关闭非核心或者低优先级的功能，从而减轻系统负担，保证系统的可用性。</li><li>服务熔断是指当系统出现异常或负载过高时，通过关闭对一些服务的访问，从而避免不断地请求导致系统崩溃，从而保证系统的稳定性。同时，熔断器还提供了快速失败的响应，避免客户端长时间等待导致系统响应时间变慢</li><li>服务隔离是指将不同的服务部署在不同的容器中，通过限制每个服务的资源使用，避免由于某个服务的异常或者负载过高，导致整个系统奔溃，从而保证系统的可用性和稳定性。</li></ul>              </div>            </details></li><li>说说RPC的实现原理<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>RPC(Remote Procedure Call)是一种远程过程调用协议，其实现原理基本可以分为以下几个步骤<ol><li>定义服务接口：定义服务的方法接口，包括方法名称、参数、返回值等信息。</li><li>生成代理类：客户端通过代理类来调用服务端的方法。</li><li>序列化数据：将客户端传递的方法名和参数等数据序列化为二进制数据。</li><li>发送请求：客户端通过网络将序列化后的数据发送给服务端。</li><li>反序列化数据：服务端接收到客户端发送的请求数据后，需要将其反序列化成具体的方法名和参数等数据。</li><li>调用服务：服务端根据反序列化得到的方方和参数调用对应的方法</li><li>序列化响应：服务端将方法的返回值序列化成二进制数据</li><li>发送相应：服务端将序列化后的数据通过网络发送给客户端</li><li>反序列化响应：客户端接收到服务端发送的响应数据后，需要将其反序列化为具体的返回值</li></ol></li></ul>              </div>            </details> </li><li>SpringBoot和SpringCloud的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringBoot和SpringCloud都是基于Spring Framework的框架。SpringBoot主要关注于快速构建单体应用程序，而SpringCloud主要关注构建分布式系统的基础设施和提供微服务开发的解决方案。</li><li>具体来说，二者的区别如下<ol><li>目标不同：SpringBoot旨在简化单体应用的构建，而SpringCloud旨在构建分布式系统的基础设施和微服务</li><li>功能不同：SpringBoot提供了一系列开箱即用的功能，如自动配置、内嵌Tomcat、SpringMVC、SpringData、SpringSecurity等；而SpringCloud则提供了一些分布式系统的基础设施和微服务解决方案，如服务注册与发现、配置中心、负载均衡、断路器、消息总线等</li><li>使用方式不同：SpringBoo是一个单体应用框架，开发者可以使用期快速构建单体应用，而SpringCloud则是一个基础设施框架，需要在SpringBoot的基础上进行集成和使用</li></ol></li><li>总的来说，SpringBoot和SpringCloud都是SpringFramework的扩展和增强，但是在目标、功能和使用方式等方面有所不同。在开发分布式系统好微服务时，通常需要同时使用SpringBoot和SpringCloud</li></ul>              </div>            </details></li><li>负载均衡的意义是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>负载均衡(Load Balancing)是指将网络请求、数据流量等分发到多个服务器上，以达到提高系统性能、增加系统可用性和可伸缩性的目的。其意义主要在于以下几个方面<ol><li>提高系统的性能：负载均衡可以将请求分散到多个服务器上进行处理，从而缩短响应时间，提高系统的吞吐量和性能</li><li>提高系统的可用性：负载均衡可以将请求分发到多台服务器上，当其中某一台服务器出现故障时，可以自动将请求切换到其他正常的服务器上，从而保证系统的可用性</li><li>提高系统的可伸缩性：负载均衡可以将请求分发到多台服务器上，当系统的负载增加是，可以通过增加服务器的数量来扩展系统的处理能力，从而提高系统的可伸缩性</li></ol></li></ul>              </div>            </details></li><li>什么是SpringCloud Gateway<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringCloud Gateway是SpringCloud生态系统中的一个API网关，提供了一种简单而有效的方法来对微服务的请求进行路由、过滤和转换。它是基于SpringFramework 5、Project Reactor和SpringBoot 2构建的，SpringCloud Gateway的目标是提供统一的API路由管理方式，实现请求的动态路由、熔断降级、限流控制等功能，同时可以继承第三方的服务发现组件（例如Eureka、Consul、Zookeeper等）来实现服务的注册和发现。</li></ul>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot知识点</title>
      <link href="/2023/04/28/SpringBoot%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/04/28/SpringBoot%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ol><li>为什么要用SpringBoot<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>因为SpringBoot的优点非常多<ol><li>独立运行：SpringBoot内嵌了各种servlet容器，如Tomcat、Jetty等，现在不再需要打成war包部署到容器中，SpringBoot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内</li><li>简化配置：SpringBoot提供了很多starter依赖，可以快速集成其他框架和组件，大大简化了配置过程。</li><li>自动配置：SpringBoot的自动配置非常强大，可以根据类路径下的jar包、类文件和注解来自动配置bean，减少了手动配置的工作量。</li><li>无代码生成和XML配置：SpringBoot使用条件注解和自动配置来完成所有的配置工作，避免了代码生成和繁琐的XML配置文件，让开发更加简洁、清晰。</li><li>应用监控：SpringBoot提供了很多有用的端点和指标，可以用来监控和管理应用程序，包括健康检查、性能监控、日志查看等。此外，SpringBoot还可以与Actuator集成，提供更加丰富的监控功能。</li></ol></li></ul>              </div>            </details></li><li>SpringBoot的核心注解是哪个？它主要由哪几个注解组成的<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringBoot的核心注解是<code>@SpringBootApplication</code>，它主要是由三个注解组成，分别是<ol><li><code>@Configuration</code>：声明当前类是一个配置类</li><li><code>@EnableAutoConfiguration</code>：开启SpringBoot的自动配置功能</li><li><code>@ComponentScan</code>：开启组件扫描，会自动扫描当前包及其子包下的所有类，并注册为Spring的Bean</li></ol></li><li>这三个注解组合在一起，可以让SpringBoot自动配置并启动应用程序。除此之外，SpringBoot还有很多其他注解，如<code>@RestController</code>、<code>@Service</code>、<code>@Repository</code>等，它们可以帮助我们更方便地创建控制器、服务层、数据访问层等组件</li></ul>              </div>            </details></li><li>运行SpringBoot应用程序有哪几种方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>运行SpringBoot应用程序有以下几种方式<ol><li>在IDE中运行：在集成开发环境(IDE)中，可以通过直接运行应用程序的主类来启动SpringBoot程序(main方法)</li><li>打包成可执行JAR包运行：SpringBoot提供了一种将应用程序打包成可执行的JAR包的方式，例如使用Maven插件，可以轻松将应用程序打包成一个单独的JAR文件，然后在命令行中运行该JAR文件即可启动应用程序<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure></li><li>在容器中运行：可以将SpringBoot应用程序部署到Web容器中，如Tomcat、Jetty等，然后启动容器即可运行应用程序。在部署时需要将应用程序打成WAR包，并将WAR包部署到相应的容器中</li></ol></li></ul>              </div>            </details></li><li>如何理解SpringBoot中的starters<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringBoot中的staters(启动器)是一种依赖管理的方式，它是一组预定义的依赖关系，可以方便地将常用的依赖库和框架引入到项目中。使用starters可以避免在pom.xml中一个一个引入依赖的麻烦，检查依赖管理的过程。（就好比你去steam的创意工坊找mod，一个一个找也太麻烦了，此时你就可以选择找一个常用mod合集）</li></ul>              </div>            </details></li><li>如何在SpringBoot启动时运行一些特定的代码<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在SpringBoot启动时，可以通过实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口来运行一些特定的代码。这两个接口都是SpringBoot提供的回调接口，它们的作用是在SpringBoot应用程序启动完成之后，自动回调其中的run方法。在这个方法中可以编写一些初始化代码，如加载配置文件、初始化缓存等<ul><li><code>ApplicationRunner</code>接口的run方法中传入了一个<code>ApplicationArguments</code>对象，可以用来获取命令行参数和选项等信息</li><li><code>CommandLineRunner</code>接口的run方法中传入一个<code>String</code>数组，可以用来获取命令行参数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span>, <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在此编写初始化代码，可以使用args获取命令行参数和选项等信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在此编写初始化代码，可以使用args获取命令行参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例如在上述代码中，<code>MyRunner</code>类实现了<code>ApplicationRunner</code>和<code>CommandLineRunner</code>接口，并重写了他们的<code>run()</code>方法，在这里可以编写一些初始化代码。同时<code>MyRunner</code>类使用<code>@Component</code>注解，表示它是一个Spring的组件，可以被自动扫描并注册到Spring容器中。当SpringBoot应用程序启动时，<code>run()</code>方法会被自动回调，从而执行其中的代码</li></ul>              </div>            </details></li><li>SpringBoot需要独立的容器运行吗<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>不需要。SpringBoot应用程序已经被打包成可执行的jar文件，可以独立完成，不需要外部容器。在启动应用程序时，SpringBoot会内嵌一个Tomcat、Jetty或Undertow等Servlet容器，从而可以直接运行Web应用程序，而不需要单独安装和配置外部的Servlet容器。这种方式成为嵌入式Servlet容器</li><li>当然，如果需要在生产环境中部署SpringBoot应用程序，可以将其打包成war包，然后部署到外部的Servlet容器中，如Tomcat、Jetty、WebSphere等，但这种部署方式失去了SpringBoot嵌入式容器的优势</li></ul>              </div>            </details></li><li>SpringBoot中的监视器是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringBoot中的监视器(monitor)是一个内置的功能，它可以让开发者实时监控应用程序的运行状况和性能指标。监视器是基于SpringBootActuator模块实现的，可以通过HTTP接口或JMX访问</li><li>监视器可以提供一下几个功能<ol><li>健康检查：通过访问<code>/actuator/health</code>接口，可以获取应用程序的健康状况。如果应用程序正常运行，会返回一个<code>HTTP 200 OK</code>响应；如果应用程序异常，会返回一个<code>HTTP 503 Service Unavailable</code>响应</li><li>指标监控：通过访问<code>/actuator/metrics</code>接口，可以获取应用程序的各种指标，如内存使用情况、CPU占用率、HTTP请求数等</li><li>环境信息：通过访问<code>/actuator/env</code>接口，可以获取应用程序的环境信息，如操作系统、Java版本、系统属性等</li><li>配置信息：通过访问<code>/actuator/configprops</code>接口，可以获取应用程序的配置信息，包括SpringBoot自动配置的所有Bean和其属性</li><li>执行器端点：除了以上几个端点，SpringBoot还提供了一系列执行器端点，可以访问应用程序内部状态和功能，如<code>/actuator/beans</code>、<code>/actuator/mappings</code>、<code>/actuator/trace</code>等</li></ol></li><li>监视器功能可以通过在pom.xml文件中引入<code>spring-boot-starter-actuator</code>依赖实现，该依赖会自动配置Actuator模块，并启用所有的端点。可以通过配置文件或<code>@Endpoint</code>注解对端点进行自定义配置</li></ul>              </div>            </details></li><li>如何使用SpringBoot实现异常处理<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在SpringBoot中，可以使用<code>@ControllerAdvice</code>注解定义一个全局异常处理器，来统一处理应用程序中的异常，具体实现步骤如下<ol><li>定义一个异常处理类，并使用<code>@ControllerAdvice</code>注解来标注，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHanlder(value = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 处理异常，并返回合适的HTTP响应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在处理方法中定义<code>@ExceptionHandler</code>注解，指定需要处理的异常类型。可以使用多个<code>@ExceptionHandler</code>注解定义不同的处理方法来处理不同类型的异常 </li><li>处理异常，并返回合适的HTTP响应，可以返回一个自定义的错误信息、一个HTTP错误码，或者其他合适的响应</li></ol></li></ul>              </div>            </details></li><li>SpringBoot中常用的starter有哪些<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>spring-boot-starter-web</code>：用于构建Web应用程序，包括Spring MVC、Tomcat容器等。</li><li><code>spring-boot-starter-data-jpa</code>：用于使用JPA和Hibernate进行持久化操作。 </li><li><code>spring-boot-starter-data-redis</code>：用于使用Redis进行数据缓存和持久化操作。</li><li><code>spring-boot-starter-security</code>：用于构建安全的Web应用程序，包括Spring Security、OAuth2等。</li><li><code>spring-boot-starter-actuator</code>：用于监视应用程序的运行状况和性能指标，包括健康检查、指标监控、环境信息、配置信息等。</li><li><code>spring-boot-starter-test</code>：用于构建测试应用程序，包括JUnit、Mockito、Hamcrest等。</li><li><code>spring-boot-starter-log4j2</code>：用于使用Log4j2进行日志记录。</li><li><code>spring-boot-starter-logging</code>：用于使用SLF4J和Logback进行日志记录。 </li><li><code>spring-boot-starter-amqp</code>：用于使用AMQP进行消息队列和消息总线操作。</li></ol>              </div>            </details></li><li>SpringBoot实现热部署有哪几种方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在SpringBoot中，可以通过以下几种方式来实现热部署<ol><li>使用<code>SpringBoot DevTools</code>：<code>SpringBoot DevTools</code>提供了许多开发工具，包括自动重启、热部署等功能。只需将<code>spring-boot-devtools</code>依赖添加到项目中即可启用该功能</li><li>使用<code>Spring Loaded</code>：<code>Spring Loaded</code>是一个轻量级的Java类热部署工具，可以让开发者在不停止和重新启动应用程序的情况下更新Java类，只需将<code>spring-loaded</code>依赖添加到项目中即可启用该功能</li><li>使用<code>JRebel</code>：<code>JRebel</code>是一款商业化的Java类热部署工具，需要将JRebel插件集成到开发环境中才能使用</li></ol></li></ul>              </div>            </details></li><li>如何理解SpringBoot配置加载顺序<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><p>在Spring Boot中，配置文件的加载顺序是非常重要的，不同的加载顺序可以对应不同的配置场景。Spring Boot的配置加载顺序如下：</p><ol><li><p>命令行参数：Spring Boot可以通过命令行参数来动态地修改配置。例如，可以使用<code>--server.port=8080</code>来指定应用程序的端口号。</p></li><li><p>Java系统属性：可以通过-D参数设置Java系统属性，这些属性可以在Spring Boot应用程序中直接使用。例如，可以使用<code>-Dapp.version=1.0.0</code>来设置应用程序版本号。</p></li><li><p>OS环境变量：Spring Boot可以读取操作系统的环境变量，这些环境变量可以在应用程序中直接使用。例如，可以使用<code>export APP_NAME=myapp</code>来设置应用程序名称。</p></li><li><p><code>application.properties</code>或<code>application.yml</code>文件：Spring Boot会自动加载application.properties或application.yml文件中的配置。其中，application.properties文件使用key=value的格式，application.yml文件使用YAML格式。这些配置文件可以放置在src/main/resources目录下或classpath的根目录下。</p></li><li><p>指定的配置文件：可以通过<code>spring.config.name</code>和<code>spring.config.location</code>属性来指定要加载的配置文件。例如，可以使用<code>--spring.config.name=myconfig</code>、<code>--spring.config.location=/etc/myapp/</code>来加载指定的配置文件。</p></li><li><p>通过<code>@ConfigurationProperties</code>注解加载配置：可以使用<code>@ConfigurationProperties</code>注解来将配置文件中的属性映射到Java类中。</p></li></ol></li></ul>              </div>            </details></li><li>SpringBoot的核心配置文件有哪几个？他们的区别是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在SpringBoot中，有以下两种核心配置文件<ol><li>application.yml：这是SpringBoot应用程序的主要配置文件，其中包含了应用程序中的各种配置属性，如数据库连接、端口号等</li><li>bootstrap.yml：它的主要应用场景是当应用程序需要连接到外部服务时，可以将连接属性(如用户名、密码、端口等)配置在bootstrap文件中，以便在应用程序启动时就能够加载这些属性。这样做可以避免将敏感信息直接暴露在应用程序的配置文件中，提高应用程序的安全性。例如我们使用SpringCloud Config作为应用程序的配置服务器，那么我们需要在bootstrap中配置如下属性 <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">http://localhost:8888</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br></pre></td></tr></table></figure><ul><li>这些属性将在应用程序启动时加载，并用于与配置服务器进行通信，以获取应用程序的配置信息。由于这些属性是保存在bootstrap文件中的，因此可以避免在应用程序配置文件中直接暴露这些属性。</li></ul></li></ol></li></ul>              </div>            </details></li><li>如何集成SpringBoot和ActiveMQ<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>要集成SpringBoot和ActiveMQ，需要进行以下步骤<ol><li>添加ActiveMQ依赖，在SpringBoot项目的pom.xml文件中添加如下依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>配置ActiveMQ连接，在application.yml中配置ActiveMQ的连接信息，例如<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure></li><li>创建JMS消息队列或主题：可以使用@Bean注解创建Queue或Topic对象，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(<span class="string">&quot;my-queue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>发送和接收JMS消息：可以使用JmsTemplate来发送和接收JMS消息，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    jmsTemplate.convertAndSend(<span class="string">&quot;my-queue&quot;</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JmsListener(destination = &quot;my-queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(5)</title>
      <link href="/2023/04/26/JVMPart/JVM_5/"/>
      <url>/2023/04/26/JVMPart/JVM_5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul><li>很多人将<code>Java内存结构</code>和<code>Java内存模型</code>傻傻分不清，<code>Java内存模型</code>是<code>Java Memory Model</code>(JMM)的意思</li><li>简单地说，JMM定义了一套在多线程读写共享数据时（成员变量、数组），对数据的可见性、有序性和原子性的规则和保障</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li>原子性在前面的文章也提过，现在来简单回顾一下</li><li>两个线程对初始值为0的静态变量，一个做自增，一个做自减，各做5000次，那么最终结果是0吗？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li>以上的结果可能是正数、负数、零。为什么呢？</li><li>因为Java中对静态变量的自增、自减操作并不是原子操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">     <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">     <span class="number">3</span>: iconst_1</span><br><span class="line">     <span class="number">4</span>: iadd</span><br><span class="line">     <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">     <span class="number">8</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">    <span class="number">11</span>: iconst_1</span><br><span class="line">    <span class="number">12</span>: isub</span><br><span class="line">    <span class="number">13</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field i:I</span></span><br><span class="line">    <span class="number">16</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li><li>对于i++而言（注意i为静态常量），实际上会产生如下字节码指令<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #<span class="number">2</span>    <span class="comment">// 获取静态常量 i 的值</span></span><br><span class="line">iconst_1            <span class="comment">// 准备常量 1</span></span><br><span class="line">iadd                <span class="comment">// 加法（如果是局部变量，则调用的是iinc）</span></span><br><span class="line">putstatic     #<span class="number">2</span>    <span class="comment">// 将修改后的值存入静态变量 i</span></span><br></pre></td></tr></table></figure></li><li>而对于i—而言，也是类似的操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #<span class="number">2</span>    <span class="comment">// 获取静态常量 i 的值</span></span><br><span class="line">iconst_1            <span class="comment">// 准备常量 1</span></span><br><span class="line">isub                <span class="comment">// 减法</span></span><br><span class="line">putstatic     #<span class="number">2</span>    <span class="comment">// 将修改后的值存入静态变量 i</span></span><br></pre></td></tr></table></figure></li><li>在多线程环境下，这些指令可能会被CPU交错的执行，就会导致我们看到的结果出现问题</li><li>Java的内存模型如下，完成静态变量的自增、自减需要在主存与线程内存中进行数据交换<br><img src="https://s1.ax1x.com/2023/04/11/ppOSFv4.png" alt=""></li><li>出现负数的情况：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic i         <span class="comment">// 线程1-获取静态变量i的值 线程内i=0</span></span><br><span class="line">getstatic i         <span class="comment">// 线程2-获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1            <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">iadd                <span class="comment">// 线程1-自增 线程内i=1</span></span><br><span class="line">putstatic i         <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span></span><br><span class="line">iconst_1            <span class="comment">// 线程2-准备常量1</span></span><br><span class="line">isub                <span class="comment">// 线程2-自减 线程内i=-1</span></span><br><span class="line">putstatic i         <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br></pre></td></tr></table></figure></li><li>出现正数的情况：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0</span></span><br><span class="line">getstatic i         <span class="comment">// 线程1-获取静态变量i的值 线程内i=0</span></span><br><span class="line">getstatic i         <span class="comment">// 线程2-获取静态变量i的值 线程内i=0</span></span><br><span class="line">iconst_1            <span class="comment">// 线程1-准备常量1</span></span><br><span class="line">iadd                <span class="comment">// 线程1-自增 线程内i=1</span></span><br><span class="line">iconst_1            <span class="comment">// 线程2-准备常量1</span></span><br><span class="line">isub                <span class="comment">// 线程2-自减 线程内i=-1</span></span><br><span class="line">putstatic i         <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span></span><br><span class="line">putstatic i         <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用synchronized（同步关键字），语法如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    要作为原子操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>解决上面的问题，在<code>i++</code>和<code>i--</code>操作处加锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以把obj想象成一间房间（撤硕），线程t1、线程t2想象成两个人</li><li>当线程t1执行到<code>synchronized(obj)</code>时，就好比t1进入了撤硕，并反手锁住了门，在门内执行<code>i++</code>操作</li><li>此时如果t2也运行到了<code>synchronized(obj)</code>，它发现门被锁住了，只能在门外等待</li><li>当t1执行完synchronized块内的代码，此时才会解开门上的锁，从撤硕出来，t2线程此时才可以进入撤硕，并反手锁住门，执行它的<code>i--</code>操作<div class="note warning no-icon flat"><ul><li>注意：上例中的t1和t2线程都必须使用synchronized锁住同一个obj对象，如果t1锁住的是x对象，t2锁住的是y对象，就好比两个人进入了两个不同的撤硕，没法起到同步的效果</li></ul></div></li><li>最后，也建议将synchronized加锁的范围设置的大一些，刚刚的代码中，仅在<code>i++</code>操作上加锁，锁住了4条虚拟机指令，但是外层循环了5W次，那就要加锁解锁5W次，这样是比较耗时的，那么此时我们就可以直接在for循环上加锁，这样就只用解锁一次<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><ul><li>可见性指的是当一个线程修改了共享变量的值后，其他线程能够立即看到这个修改的结果。在单线程环境下，修改变量的值和读取变量的值都是在同一个线程内进行的，所以不存在可见性问题。但是在多线程环境下，由于每个线程都有自己的缓存，所以可能出现一个线程修改了共享变量的值，但是其他线程还是看到原来的旧值的情况。</li></ul><h2 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h2><ul><li>先来看一个现象，main线程对run变量的修改，对于t线程不可见，导致t线程无法停止<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);     <span class="comment">//  休眠 1 秒</span></span><br><span class="line">        run = <span class="keyword">false</span>;            <span class="comment">// 此时将run改为false，按理说上面的while循环应该会结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>那这是为什么呢？我们来分析一下<psw>（提示：联想一下上篇文章的JIT优化）</psw><ol><li>初始状态：t线程刚开始就从主存读取到了run的值到工作内存<br><img src="https://s1.ax1x.com/2023/04/11/ppOC3MF.png" alt=""></li><li>因为t线程要频繁的从主存中读取run的值，JIT编译器会将run的值缓存至自己工作内存的高速缓存中，减少对主存中run的访问，提高效率<br><img src="https://s1.ax1x.com/2023/04/11/ppOCtaR.png" alt=""></li><li>1秒过后，main线程修改了run值，并同步至主存，但是t现在已经是从自己工作内存的高速缓存中读取的run，结果永远是true<br><img src="https://s1.ax1x.com/2023/04/11/ppOCaPx.png" alt=""></li></ol></li></ul><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>可见性问题的方法是通过使用<code>volatile</code>关键字来声明共享变量。在使用了<code>volatile</code>关键字声明的共享变量上进行读写操作时，JVM会保证所有线程都能够看到该变量的最新值，从而解决可见性问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (run) &#123;</span><br><span class="line">                <span class="comment">//TODO</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        run = <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>此时程序运行1秒后就会停下来了<div class="note warning no-icon flat"><ul><li>synchronized语句块既可以保证代码的原子性，同时也可以保证代码块内变量的可见性。但缺点是synchronized属于重量级操作，性能相对较低</li></ul></div></li><li>如果在前面示例的死循环中，加入一条输出指令<code>System.out.println()</code>会发现，即使不加volatile修饰符，线程t也正确看到run变量的修改了，这是为什么呢？<ul><li>因为System.out.println()语句具有同步锁的效果，它会强制刷新CPU缓存，从而强制线程从主内存中读取变量的值。这与volatile的作用相似，可以保证线程获取到最新的变量值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine( );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><h2 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h2><ul><li>先来看一段代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        p.age = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.age = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Person是一个对象，有一个属性age用来保存结果，那么上面的代码会有几种可能？<ol><li>线程1先执行，此时<code>ready = false</code>，进入else分支，结果是<code>1</code></li><li>线程2先执行，<code>num = 2</code>，<code>ready = true</code>，线程1执行是，<code>ready = true</code>，执行if分支，同时<code>num = 2</code>，结果是<code>4</code></li><li>线程2先执行，<code>num = 2</code>，还没来得及执行<code>ready = true</code>，此时线程1执行，<code>ready = false</code>，进入else分支，结果是<code>1</code></li></ol></li><li>但是其实还有一种可能，结果是0<ul><li>这种情况下：线程2先执行<code>ready = true</code>，切回到线程1，进入if分支，相加为0，再切回线程2执行<code>num = 2</code></li></ul></li><li><p>这种现象叫：<code>指令重排</code></p><ul><li>指令重排是指在编译器或者JIT编译器优化过程中，为了提高程序的性能而重新排列指令的执行顺序，以便在运行时更加高效地执行。</li><li>指令重排并不会改变程序的语义，但它可能会改变程序的执行顺序，从而导致程序出现错误或异常。</li><li>指令重排需要通过大量测试才能发现，借助java并发压测工具<code>jcstress</code></li><li>在JVM中，指令重排主要有以下三种类型：<ol><li>编译器重排：编译器在生成目标代码时对指令进行重排，以提高代码的性能。</li><li>运行时重排：JIT编译器在运行时对字节码进行优化，对指令进行重排，以提高程序的性能。</li><li>处理器重排：现代处理器具有乱序执行的能力，可以根据需要重新排列指令的执行顺序，以提高指令的执行效率。</li></ol></li><li>指令重排的好处是可以提高程序的性能，但也有风险。如果重排不当，可能会导致程序出现错误或异常。为了避免这种情况，JVM提供了一些机制，例如volatile关键字、synchronized关键字、final关键字等，以保证程序的正确性。</li></ul></li><li><p>运行如下maven命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=<span class="number">0.5</span> -DgroupId=com.demo.jmm -DartifactId=com.demo.jmm.my-test-project -Dversion=<span class="number">1.0</span>-SNAPSHOT</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/04/11/ppOExQx.png" alt=""></p></li><li>修改生成的测试方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行maven clean install，生成jar包<br><img src="https://s1.ax1x.com/2023/04/11/ppOVe6P.png" alt=""></li><li>使用java -jar命令启动测试，结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests</span><br><span class="line">  Some interesting behaviors observed. This is for the plain curiosity.</span><br><span class="line"></span><br><span class="line">  2 matching test results. </span><br><span class="line">      [OK] com.demo.jmm.ConcurrencyTest</span><br><span class="line">    (JVM args: [-XX:-TieredCompilation])</span><br><span class="line">  Observed state   Occurrences              Expectation  Interpretation</span><br><span class="line">               0         4,118   ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">               1   100,677,962               ACCEPTABLE  ok</span><br><span class="line">               4    65,352,081               ACCEPTABLE  ok</span><br><span class="line"></span><br><span class="line">      [OK] com.demo.jmm.ConcurrencyTest</span><br><span class="line">    (JVM args: [])</span><br><span class="line">  Observed state   Occurrences              Expectation  Interpretation</span><br><span class="line">               0         4,446   ACCEPTABLE_INTERESTING  !!!!</span><br><span class="line">               1    70,399,953               ACCEPTABLE  ok</span><br><span class="line">               4    64,934,892               ACCEPTABLE  ok</span><br></pre></td></tr></table></figure></li><li>可以看到，出现结果为0的次数有4118次，虽然次数相对较少，但毕竟还是出现了</li></ul><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用volatile修饰的变量，可以禁用指令重排<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests</span><br><span class="line">  Some interesting behaviors observed. This is for the plain curiosity.</span><br><span class="line"></span><br><span class="line">  0 matching test results.</span><br></pre></td></tr></table></figure></li></ul><h2 id="有序性理解"><a href="#有序性理解" class="headerlink" title="有序性理解"></a>有序性理解</h2><ul><li>JVM会在不影响正确性的前提下，调整语句的执行顺序，来看一下下面的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个线程内执行如下赋值操作（单线程）</span></span><br><span class="line">i = ...;    <span class="comment">// 较为耗时的操作</span></span><br><span class="line">j = ...l    <span class="comment">// 简单的 操作</span></span><br></pre></td></tr></table></figure></li><li>可以看到，不管是先执行i还是先执行j，对最终的结果都不会产生影响，所以上面两条语句的执行顺序可以任意的排列组合</li><li>这种特性被称之为<code>指令重排</code>，多线程下的指令重排会影响正确性，例如著名的<code>double-checked-locking</code>模式实现单例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上的实现的特点是<ol><li>懒惰实例化</li><li>首次使用getInstance()才使用synchronized加锁，后续使用时无需加锁</li></ol></li><li>但是在多线程环境下，上面的代码是有问题的，<code>INSTANCE = new Singleton();</code>对应的字节码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span> #<span class="number">2</span>               <span class="comment">// class cn/itcast/jvm/t4/Singleton</span></span><br><span class="line"><span class="number">3</span>: dup  </span><br><span class="line"><span class="number">4</span>: invokespecial #<span class="number">3</span>     <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">7</span>: putstatic #<span class="number">4</span>         <span class="comment">// Field</span></span><br></pre></td></tr></table></figure></li><li>其中<code>4</code>和<code>7</code> 两步的顺序不是固定的，也许jvm会优化为：先将引用地址赋给INSTANCE变量后，再执行构造方法，如果两个线程t1、t2按如下时间序列执行<ol><li>时间1 <code>t1</code> 线程执行到 <code>INSTANCE = new Singleton();</code></li><li>时间2 <code>t1</code> 线程分配空间，为Singleton对象生成了引用地址（0 处）</li><li>时间3 <code>t1</code> 线程将引用地址赋值给 INSTANCE，这时 <code>INSTANCE != null</code>（7 处）</li><li>时间4 <code>t2</code> 线程进入<code>getInstance()</code> 方法，发现 <code>INSTANCE != null</code>（synchronized块外），直接返回 INSTANCE</li><li>时间5 <code>t1</code> 线程执行Singleton的构造方法（4 处）</li></ol></li><li>此时t1还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的将是一个未完成初始化的单例</li><li>对INSTANCE使用volatile修饰即可，可以禁用指令重排</li></ul><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><ul><li>happens-before规定了哪些写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结。抛开以下happens-before规则，JMM不能保证一个线程对共享变量的<code>写</code>，对于其他线程对该共享变量的<code>读</code>是<code>可见</code>的</li></ul><ol><li>线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对该变量的读可见 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (m) &#123;</span><br><span class="line">            x = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (m) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在线程t2中，当获取了对象m的锁之后，线程可以读取到线程t1对变量x的写入结果。</li></ul></li><li>线程对volatile变量的写，对接下来其他线程对该变量的读可见 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在线程t2中，当读取变量x的值时，可以看到线程t1对变量x的最新写入结果，而不会读取到变量x的旧值。</li></ul></li><li>线程start前对变量的写，对该线程开始后对该变量的读可见 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线程结束前对变量的写，对其他线程得知它结束后的读可见 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当主线程中读取变量x的值时，可以看到线程t1对变量x的写入结果。</li></ul></li><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span> (!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码创建了两个线程t1和t2。线程t2在一个无限循环中不断检查自身的中断状态，如果发现自己被打断则打印变量x的值并跳出循环，线程t1会在1秒后修改变量x的值并打断线程t2。</li><li>线程t1在打断线程t2之前对变量x的写操作对于其他线程得知线程t2被打断后的读操作可见。在本例中，线程t1在修改变量x的值并打断线程t2之前会先睡眠1秒，因此线程t2的循环会在线程t1修改变量x的值之后才会被打断。此时，线程t2中对变量x的读操作就能看到线程t1对变量x的修改。</li></ul></li></ol><h1 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h1><ul><li>CAS即<code>Compare And Swap</code>，它体现的是一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 <code>+1</code> 操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> 旧值 = 共享变量;    <span class="comment">// 比如当前共享变量是 0</span></span><br><span class="line">    <span class="keyword">int</span> 结果 = 旧值 + <span class="number">1</span>;    <span class="comment">// 在旧值的基础上 +1 ，结果是 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时如果别的线程将共享变量改为了 5，那么本线程的正确结果 1 就作废了</span></span><br><span class="line"><span class="comment">        此时compareAndSwap 返回 false，重新尝试</span></span><br><span class="line"><span class="comment">        直到compareAndSwap 返回 true，表示本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span>(compareAndSwap(旧值, 结果)) &#123;</span><br><span class="line">        <span class="comment">// 比较旧值和当前共享变量是否相等</span></span><br><span class="line">        <span class="comment">// 成功，退出循环</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获取共享变量时，为了保证该变量的可见性需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下<ul><li>因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li><li>CAS底层依赖于一个Unsafe类来直接调用操作系统底层的CAS指令，下面是直接使用Unsafe对象进行线程安全保护的一个例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DataContainer dc = <span class="keyword">new</span> DataContainer();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                dc.increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(dc.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Unsafe 对象不能直接调用，只能通过反射获得</span></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span></span><br><span class="line">            DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span></span><br><span class="line">            oldValue = data;</span><br><span class="line">            <span class="comment">// cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>, DATA_OFFSET, oldValue, oldValue +</span><br><span class="line">                    <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            oldValue = data;</span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>, DATA_OFFSET, oldValue, oldValue -</span><br><span class="line">                    <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><ul><li>CAS是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就散改了也没关系，我吃亏点再重试呗</li><li>synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了再解开锁，你们才有机会来</li></ul><h2 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h2><ul><li>JUC(java.util.concurrent)中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，它们底层就是采用CAS技术+volatile来实现的</li><li>可以使用AtomicInteger改写之前的例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMM07</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子整数对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndIncrement();    <span class="comment">// 获取并且自增 i++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndDecrement();    <span class="comment">// 获取并且自增 i--</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">// 最终的结果总是0</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h1><ul><li>Java HotSpot虚拟机中，每个对象都有对象头（包括class指针和Mark Word），Mark Word平时存储这个对象的<code>哈希码</code>、<code>分代年龄</code>，当加锁时，这些信息就根据情况被替换为<code>标记位</code>、<code>线程锁记录指针</code>、<code>重量级锁指针</code>、<code>线程ID</code>等内容</li></ul><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><ul><li>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么就可以使用轻量级锁来优化，就好比<ul><li>学生A（线程A）用课本占座，上了半节课就出门了（CPU时间到了），回来一看，发现课本还在，说明没有竞争，继续上他的课</li><li>如果此时其他学生B（线程B）来了，会告知学生A（线程A）有并发访问，线程A随即升级为重量级锁，进入重量级锁的流程</li><li>而重量级锁就不是用课本占座那么简单了，在学生A走之前，把座位用铁栅栏围了起来</li><li>假设有两个方法同步块，利用同一个对象加锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A    </span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">线程 1</th><th style="text-align:center">对象 Mark Word</th><th style="text-align:center">线程 2</th></tr></thead><tbody><tr><td style="text-align:center">访问同步块 A，把 Mark 复制到线程 1 的锁记录</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">CAS 修改 Mark 为线程 1 锁记录地址</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（加锁）</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块 A</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">访问同步块 B，把 Mark 复制到线程 1 的锁记录</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">CAS 修改 Mark 为线程 1 锁记录地址</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">失败（发现是自己的锁）</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">锁重入</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块 B</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">同步块 B 执行完毕</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">同步块 A 执行完毕</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（解锁）</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">访问同步块 A，把 Mark 复制到线程 2 的锁记录</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">00（轻量锁）线程 2锁记录地址</td><td style="text-align:center">成功（加锁）</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><ul><li>如果在尝试加轻量级锁的过程中，CAS操作无法完成，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时就需要进行锁膨胀，将轻量级锁变为重量级锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A    </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">线程 1</th><th style="text-align:center">对象 Mark Word</th><th style="text-align:center">线程 2</th></tr></thead><tbody><tr><td style="text-align:center">访问同步块 A，把 Mark 复制到线程 1 的锁记录</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">CAS 修改 Mark 为线程 1 锁记录地址</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（加锁）</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">访问同步块，把 Mark 复制到线程 2</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">CAS 修改 Mark 为线程 2 锁记录地址</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">失败（发现别人已经占了锁）</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">00（轻量锁）线程 1 锁记录地址</td><td style="text-align:center">CAS 修改 Mark 为重量锁</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">阻塞中</td></tr><tr><td style="text-align:center">执行完毕</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">阻塞中</td></tr><tr><td style="text-align:center">失败（解锁）</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">阻塞中</td></tr><tr><td style="text-align:center">释放重量锁，唤起阻塞线程竞争</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">阻塞中</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）</td><td style="text-align:center">竞争重量锁</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）</td><td style="text-align:center">成功（加锁）</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><h2 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h2><ul><li>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。<ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul></li><li>自旋重试成功的情况</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">线程 1 （cpu 1 上）</th><th style="text-align:center">对象 Mark</th><th style="text-align:center">线程 2 （cpu 2 上）</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">访问同步块，获取 monitor</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（加锁）</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">访问同步块，获取 monitor</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行完毕</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">成功（解锁）</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">成功（加锁）</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">执行同步块</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><ul><li>自旋重试失败的情况</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">线程 1（cpu 1 上）</th><th style="text-align:center">对象 Mark</th><th style="text-align:center">线程 2（cpu 2 上）</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">访问同步块，获取 monitor</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（加锁）</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">访问同步块，获取 monitor</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">阻塞</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table></div><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul><li>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID是自己的就表示没有竞争，不用重新 CAS.<ul><li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li><li>访问对象的 hashCode 也会撤销偏向锁</li><li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，</li><li>重偏向会重置对象的 Thread ID</li><li>撤销偏向和重偏向都是批量进行的，以类为单位</li><li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li><li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li></ul></li><li>假设有两个方法同步块，利用同一个对象加锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">线程 1</th><th style="text-align:center">对象 Mark</th></tr></thead><tbody><tr><td style="text-align:center">访问同步块 A，检查 Mark 中是否有线程 ID</td><td style="text-align:center">101（无锁可偏向）</td></tr><tr><td style="text-align:center">尝试加偏向锁</td><td style="text-align:center">101（无锁可偏向）对象 hashCode</td></tr><tr><td style="text-align:center">成功</td><td style="text-align:center">101（无锁可偏向）线程ID</td></tr><tr><td style="text-align:center">执行同步块 A</td><td style="text-align:center">101（无锁可偏向）线程ID</td></tr><tr><td style="text-align:center">访问同步块 B，检查 Mark 中是否有线程 ID</td><td style="text-align:center">101（无锁可偏向）线程ID</td></tr><tr><td style="text-align:center">是自己的线程 ID，锁是自己的，无需做更多操作</td><td style="text-align:center">101（无锁可偏向）线程ID</td></tr><tr><td style="text-align:center">执行同步块 B</td><td style="text-align:center">101（无锁可偏向）线程ID</td></tr><tr><td style="text-align:center">执行完毕</td><td style="text-align:center">101（无锁可偏向）对象 hashCode</td></tr></tbody></table></div><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ol><li><p>减少上锁时间</p><ul><li>同步代码块中尽量短</li></ul></li><li><p>减少锁的粒度</p><ul><li>将一个锁拆分为多个锁提高并发度，例如<ul><li>ConcurrentHashMap</li><li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li><li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li></ul></li></ul></li><li><p>锁粗化</p><ul><li>多次循环进入同步块不如同步块内多次循环</li><li>另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StringBuffer().append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li>锁消除<ul><li>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</li></ul></li><li>读写分离<ul><li>CopyOnWriteArrayList</li><li>ConyOnWriteSet</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(4)</title>
      <link href="/2023/04/26/JVMPart/JVM_4/"/>
      <url>/2023/04/26/JVMPart/JVM_4/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><ul><li>一个简单的HelloWorld.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后查看其二进制字节码文件的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -t xC target/classes/com/demo/HelloWorld.class</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2023/04/05/pp5L8lF.png" alt=""></p></li><li><p>根据JVM规范，类文件结构如下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ClassFile</span> &#123;</span><br><span class="line">    <span class="selector-tag">u4</span> <span class="selector-tag">magic</span>;                  <span class="comment">// 魔数，用于标识文件类型</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">minor_version</span>;          <span class="comment">// Java虚拟机的次版本号</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">major_version</span>;          <span class="comment">// Java虚拟机的主版本号</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">constant_pool_count</span>;    <span class="comment">// 常量池大小</span></span><br><span class="line">    <span class="selector-tag">cp_info</span> <span class="selector-tag">constant_pool</span><span class="selector-attr">[constant_pool_count-1]</span>; <span class="comment">// 常量池数组</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">access_flags</span>;           <span class="comment">// 访问标识符，用于表示类或接口的访问控制</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">this_class</span>;             <span class="comment">// 当前类或接口的索引</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">super_class</span>;            <span class="comment">// 当前类的超类(父类)索引</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">interfaces_count</span>;       <span class="comment">// 接口数量</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">interfaces</span><span class="selector-attr">[interfaces_count]</span>; <span class="comment">// 接口索引列表</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">fields_count</span>;           <span class="comment">// 字段数量</span></span><br><span class="line">    <span class="selector-tag">field_info</span> <span class="selector-tag">fields</span><span class="selector-attr">[fields_count]</span>; <span class="comment">// 字段信息数组</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">methods_count</span>;          <span class="comment">// 方法数量</span></span><br><span class="line">    <span class="selector-tag">method_info</span> <span class="selector-tag">methods</span><span class="selector-attr">[methods_count]</span>; <span class="comment">// 方法信息数组</span></span><br><span class="line">    <span class="selector-tag">u2</span> <span class="selector-tag">attributes_count</span>;       <span class="comment">// 类或接口的附加属性数量</span></span><br><span class="line">    <span class="selector-tag">attribute_info</span> <span class="selector-tag">attributes</span><span class="selector-attr">[attributes_count]</span>; <span class="comment">// 类或接口的附加属性信息数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><ul><li><p>以下面的字节码文件，按顺序逐个进行分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00</span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00</span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure></li><li><p>0-3字节，表示它是否是<code>class</code>类型的文件</p><ul><li>0000000 <code>ca fe ba be</code> 00 00 00 34 00 22 0a 00 06 00 14 09</li></ul></li><li>在Java中，所有的.class文件都以魔数<code>ca fe ba be</code>开头，这个魔数的前4个字节用于识别该文件是否为Java类文件，如果这个魔数不匹配，那么Java虚拟机将无法加载该文件。<div class="note info no-icon flat"><ul><li>关于<code>cafebabe</code>这个魔数的由来并没有具体的官方解释，但有一些有趣的猜测和传说。<ul><li>一种说法是，这个魔数是由Java的创造者之一、现任谷歌高管James Gosling取的。据说Gosling是个爱好咖啡的人，他认为Java这个名字也与咖啡有关，所以他将cafebabe取作魔数来向咖啡致敬。另外，有一种传说认为这个魔数是来自于一个好莱坞电影中的经典台词，<code>cafe babe</code>（咖啡宝贝？）。</li><li>然而，无论是什么样的由来，cafebabe这个魔数现在已经成为Java世界中的一个标志，每一个Java程序员都能够轻松地辨认出这个魔数，这也是Java文件格式稳定性的一个体现。</li></ul></li></ul></div></li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>4-7字节，表示类的版本 <code>00 34(52)</code>对应十进制为52，表示的是<code>Java 8</code></li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><div class="table-container"><table><thead><tr><th style="text-align:center">Constant Type</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">CONSTANT_Utf8</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">CONSTANT_Integer</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">CONSTANT_Float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">CONSTANT_Long</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">CONSTANT_Double</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">CONSTANT_Class</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">CONSTANT_String</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">CONSTANT_Fieldref</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">CONSTANT_Methodref</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">CONSTANT_InterfaceMethodref</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">CONSTANT_NameAndType</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">CONSTANT_MethodHandle</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">CONSTANT_MethodType</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">CONSTANT_InvokeDynamic</td><td style="text-align:center">18</td></tr></tbody></table></div><ul><li>8-9字节，表示常量池长度<ul><li>0000000 ca fe ba be 00 00 00 34 <code>00 22</code> 0a 00 06 00 14 09</li><li><code>00 22(34)</code>，表示常量池有<code>#1-#33</code>项，注意#0项不计入，也没有值</li></ul></li></ul><ol><li><p><code>第#1项</code> 0a 表示一个 Method 信息，00 06 和 00 14（20） 表示它引用了常量池中 #6 和 #20 项来获得这个方法的<code>所属类</code>和<code>方法名</code></p><ul><li>0000000 ca fe ba be 00 00 00 34 00 22 <code>0a 00 06 00 14</code> 09</li></ul></li><li><p><code>第#2项</code> 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项来获得这个成员变量的<code>所属类</code>和<code>成员变量名</code></p><ul><li>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <code>09</code></li><li>0000020 <code>00 16 00 17</code> 08 00 18 0a 00 19 00 1a 07 00 1b 07</li></ul></li><li><p><code>第#3项</code> 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项</p><ul><li>0000020 00 16 00 17 <code>08 00 18</code> 0a 00 19 00 1a 07 00 1b 07</li></ul></li><li><p><code>第#4项</code> 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26项来获得这个方法的<code>所属类</code>和<code>方法名</code></p><ul><li>0000020 00 16 00 17 08 00 18 <code>0a 00 19 00 1a</code> 07 00 1b 07</li></ul></li><li><code>第#5项</code> 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项<ul><li>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <code>07 00 1b</code> 07</li></ul></li><li><code>第#6项</code> 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项<ul><li>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <code>07</code></li><li>0000040 <code>00 1c</code> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</li></ul></li><li><code>第#7项</code> 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是<code>&lt;init&gt;</code><ul><li>0000040 00 1c 01 <code>00 06 3c 69 6e 69 74 3e</code> 01 00 03 28 29</li></ul></li><li><code>第#8项</code> 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是<code>()V</code>其实就是表示无参、无返回值<ul><li>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <code>01 00 03 28 29</code></li><li>0000060 <code>56</code> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</li></ul></li><li><code>第#9项</code> 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是<code>Code</code><ul><li>0000060 56 <code>01 00 04 43 6f 64 65</code> 01 00 0f 4c 69 6e 65 4e</li></ul></li><li><code>第#10项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是<code>LineNumberTable</code><ul><li>0000060 56 01 00 04 43 6f 64 <code>65 01 00 0f 4c 69 6e 65 4e</code></li><li>0000100 <code>75 6d 62 65 72 54 61 62 6c 65</code> 01 00 12 4c 6f 63</li></ul></li><li><code>第#11项</code> 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是<code>LocalVariableTable</code><ul><li>0000100 75 6d 62 65 72 54 61 62 6c 65 <code>01 00 12 4c 6f 63</code></li><li>0000120 <code>61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65</code> 01</li></ul></li><li><code>第#12项</code> 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是<code>this</code><ul><li>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 <code>01</code></li><li>0000140 <code>00 04 74 68 69 73</code> 01 00 1d 4c 63 6e 2f 69 74 63</li></ul></li><li><code>第#13项</code> 01 表示一个 utf8 串，00 1d（29） 表示长度，是<code>Lcn/itcast/jvm/t5/HelloWorld;</code><ul><li>0000140 00 04 74 68 69 73 <code>01 00 1d 4c 63 6e 2f 69 74 63</code></li><li>0000160 <code>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</code></li><li>0000200 <code>57 6f 72 6c 64 3b</code> 01 00 04 6d 61 69 6e 01 00 16</li></ul></li><li><code>第#14项</code> 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是<code>main</code><ul><li>0000200 57 6f 72 6c 64 3b <code>01 00 04 6d 61 69 6e</code> 01 00 16</li></ul></li><li><code>第#15项</code> 01 表示一个 utf8 串，00 16（22） 表示长度，是<code>([Ljava/lang/String;)V</code>其实就是参数为字符串数组，无返回值<ul><li>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e <code>01 00 16</code></li><li>0000220 <code>28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</code></li><li>0000240 <code>69 6e 67 3b 29 56</code> 01 00 04 61 72 67 73 01 00 13</li></ul></li><li><code>第#16项</code> 01 表示一个 utf8 串，00 04 表示长度，是<code>args</code><ul><li>0000240 69 6e 67 3b 29 56 <code>01 00 04 61 72 67 73</code> 01 00 13</li></ul></li><li><code>第#17项</code> 01 表示一个 utf8 串，00 13（19） 表示长度，是<code>[Ljava/lang/String;</code><ul><li>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 <code>01 00 13</code></li><li>0000260 <code>5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</code></li><li>0000300 <code>6e 67 3b</code> 01 00 10 4d 65 74 68 6f 64 50 61 72 61</li></ul></li><li><code>第#18项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>MethodParameters</code><ul><li>0000300 6e 67 3b <code>01 00 10 4d 65 74 68 6f 64 50 61 72 61</code></li><li>0000320 <code>6d 65 74 65 72 73</code> 01 00 0a 53 6f 75 72 63 65 46</li></ul></li><li><code>第#19项</code> 01 表示一个 utf8 串，00 0a（10） 表示长度，是<code>SourceFile</code><ul><li>0000320 6d 65 74 65 72 73 <code>01 00 0a 53 6f 75 72 63 65 46</code></li><li>0000340 <code>69 6c 65</code> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</li></ul></li><li><code>第#20项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，是<code>HelloWorld.java</code><ul><li>0000340 69 6c 65 <code>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</code></li><li>0000360 <code>2e 6a 61 76 61</code> 0c 00 07 00 08 07 00 1d 0c 00 1e</li></ul></li><li><code>第#21项</code> 0c 表示一个 <code>名+类型</code>，00 07 00 08 引用了常量池中 #7 #8 两项<ul><li>0000360 2e 6a 61 76 61 <code>0c 00 07 00 08</code> 07 00 1d 0c 00 1e</li></ul></li><li><code>第#22项</code> 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项<ul><li>0000360 2e 6a 61 76 61 0c 00 07 00 08 <code>07 00 1d</code> 0c 00 1e</li></ul></li><li><code>第#23项</code> 0c 表示一个 <code>名+类型</code>，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项<ul><li>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <code>0c 00 1e</code></li><li>0000400 <code>00 1f</code> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</li></ul></li><li><code>第#24项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，是<code>hello world</code><ul><li>0000400 00 1f <code>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</code></li></ul></li><li><code>第#25项</code> 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项<ul><li>0000420 <code>07 00 20</code> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</li></ul></li><li><code>第#26项</code> 0c 表示一个 <code>名+类型</code>，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项<ul><li>0000420 07 00 20 <code>0c 00 21 00 22</code> 01 00 1b 63 6e 2f 69 74</li></ul></li><li><code>第#27项</code> 01 表示一个 utf8 串，00 1b（27） 表示长度，是<code>cn/itcast/jvm/t5/HelloWorld</code><ul><li>0000420 07 00 20 0c 00 21 00 22 01 <code>00 1b 63 6e 2f 69 74</code></li><li>0000440 <code>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</code></li><li>0000460 <code>6f 57 6f 72 6c 64</code> 01 00 10 6a 61 76 61 2f 6c 61</li></ul></li><li><code>第#28项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>java/lang/Object</code><ul><li>0000460 6f 57 6f 72 6c 64 <code>01 00 10 6a 61 76 61 2f 6c 61</code></li><li>0000500 <code>6e 67 2f 4f 62 6a 65 63 74</code> 01 00 10 6a 61 76 61</li></ul></li><li><code>第#29项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>java/lang/System</code><ul><li>0000500 6e 67 2f 4f 62 6a 65 63 74 <code>01 00 10 6a 61 76 61</code></li><li>0000520 <code>2f 6c 61 6e 67 2f 53 79 73 74 65 6d</code> 01 00 03 6f</li></ul></li><li><code>第#30项</code> 01 表示一个 utf8 串，00 03 表示长度，是<code>out</code><ul><li>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d <code>01 00 03 6f</code></li><li>0000540 <code>75 74</code> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</li></ul></li><li><code>第#31项</code> 01 表示一个 utf8 串，00 15（21） 表示长度，是<code>Ljava/io/PrintStream;</code><ul><li>0000540 75 74 <code>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</code></li><li>0000560 <code>69 6e 74 53 74 72 65 61 6d 3b</code> 01 00 13 6a 61 76</li></ul></li><li><code>第#32项</code> 01 表示一个 utf8 串，00 13（19） 表示长度，是<code>java/io/PrintStream</code><ul><li>0000560 69 6e 74 53 74 72 65 61 6d 3b <code>01 00 13 6a 61 76</code></li><li>0000600 <code>61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</code></li></ul></li><li><code>第#33项</code> 01 表示一个 utf8 串，00 07 表示长度，是<code>println</code><ul><li>0000620 <code>01 00 07 70 72 69 6e 74 6c 6e</code> 01 00 15 28 4c 6a</li></ul></li><li><code>第#34项</code> 01 表示一个 utf8 串，00 15（21） 表示长度，是<code>(Ljava/lang/String;)V</code><ul><li>0000620 01 00 07 70 72 69 6e 74 6c 6e <code>01 00 15 28 4c 6a</code></li><li>0000640 <code>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</code></li><li>0000660 <code>29 56</code> 00 21 00 05 00 06 00 00 00 00 00 02 00 01</li></ul></li></ol><h2 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h2><ul><li>访问标识符：21表示class是一个类，公共的<ul><li>0000660 29 56 <code>00 21</code> 00 05 00 06 00 00 00 00 00 02 00 01</li></ul></li><li>当前类或接口的索引：05表示根据常量池中的#5找到本类的全限定名<ul><li>0000660 29 56 00 21 <code>00 05</code> 00 06 00 00 00 00 00 02 00 01</li></ul></li><li>当前类的超类（父类）索引：06表示根据常量池中的#6找到父类全限定名<ul><li>0000660 29 56 00 21 00 05 <code>00 06</code> 00 00 00 00 00 02 00 01</li></ul></li><li>接口数量：本类为0<ul><li>0000660 29 56 00 21 00 05 00 06 <code>00 00</code> 00 00 00 02 00 01</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Flag Name</th><th style="text-align:center">Value</th><th>Interpretation</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td>Declared public; may be accessed from outside its package.</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0010</td><td>Declared final; no subclasses allowed.</td></tr><tr><td style="text-align:center">ACC_SUPER</td><td style="text-align:center">0x0020</td><td>Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr><tr><td style="text-align:center">ACC_INTERFACE</td><td style="text-align:center">0x0200</td><td>Is an interface, not a class.</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:center">0x0400</td><td>Declared abstract; must not be instantiated.</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td style="text-align:center">ACC_ANNOTATION</td><td style="text-align:center">0x2000</td><td>Declared as an annotation type.</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:center">0x4000</td><td>Declared as an enum type.</td></tr></tbody></table></div><h2 id="Field信息"><a href="#Field信息" class="headerlink" title="Field信息"></a>Field信息</h2><ul><li>字段数量（成员变量数量），本类为0<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 <code>00 00</code> 00 02 00 01</li></ul></li></ul><h2 id="Method信息"><a href="#Method信息" class="headerlink" title="Method信息"></a>Method信息</h2><ul><li>方法数量：本类为2，构造方法和main方法<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 00 00 <code>00 02</code> 00 01</li></ul></li><li>一个方法由访问修饰符、名称、参数描述、方法苏属性数量、方法属性组成</li><li>00 01表示访问修饰符（本类中为public）<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 <code>00 01</code></li></ul></li><li>00 07表示引用了常量池中的#07项作为方法名称<ul><li>0000700 <code>00 07</code> 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>00 08表示引用了常量池中的#08项作为方法参数描述<ul><li>0000700 00 07 <code>00 08</code> 00 01 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>01表示引方法属性数量，本方法是1  <ul><li>0000700 00 07 00 08 <code>00 01</code> 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>00 09表示引用常量池#09项，发现是<code>code</code>属性<ul><li>0000700 00 07 00 08 00 01 <code>00 09</code> 00 00 00 2f 00 01 00 01</li></ul></li><li>00 00 00 2f表示此属性的长度是47<ul><li>0000700 00 07 00 08 00 01 00 09 <code>00 00 00 2f</code> 00 01 00 01</li></ul></li><li>00 01表示操作数栈最大深度<ul><li>0000700 00 07 00 08 00 01 00 09 00 00 00 2f <code>00 01</code> 00 01</li></ul></li><li>00 01表示局部变量最大槽(slot)数<ul><li>0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 <code>00 01</code></li></ul></li><li>00 00 00 05表示字节码长度，本例为5<ul><li>0000720 <code>00 00 00 05</code> 2a b7 00 01 b1 00 00 00 02 00 0a 00</li></ul></li><li>2a b7 00 01 b1 是字节码指令<ul><li>0000720 00 00 00 05 <code>2a b7 00 01 b1</code> 00 00 00 02 00 0a 00</li></ul></li><li>00 00 00 02 表示方法细节属性数量，本例为2<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 <code>00 00 00 02</code> 00 0a 00</li></ul></li><li>00 0a表示引用了常量池#10项，发现是LineNumberTable属性<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 <code>00 0a</code> 00</li><li>00 00 00 06表示此属性的总长度，本例是6<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a <code>00</code></li><li>0000740 <code>00 00 06</code> 00 01 00 00 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 01表示LineNumberTable长度<ul><li>0000740 00 00 06 <code>00 01</code> 00 00 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 00 表示字节码行号<ul><li>0000740 00 00 06 00 01 <code>00 00</code> 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 04表示Java源码行号<ul><li>0000740 00 00 06 00 01 00 00 <code>00 04</code> 00 0b 00 00 00 0c 00</li></ul></li></ul></li><li><p>00 0b表示引用了常量池#11项，发现是LocalVariableTable属性</p><ul><li>0000740 00 00 06 00 01 00 00 00 04 <code>00 0b</code> 00 00 00 0c 00</li><li>00 00 00 0c 表示此属性总长度，本例为12<ul><li>0000740 00 00 06 00 01 00 00 00 04 00 0b <code>00 00 00 0c</code> 00</li></ul></li><li>00 01 表示<code>LocalVariableTable</code>长度<ul><li>0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c <code>00</code></li><li>0000760 <code>01</code> 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<ul><li><ul><li>0000760 01 <code>00 00</code> 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li></ul></li><li>00 05 表示局部变量覆盖的范围长度<ul><li>0000760 01 00 00 <code>00 05</code> 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 0c 表示局部变量的名称，引用常量池#12项<ul><li>0000760 01 00 00 00 05 <code>00 0c</code> 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是<code>Lcn/itcast/jvm/t5/HelloWorld;</code><ul><li>0000760 01 00 00 00 05 00 0c <code>00 0d</code> 00 00 00 09 00 0e 00</li></ul></li><li>00 00 表述局部变量占有的槽位(slot)编号，本例是0<ul><li>0000760 01 00 00 00 05 00 0c 00 0d <code>00 00</code> 00 09 00 0e 00</li></ul></li></ul></li><li><p>00 09代表访问修饰符（本类中是 public static）</p></li><li>00 0e 代表引用了常量池 #14 项作为方法名称</li><li>00 0f 代表引用了常量池 #15 项作为方法参数描述</li><li>00 02 代表方法属性数量，本方法是 2</li><li>其余代表方法属性（属性1）<ul><li>00 09 表示引用了常量池 #09 项，发现是<code>Code</code>属性</li><li>00 00 00 37 表示此属性的长度是 55</li><li>00 02 表示<code>操作数栈</code>最大深度</li><li>00 01 表示<code>局部变量表</code>最大槽（slot）数</li><li>00 00 00 05 表示字节码长度，本例是 9</li><li>b2 00 02 12 03 b6 00 04 b1 是字节码指令</li><li>00 00 00 02 表示方法细节属性数量，本例是 2</li><li>00 0a 表示引用了常量池 #10 项，发现是<code>LineNumberTable</code>属性<ul><li>00 00 00 0a 表示此属性的总长度，本例是 10</li><li>00 02 表示<code>LineNumberTable</code>长度</li><li>00 00 表示<code>字节码</code>行号 00 06 表示<code>java 源码</code>行号</li><li>00 08 表示<code>字节码</code>行号 00 07 表示<code>java 源码</code>行号</li></ul></li></ul></li><li><p>00 0b 表示引用了常量池 #11 项，发现是<code>LocalVariableTable</code>属性</p><ul><li>00 00 00 0c 表示此属性的总长度，本例是 12</li><li>00 01 表示<code>LocalVariableTable</code>长度</li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li><li>00 09 表示局部变量覆盖的范围长度</li><li>00 10 表示局部变量名称，本例引用了常量池 #16 项，是<code>args</code></li><li>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是<code>[Ljava/lang/String;</code></li><li>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</li></ul></li><li><p>0000760 01 00 00 00 05 00 0c 00 0d 00 00 <code>00 09 00 0e 00</code></p></li><li>0001000 <code>0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</code></li><li>0001020 <code>09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</code></li><li>0001040 <code>00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</code></li><li><p>0001060 <code>00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</code></p></li><li><p>红色代表方法属性（属性2）</p><ul><li>00 12 表示引用了常量池 #18 项，发现是<code>MethodParameters</code>属性</li><li>00 00 00 05 表示此属性的总长度，本例是 5</li><li>01 参数数量</li><li>00 10 表示引用了常量池 #16 项，是<code>args</code></li><li>00 00 访问修饰符</li><li>0001100 <code>00 12 00 00 00 05 01 00 10 00 00</code> 00 01 00 13 00</li></ul></li></ul><h2 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h2><ul><li>00 01 表示附加属性数量</li><li>00 13 表示引用了常量池 #19 项，即<code>SourceFile</code></li><li>00 00 00 02 表示此属性的长度</li><li>00 14 表示引用了常量池 #20 项，即<code>HelloWorld.java</code><ul><li>0001100 00 12 00 00 00 05 01 00 10 00 00 <code>00 01 00 13 00</code></li><li>0001120 <code>00 00 02 00 14</code>分</li></ul></li></ul><h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul><li>在上一小节，有两个字节码指令，我们没有细说，那现在就来具体看看</li><li>一个是<code>public cn.itcast.jvm.t5.HelloWorld();</code>构造方法的字节码指令  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a b7 00 01 b1</span><br></pre></td></tr></table></figure><ol><li>2a =&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</li><li>b7 =&gt; invokespecial 预备调用构造方法，哪个方法呢？</li><li>00 01 引用常量池中 #1 项，即<code>Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></li><li>b1 表示返回</li></ol></li><li>另一个是 <code>public static void main(java.lang.String[]);</code> 主方法的字节码指令  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 00 02 12 03 b6 00 04 b1</span><br></pre></td></tr></table></figure><ol><li>b2 =&gt; getstatic 用来加载静态变量，哪个静态变量呢？</li><li>00 02 引用常量池中 #2 项，即<code>Field java/lang/System.out:Ljava/io/PrintStream;</code></li><li>12 =&gt; ldc 加载参数，哪个参数呢？</li><li>03 引用常量池中 #3 项，即 <code>String hello world</code></li><li>b6 =&gt; invokevirtual 预备调用成员方法，哪个方法呢？</li><li>00 04 引用常量池中 #4 项，即<code>Method java/io/PrintStream.println:(Ljava/lang/String;)V</code></li><li>b1 表示返回</li></ol></li><li>详情请参考官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></li></ul><h2 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h2><ul><li>自己分析类文件结构太麻烦了，Oracle提供了javap工具来反编译class文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-4-5; size 551 bytes</span><br><span class="line">  MD5 checksum 1389d939c65ba536eb81d1a5c61d99be</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;              </span><br><span class="line">public class com.demo.HelloWorld               </span><br><span class="line">  minor version: 0                             </span><br><span class="line">  major version: 52                            </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #23            // hello world</span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld</span><br><span class="line">   #6 = Class              #27            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               hello world</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h2><ol><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 字节码指令 和 操作数栈、常量池的关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v Demo_20.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/Demo_20.class</span><br><span class="line">  Last modified 2023-4-7; size 601 bytes       </span><br><span class="line">  MD5 checksum 0f9e41fb2a7334a69c89d2661540f4f1</span><br><span class="line">  Compiled from &quot;Demo_20.java&quot;                 </span><br><span class="line">public class com.demo.Demo_20                  </span><br><span class="line">  minor version: 0                             </span><br><span class="line">  major version: 52                            </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                 </span><br><span class="line">Constant pool:                                 </span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V             </span><br><span class="line">   #2 = Class              #26            // java/lang/Short                           </span><br><span class="line">   #3 = Integer            32768                                                       </span><br><span class="line">   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #31            // com/demo/Demo_20</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lcom/demo/Demo_20;</span><br><span class="line">  #15 = Utf8               main</span><br><span class="line">  #16 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #17 = Utf8               args</span><br><span class="line">  #18 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               a</span><br><span class="line">  #20 = Utf8               I</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               c</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               Demo_20.java</span><br><span class="line">  #25 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               java/lang/Short</span><br><span class="line">  #27 = Class              #33            // java/lang/System</span><br><span class="line">  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #29 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #30 = NameAndType        #37:#38        // println:(I)V</span><br><span class="line">  #31 = Utf8               com/demo/Demo_20</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.Demo_20();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/Demo_20;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: ldc           #3                  // int 32768</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        13: iload_3</span><br><span class="line">        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        17: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 3</span><br><span class="line">        line 10: 6</span><br><span class="line">        line 11: 10</span><br><span class="line">        line 12: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            3      15     1     a   I</span><br><span class="line">            6      12     2     b   I</span><br><span class="line">           10       8     3     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo_20.java&quot;</span><br></pre></td></tr></table></figure></li><li><p>常量池载入运行时常量池<br><img src="https://s1.ax1x.com/2023/04/07/ppTr326.png" alt=""></p></li><li><p>方法字节码载入方法区<br><img src="https://s1.ax1x.com/2023/04/07/ppTrdIA.png" alt=""></p></li><li><p>main线程开始运行、分配栈帧内存</p><ul><li>stack=2, locals=4<ul><li>操作数栈的深度为2，也就是说，在执行该方法时，最多可以将两个值压入栈中进行操作。</li><li>包含四个局部变量<br><img src="https://s1.ax1x.com/2023/04/07/ppTrDRP.png" alt=""></li></ul></li></ul></li><li><p>执行引擎开始执行字节码</p><ul><li>bipush 10<ul><li>将一个byte压入操作数栈（其长度会补齐为4个字节），类似的指令还有</li><li>sipush：将一个short压入操作数栈（其长度会补齐为4个字节）</li><li>ldc：将一个int压入操作数栈</li><li>ldc2_w：将一个long压入操作数栈（分两次压入，因为long占8个字节）<br><img src="https://s1.ax1x.com/2023/04/07/ppTr2ZQ.png" alt=""></li></ul></li><li>istore_1<ul><li>将操作数栈顶数据弹出，存入局部变量表slot 1<br><img src="https://s1.ax1x.com/2023/04/07/ppT6Rde.png" alt=""></li></ul></li><li>ldc #3<ul><li>从常量池加载#3数据到操作数栈<br><img src="https://s1.ax1x.com/2023/04/07/ppT6OoQ.png" alt=""></li></ul></li><li>istore_2<ul><li>将操作数栈顶数据弹出，存入局部变量表slot 2<br><img src="https://s1.ax1x.com/2023/04/07/ppTc9yV.png" alt=""></li></ul></li><li>iload_1<ul><li>将局部变量表slot 1的值加载到操作数栈中</li></ul></li><li>iload_2<ul><li>将局部变量表slot 2的值加载到操作数栈中<br><img src="https://s1.ax1x.com/2023/04/07/ppTcsYj.png" alt=""></li></ul></li><li>iadd<ul><li>从操作数栈顶部弹出两个int类型的数值，将这两个数值相加，并将其结果压入操作数栈顶部；<br><img src="https://s1.ax1x.com/2023/04/07/ppTcTh9.png" alt=""></li></ul></li><li>istore_3<ul><li>将操作数栈顶部数据弹出，存入局部变量表slot 3<br><img src="https://s1.ax1x.com/2023/04/07/ppTcXnK.png" alt=""></li></ul></li><li>getstatic #4<ul><li>从常量池加载#4静态字段到操作数栈<br><img src="https://s1.ax1x.com/2023/04/07/ppTgEB8.png" alt=""></li></ul></li><li>iload_3<ul><li>将局部变量表slot 3的值加载到操作数栈中<br><img src="https://s1.ax1x.com/2023/04/07/ppTgnhj.png" alt=""></li></ul></li><li>invokevirtual #5<ul><li>找到常量池#5项</li><li>定位到方法区 </li><li>生成新的栈帧（分配locals、stack等）</li><li>传递参数、执行新栈帧中的字节码<br><img src="https://s1.ax1x.com/2023/04/07/ppTgM3n.png" alt=""></li><li>执行完毕，弹出栈帧</li><li>清除main操作数栈内容<br><img src="https://s1.ax1x.com/2023/04/07/ppTglj0.png" alt=""></li></ul></li><li>return<ul><li>完成main方法调用，弹出main栈帧</li><li>程序结束</li></ul></li></ul></li></ol><h2 id="分析-i"><a href="#分析-i" class="headerlink" title="分析 i++"></a>分析 i++</h2><ul><li>目的：从字节码角度分析a++相关题目</li><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v Demo_21.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/Demo_21.class</span><br><span class="line">  Last modified 2023-4-7; size 576 bytes</span><br><span class="line">  MD5 checksum 5bc962752b10ca4b57350ca9814ec5b0</span><br><span class="line">  Compiled from &quot;Demo_21.java&quot;</span><br><span class="line">public class com.demo.Demo_21</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#22         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #25.#26        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #27            // com/demo/Demo_21</span><br><span class="line">   #5 = Class              #28            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               LocalVariableTable</span><br><span class="line">  #11 = Utf8               this</span><br><span class="line">  #12 = Utf8               Lcom/demo/Demo_21;</span><br><span class="line">  #13 = Utf8               main</span><br><span class="line">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #15 = Utf8               args</span><br><span class="line">  #16 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #17 = Utf8               a</span><br><span class="line">  #18 = Utf8               I</span><br><span class="line">  #19 = Utf8               b</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               Demo_21.java</span><br><span class="line">  #22 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #23 = Class              #29            // java/lang/System</span><br><span class="line">  #24 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;</span><br><span class="line">  #25 = Class              #32            // java/io/PrintStream</span><br><span class="line">  #26 = NameAndType        #33:#34        // println:(I)V</span><br><span class="line">  #27 = Utf8               com/demo/Demo_21</span><br><span class="line">  #28 = Utf8               java/lang/Object</span><br><span class="line">  #29 = Utf8               java/lang/System</span><br><span class="line">  #30 = Utf8               out</span><br><span class="line">  #31 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #32 = Utf8               java/io/PrintStream</span><br><span class="line">  #33 = Utf8               println</span><br><span class="line">  #34 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.Demo_21();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/Demo_21;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: iload_1</span><br><span class="line">         4: iinc          1, 1</span><br><span class="line">         7: iinc          1, 1</span><br><span class="line">        10: iload_1</span><br><span class="line">        11: iadd</span><br><span class="line">        12: iload_1</span><br><span class="line">        13: iinc          1, -1</span><br><span class="line">        16: iadd</span><br><span class="line">        17: istore_2</span><br><span class="line">        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        21: iload_1</span><br><span class="line">        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        25: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        28: iload_2</span><br><span class="line">        29: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        32: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 3</span><br><span class="line">        line 7: 18</span><br><span class="line">        line 8: 25</span><br><span class="line">        line 9: 32</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      33     0  args   [Ljava/lang/String;</span><br><span class="line">            3      30     1     a   I</span><br><span class="line">           18      15     2     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo_21.java&quot;</span><br></pre></td></tr></table></figure></li><li>提示：<code>iinc</code>指令是直接在局部变量slot上进行运算，下面逐行分析字节码指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10        // 将一个byte压入操作数栈，此时就是将10压入操作数栈</span><br><span class="line"> 2: istore_1                // 将操作数栈顶部数据弹出，存入局部变量表 slot 1</span><br><span class="line"> 3: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将10加载到栈中</span><br><span class="line"> 4: iinc          1, 1      // 在当前局部变量上进行运算，自增1，此时局部变量 a = 11   至此 a++ 执行完毕</span><br><span class="line"> 7: iinc          1, 1      // 在当前局部变量上进行运算，自增1，此时局部变量 a = 12</span><br><span class="line">10: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将12加载到栈中</span><br><span class="line">11: iadd                    // 将栈内两个元素相加，10 + 12 = 22，将结果22加载到栈中</span><br><span class="line">12: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将12加载到栈中</span><br><span class="line">13: iinc          1, -1     // 在当前局部变量上进行运算，自减1，此时局部变量 a = 11</span><br><span class="line">16: iadd                    // 将栈内两个元素相加，22 + 12 = 34，结果为34</span><br><span class="line">17: istore_2                // 将操作数栈顶部数据弹出，存入局部变量表slot 2</span><br><span class="line">18: getstatic     #2        // 下面就不分析了，就是输出a和b的值</span><br><span class="line">21: iload_1</span><br><span class="line">22: invokevirtual #3                  </span><br><span class="line">25: getstatic     #2                  </span><br><span class="line">28: iload_2</span><br><span class="line">29: invokevirtual #3                  </span><br><span class="line">32: return</span><br></pre></td></tr></table></figure></li><li>那么最终的结果<code>a = 11</code>，<code>b = 34</code></li><li>从字节码指令中，我们可以看出，<code>a++</code>和<code>++a</code>的区别为<ul><li><code>a++</code>是先执行<code>iload</code>，再执行<code>iinc</code></li><li><code>++a</code>是先执行<code>iinc</code>，再执行<code>iload</code></li></ul></li></ul><h2 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">助记符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0x99</td><td style="text-align:center">ifeq</td><td style="text-align:center">判断是否 == 0</td></tr><tr><td style="text-align:center">0x9a</td><td style="text-align:center">ifne</td><td style="text-align:center">判断是否 != 0</td></tr><tr><td style="text-align:center">0x9b</td><td style="text-align:center">iflt</td><td style="text-align:center">判断是否 &lt; 0</td></tr><tr><td style="text-align:center">0x9c</td><td style="text-align:center">ifge</td><td style="text-align:center">判断是否 &gt;= 0</td></tr><tr><td style="text-align:center">0x9d</td><td style="text-align:center">ifgt</td><td style="text-align:center">判断是否 &gt; 0</td></tr><tr><td style="text-align:center">0x9e</td><td style="text-align:center">ifle</td><td style="text-align:center">判断是否 &lt;= 0</td></tr><tr><td style="text-align:center">0x9f</td><td style="text-align:center">if_icmpeq</td><td style="text-align:center">两个int是否 ==</td></tr><tr><td style="text-align:center">0xa0</td><td style="text-align:center">if_icmpne</td><td style="text-align:center">两个int是否 !=</td></tr><tr><td style="text-align:center">0xa1</td><td style="text-align:center">if_icmplt</td><td style="text-align:center">两个int是否 &lt;</td></tr><tr><td style="text-align:center">0xa2</td><td style="text-align:center">if_icmpge</td><td style="text-align:center">两个int是否 &gt;=</td></tr><tr><td style="text-align:center">0xa3</td><td style="text-align:center">if_icmpgt</td><td style="text-align:center">两个int是否 &gt;</td></tr><tr><td style="text-align:center">0xa4</td><td style="text-align:center">if_icmple</td><td style="text-align:center">两个int是否 &lt;=</td></tr><tr><td style="text-align:center">0xa5</td><td style="text-align:center">if_acmpeq</td><td style="text-align:center">两个引用是否 ==</td></tr><tr><td style="text-align:center">0xa6</td><td style="text-align:center">if_acmpne</td><td style="text-align:center">两个引用是否 !=</td></tr><tr><td style="text-align:center">0xc6</td><td style="text-align:center">ifnull</td><td style="text-align:center">判断是否 == null</td></tr><tr><td style="text-align:center">0xc7</td><td style="text-align:center">ifnonnull</td><td style="text-align:center">判断是否 != null</td></tr></tbody></table></div><ul><li><p>原始Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 0: iconst_0             // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iload_1              // 将局部变量表slot 1的值压入操作数栈</span><br><span class="line"> 3: ifne           12    // 判断不等于0，成立跳转至12行，不成立则执行下一行</span><br><span class="line"> 6: bipush         10    // 将10压入操作数栈</span><br><span class="line"> 8: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 9: goto           15    // 跳转至第15行</span><br><span class="line">12: bipush        20     // 将20压入操作数栈，对应 a = 20</span><br><span class="line">14: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure></li></ul><h2 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h2><ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 0: iconst_0                // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1                // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iload_1                 // 将局部变量表slot 1的值压入操作数栈</span><br><span class="line"> 3: bipush        10        // 将10压入操作数栈</span><br><span class="line"> 5: if_icmpge     14        // 判断 i &gt;= 10 ，成立则跳转到14行，不成立则执行下一行</span><br><span class="line"> 8: iinc          1, 1      // i自增</span><br><span class="line">11: goto          2         // 跳转到第2行</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure></li><li>再比如<code>do while</code>循环<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0: iconst_0                // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1                // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iinc          1, 1      // i自增</span><br><span class="line"> 5: iload_1                 // 将局部变量表slot 1加载到操作数栈</span><br><span class="line"> 6: bipush        10        // 将10加载到操作数栈</span><br><span class="line"> 8: if_icmplt     2         // 判断 i &lt; 10，成立则跳转到第2行，不成立执行下一行</span><br><span class="line">11: return</span><br></pre></td></tr></table></figure></li><li>最后再来看看for循环<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 0: iconst_0</span><br><span class="line"> 1: istore_1</span><br><span class="line"> 2: iload_1</span><br><span class="line"> 3: bipush        10</span><br><span class="line"> 5: if_icmpge     14</span><br><span class="line"> 8: iinc          1, 1</span><br><span class="line">11: goto          2</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure></li></ul><div class="note info no-icon flat"><p>注意到while和for的字节码，它们是一模一样的，这就是所谓的<code>殊途同归</code>吧</p></div><h2 id="判断结果"><a href="#判断结果" class="headerlink" title="判断结果"></a>判断结果</h2><ul><li>从字节码的角度来分析下面程序的运行结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            x = x++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最终x的结果是0<ul><li>执行<code>x++</code>时，先执行<code>iload_x</code>，将0加载到操作数栈中</li><li>然后执行iinc，将局部变量表中的x自增，此时局部变量表中的<code>x = 1</code></li><li>此时又执行了一个赋值操作，<code>istore_x</code>，将操作数栈中的0，重新赋给了局部变量表中的x，导致x为0</li></ul></li><li>下面是对应的字节码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10: iload_2</span><br><span class="line">11: iinc          2, 1</span><br><span class="line">14: istore_2</span><br></pre></td></tr></table></figure></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ol><li><code>&lt;cinit&gt;()V</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_27</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: putstatic     #2                  // Field i:I</span><br><span class="line"> 5: bipush        20</span><br><span class="line"> 7: putstatic     #2                  // Field i:I</span><br><span class="line">10: bipush        30</span><br><span class="line">12: putstatic     #2                  // Field i:I</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure></li><li>编译器会按照从上至下的顺序，收集所有的static静态代码块和静态成员赋值的代码，合并成一个特殊的方法<code>&lt;cinit&gt;()V</code></li><li><code>&lt;cinit&gt;()V</code>方法会在类加载的初始化阶段被调用</li></ul></li><li><code>&lt;init&gt;()V</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_28</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo_28</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo_28 demo = <span class="keyword">new</span> Demo_28(<span class="string">&quot;s3&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(demo.a);</span><br><span class="line">        System.out.println(demo.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 0: aload_0</span><br><span class="line"> 1: invokespecial #1      // super.&lt;init&gt;()V</span><br><span class="line"> 4: aload_0</span><br><span class="line"> 5: ldc #2                // &lt;- &quot;s1&quot;</span><br><span class="line"> 7: putfield #3           // -&gt; this.a</span><br><span class="line">10: aload_0</span><br><span class="line">11: bipush 20             // &lt;- 20</span><br><span class="line">13: putfield #4           // -&gt; this.b</span><br><span class="line">16: aload_0</span><br><span class="line">17: bipush 10             // &lt;- 10</span><br><span class="line">19: putfield #4           // -&gt; this.b</span><br><span class="line">22: aload_0</span><br><span class="line">23: ldc #5                // &lt;- &quot;s2&quot;</span><br><span class="line">25: putfield #3           // -&gt; this.a</span><br><span class="line">28: aload_0               // ------------------------------</span><br><span class="line">29: aload_1               // &lt;- slot 1(a) &quot;s3&quot;            |</span><br><span class="line">30: putfield #3           // -&gt; this.a                    |</span><br><span class="line">33: aload_0                                               |</span><br><span class="line">34: iload_2               // &lt;- slot 2(b) 30              |</span><br><span class="line">35: putfield #4           // -&gt; this.b --------------------</span><br><span class="line">38: return</span><br></pre></td></tr></table></figure></li><li>编译器会按照从上至下的顺序，收集所有代码块和所有成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是会在最后</li></ul></li></ol><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><ul><li>看一下几种不同方法调用对应的字节码指令，私有方法，final方法，公共方法，静态方法<ul><li>其中静态方法包括对象调静态方法和类直接调静态方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_29</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo_29</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo_29 demo = <span class="keyword">new</span> Demo_29();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        Demo_29.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0: new           #2                  // class com/demo/Demo_29</span><br><span class="line"> 3: dup</span><br><span class="line"> 4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> 7: astore_1</span><br><span class="line"> 8: aload_1</span><br><span class="line"> 9: invokespecial #4                  // Method test1:()V</span><br><span class="line">12: aload_1</span><br><span class="line">13: invokespecial #5                  // Method test2:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">20: aload_1</span><br><span class="line">21: pop</span><br><span class="line">22: invokestatic  #7                  // Method test4:()V</span><br><span class="line">25: invokestatic  #7                  // Method test4:()V</span><br><span class="line">28: return</span><br></pre></td></tr></table></figure></li><li>new #2是创建Demo_29对象，给对象分配内存，执行成功会将<code>对象引用</code>压入操作数栈</li><li>dup是赋值操作数栈顶的内容，本例为<code>对象引用</code>。那为什么需要两份引用呢？<ul><li>一个是要配合<code>invokespecial</code>调用该对象的构造方法<code>&quot;&lt;init&gt;:()V&quot;</code>，会消耗掉栈顶一个引用</li><li>另一个要配合<code>astore_1</code>赋值给局部变量</li></ul></li><li>final方法、私有方法、构造方法，都是由invokespecial指令来调用，属于静态绑定</li><li>普通成员方法是由invokevirtual调用，属于动态绑定，即支持多态</li><li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要<code>对象引用</code></li><li>比较有意思的是，执行demo.test4()时，是通过<code>对象引用</code>调用的静态方法，可以看到在调用前执行了pop指令，把对象引用从操作数栈弹掉了，因为静态方法不需要对象引用来掉，通过这种方式，反而会增加两步无用的字节码指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20: aload_1</span><br><span class="line">21: pop</span><br><span class="line">22: invokestatic  #7                  // Method test4:()V</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><ul><li>原始Java代码<ul><li>定义了一个抽象类Animal，还有其两个子类Cat和Dog<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加VM参数：-XX:-UseCompressedOops -XX:-UseCompressedClassPointers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_30</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        System.out.println(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Cat());</span><br><span class="line">        test(<span class="keyword">new</span> Dog());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是&quot;</span> + <span class="keyword">this</span>.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;想啃大骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;想吃小鱼干&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol><li>运行代码<ul><li>会停在System.in.read()方法上（当然你也可以直接打断点），运行jps命令获取进程id</li></ul></li><li>运行HSDB工具<ul><li>进入JDK安装目录，执行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure></li><li>进入图形界面attach进程id</li></ul></li><li>查找某个对象<ul><li>打开Tools -&gt; Find Object By Query，输入命令，点击Execute执行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d from com.demo.Dog d</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/04/08/pp7s72q.png" alt=""></li></ul></li><li>查看对象内存结构<ul><li>点击超链接可以看到对象的内存结构，此对象没有任何属性，因此只有对象头的16字节，前8字节是MarkWord，后8字节就是对象的Class指针，但现在看不到它的实际地址</li></ul></li><li>查看对象Class的内存地址<ul><li>可以通过Windows -&gt; Console进入命令行模式，执行如下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem 0x000001f1676e77c8 2</span><br></pre></td></tr></table></figure></li><li>mem指令有两个参数，参数1是对象地址，参数2是查看2行（即16字节）</li><li>结果中第二行<code>0x000001f1f48841a0</code>即为Class的内存地址<br><img src="https://s1.ax1x.com/2023/04/08/pp7yJoQ.png" alt=""></li></ul></li><li>查看类的vtable<ul><li>方法1：<kbd>ALT</kbd> + <kbd>R</kbd>进入Inspector工具输入刚才的Class内存地址</li><li>方法2：或者Tools -&gt; Class Browser 输入Dog查找，可以得到相同的结果<br><img src="https://s1.ax1x.com/2023/04/08/pp7ycFJ.png" alt=""></li><li>无论通过哪种方法，都可以找到Dog Class的vtable长度为6，意思就是Dog类会有6个虚方法（多台相关的，final、static不会列入）</li><li>那么这6个虚方法都是谁呢？从Class的起始地址开始算，偏移<code>0x1b8</code>就是vtable的其实地址，进行计算得到<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x000001f1f48841a0</span><br><span class="line">               1b8 +</span><br><span class="line">--------------------</span><br><span class="line">0x000001f1f4884358</span><br></pre></td></tr></table></figure></li><li>通过Windows -&gt; Console进入命令行模式，执行如下命令，就得到了6个虚方法的入口地址<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mem 0x000001f1f4884358 6</span><br><span class="line">0x000001f1f4884358: 0x000001f1f4481b10 </span><br><span class="line">0x000001f1f4884360: 0x000001f1f44815e8 </span><br><span class="line">0x000001f1f4884368: 0x000001f1f4883750 </span><br><span class="line">0x000001f1f4884370: 0x000001f1f4481540 </span><br><span class="line">0x000001f1f4884378: 0x000001f1f4481678 </span><br><span class="line">0x000001f1f4884380: 0x000001f1f4884148 </span><br></pre></td></tr></table></figure></li></ul></li><li>验证方法地址<ul><li>通过Tools -&gt; Class Browser 查看每个类的方法定义，比较可知<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x000001f1f4481b10 -&gt; Object -- protected void finalize() @0x000001f1f4481b10;</span><br><span class="line">0x000001f1f44815e8 -&gt; Object -- public boolean equals(java.lang.Object) @0x000001f1f44815e8;</span><br><span class="line">0x000001f1f4883750 -&gt; Animal -- public java.lang.String toString() @0x000001f1f4883750;</span><br><span class="line">0x000001f1f4481540 -&gt; Object -- public native int hashCode() @0x000001f1f4481540;</span><br><span class="line">0x000001f1f4481678 -&gt; Object -- protected native java.lang.Object clone() @0x000001f1f4481678;</span><br><span class="line">0x000001f1f4884148 -&gt; Dog -- public void eat() @0x000001f1f4884148;</span><br></pre></td></tr></table></figure></li><li>对号入座，发现<ul><li>eat()方法是Dog类自己的</li><li>toString()方法是继承String类的</li><li>finalize() ，equals()，hashCode()，clone() 都是继承 Object 类的</li></ul></li></ul></li><li>小结<ul><li>当执行invokevirtual指令时<ol><li>先通过栈帧中的对象引用找到对象</li><li>分析对象头，找到对象的实际Class</li><li>Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成号了</li><li>查表得到方法的具体地址</li><li>执行方法的字节码 </li></ol></li></ul></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li>try-catch<ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_31</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">    <span class="number">0</span>: iconst_0</span><br><span class="line">    <span class="number">1</span>: istore_1</span><br><span class="line">    <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">    <span class="number">4</span>: istore_1</span><br><span class="line">    <span class="number">5</span>: goto          <span class="number">12</span></span><br><span class="line">    <span class="number">8</span>: astore_2</span><br><span class="line">    <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">    <span class="number">11</span>: istore_1</span><br><span class="line">    <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">    from    to  target type</span><br><span class="line">        <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br></pre></td></tr></table></figure></li><li>可以看到多出来一个<code>Exception table</code>的结构，<code>[from to)</code>是左闭右开的检测范围，一旦这个范围内的字节码执行出现异常，则通过<code>type</code>匹配异常类型，如果一致，进入<code>target</code>所指示的行号，该例中是第8行，也就是执行catch代码块</li><li>第8行的字节码指令<code>astore_2</code>是将异常对象存入局部变量表的<code>slot 2</code>的位置</li></ul></li><li>多个catch块的情况<ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_32</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">40</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">4</span>: istore_1</span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">26</span></span><br><span class="line">       <span class="number">8</span>: astore_2</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">      <span class="number">11</span>: istore_1</span><br><span class="line">      <span class="number">12</span>: goto          <span class="number">26</span></span><br><span class="line">      <span class="number">15</span>: astore_2</span><br><span class="line">      <span class="number">16</span>: bipush        <span class="number">30</span></span><br><span class="line">      <span class="number">18</span>: istore_1</span><br><span class="line">      <span class="number">19</span>: goto          <span class="number">26</span></span><br><span class="line">      <span class="number">22</span>: astore_2</span><br><span class="line">      <span class="number">23</span>: bipush        <span class="number">40</span></span><br><span class="line">      <span class="number">25</span>: istore_1</span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/ArithmeticException</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/NullPointerException</span><br><span class="line">           <span class="number">2</span>     <span class="number">5</span>    <span class="number">22</span>   Class java/lang/Exception</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">2</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">9</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">15</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">16</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">19</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">22</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">23</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">26</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/ArithmeticException;</span><br><span class="line">         <span class="number">16</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/NullPointerException;</span><br><span class="line">         <span class="number">23</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">          <span class="number">0</span>      <span class="number">27</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">          <span class="number">2</span>      <span class="number">25</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure></li><li>因为异常出现时，只能进入一个<code>Exception table</code>的分支，所以局部变量表<code>slot 2</code>位置被共用</li><li><code>[from, to)</code>的检测范围都相同，只不过<code>target</code>的行号不同，对应三个catch块</li></ul></li><li>multi-catch的情况<ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodError | IllegalAccessError | Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">13</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: aload_2</span><br><span class="line">        <span class="number">10</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Throwable.printStackTrace:()V</span></span><br><span class="line">        <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/NoSuchMethodError</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/IllegalAccessError</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">13</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">9</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Throwable;</span><br><span class="line">            <span class="number">0</span>      <span class="number">14</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">12</span>     <span class="number">1</span>     i   I</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><code>[from, to)</code>的检测范围都相同，<code>target</code>的行号也相同</li></ul></li><li>finally<ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_34</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">        stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">            <span class="number">0</span>: iconst_0</span><br><span class="line">            <span class="number">1</span>: istore_1             <span class="comment">// 0 -&gt; i</span></span><br><span class="line">            <span class="number">2</span>: bipush       <span class="number">10</span>      <span class="comment">// try ---------------------------</span></span><br><span class="line">            <span class="number">4</span>: istore_1             <span class="comment">// 10 -&gt; i                       |</span></span><br><span class="line">            <span class="number">5</span>: bipush       <span class="number">30</span>      <span class="comment">//                               |</span></span><br><span class="line">            <span class="number">7</span>: istore_1             <span class="comment">// 30 -&gt; i                       |</span></span><br><span class="line">            <span class="number">8</span>: goto         <span class="number">27</span>      <span class="comment">// return ------------------------</span></span><br><span class="line">            <span class="number">11</span>: astore_2            <span class="comment">// catch Exception -&gt; e ----------</span></span><br><span class="line">            <span class="number">12</span>: bipush <span class="number">20</span>           <span class="comment">//                               |</span></span><br><span class="line">            <span class="number">14</span>: istore_1            <span class="comment">// 20 -&gt; i                       |</span></span><br><span class="line">            <span class="number">15</span>: bipush      <span class="number">30</span>      <span class="comment">//                               |</span></span><br><span class="line">            <span class="number">17</span>: istore_1            <span class="comment">// 30 -&gt; i                       |</span></span><br><span class="line">            <span class="number">18</span>: goto        <span class="number">27</span>      <span class="comment">// return ------------------------</span></span><br><span class="line">            <span class="number">21</span>: astore_3            <span class="comment">// catch any -&gt; slot 3 -----------</span></span><br><span class="line">            <span class="number">22</span>: bipush      <span class="number">30</span>      <span class="comment">//                               |</span></span><br><span class="line">            <span class="number">24</span>: istore_1            <span class="comment">// 30 -&gt; i                       |</span></span><br><span class="line">            <span class="number">25</span>: aload_3             <span class="comment">// &lt;- slot 3                     |</span></span><br><span class="line">            <span class="number">26</span>: athrow              <span class="comment">// throw -------------------------</span></span><br><span class="line">            <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">        Exception table:</span><br><span class="line">            from to target type</span><br><span class="line">            <span class="number">2</span> <span class="number">5</span> <span class="number">11</span> java/lang/Exception</span><br><span class="line">            <span class="number">2</span> <span class="number">5</span> <span class="number">21</span> any</span><br><span class="line">            <span class="number">11</span> <span class="number">15</span> <span class="number">21</span> any</span><br><span class="line">        LineNumberTable: ...</span><br><span class="line">        LocalVariableTable:</span><br><span class="line">            Start Length Slot Name Signature</span><br><span class="line">            <span class="number">0</span> <span class="number">28</span> <span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span> <span class="number">26</span> <span class="number">1</span> i I</span><br><span class="line">            <span class="number">12</span> <span class="number">3</span> <span class="number">2</span> e Ljava/lang/Exception;</span><br></pre></td></tr></table></figure></li><li>可以看到有3个<code>[from, to)</code><ul><li>第一个<code>[2, 5)</code>是检测try块中是否有Exception异常，如果有则跳转至11行执行catch块</li><li>第二个<code>[2, 5)</code>是检测try块中是否有其他异常（非Exception异常），如果有则跳转至21行执行finally块</li><li>第三个<code>[11, 15)</code>是检测catch快中是否有其他异常，如果有则跳转至21行执行finally块</li></ul></li><li>结论：finally中的代码被复制了三分，分别放进try流程、catch流程以及catch剩余的异常类型流程</li></ul></li></ol><h2 id="关于finally的面试题"><a href="#关于finally的面试题" class="headerlink" title="关于finally的面试题"></a>关于finally的面试题</h2><ol><li>finally中出现了return<ul><li>原始Java代码，先自己试着想一下最终的结果是啥：<psw>20</psw><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<div class="note warning no-icon flat"><ul><li>注意这里要加上-p参数，才能显示私有方法的信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p Demo_35.class</span><br></pre></td></tr></table></figure></li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span>      <span class="comment">// 将 int 10 压入栈顶</span></span><br><span class="line">       <span class="number">2</span>: istore_0              <span class="comment">// 将栈顶的 int 10 存入到局部变量 slot 0 中，并从栈顶弹出</span></span><br><span class="line">       <span class="number">3</span>: bipush        <span class="number">20</span>      <span class="comment">// 将 int 20 压入栈顶</span></span><br><span class="line">       <span class="number">5</span>: ireturn               <span class="comment">// 返回栈顶的 int 20</span></span><br><span class="line">       <span class="number">6</span>: astore_1              <span class="comment">// 捕获任何异常</span></span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">20</span>      <span class="comment">// 将 int 20 压入栈顶</span></span><br><span class="line">       <span class="number">9</span>: ireturn</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">3</span>     <span class="number">6</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">3</span></span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">      frame_type = <span class="number">70</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">        stack = [ <span class="class"><span class="keyword">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Throwable</span> ]</span></span><br></pre></td></tr></table></figure></li><li>由于finally中的ireturn被插入了所有可能的流程，因此返回结果肯定以finally为准</li><li>至于字节码中的第二行，目前看似没啥用，先留个伏笔，等下个例子来讲解</li><li>之前的finally例子中，最后都会有一个athrow，这告诉我们，如果在finally中出现了return，那么就会吞掉异常，具体来看下面这个例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_36</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行上面的代码，不会出现任何异常，输出20，<code>i = 1 / 0</code>那个异常被吞掉了</li></ul></li><li>finally对返回值的影响<ul><li>原始Java代码，还是先试着想想结果会输出什么：<psw>10</psw><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_37</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span>      <span class="comment">// 将 10 放入栈顶</span></span><br><span class="line">       <span class="number">2</span>: istore_0              <span class="comment">// 10 -&gt; i</span></span><br><span class="line">       <span class="number">3</span>: iload_0               <span class="comment">// &lt;- i(10)</span></span><br><span class="line">       <span class="number">4</span>: istore_1              <span class="comment">// 将 i(10) 暂存至 slot 1，目的是为了固定返回值</span></span><br><span class="line">       <span class="number">5</span>: bipush        <span class="number">20</span>      <span class="comment">// 将 20 放入栈顶</span></span><br><span class="line">       <span class="number">7</span>: istore_0              <span class="comment">// 20 -&gt; i</span></span><br><span class="line">       <span class="number">8</span>: iload_1               <span class="comment">// 载入 slot 1 暂存的值 (10)</span></span><br><span class="line">       <span class="number">9</span>: ireturn               <span class="comment">// 返回栈顶的值</span></span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">      <span class="number">13</span>: istore_0</span><br><span class="line">      <span class="number">14</span>: aload_2</span><br><span class="line">      <span class="number">15</span>: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">3</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">      line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">10</span></span><br><span class="line">        locals = [ <span class="keyword">int</span> ]</span><br><span class="line">        stack = [ <span class="class"><span class="keyword">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Throwable</span> ]</span></span><br></pre></td></tr></table></figure></li><li>虽然在 finally 块中将 i 的值修改为 20，但是这不会影响 return 语句的返回值，因为在返回之前，i 的值已经被暂存到了 slot 1 中。在 finally 块中对 i 进行的修改不会影响 slot 1 中的值，因此 ireturn 指令返回的是 slot 1 中的值，即 10。</li></ul></li></ol><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul><li>synchronized代码块是对一个对象进行加锁操作，那么它是如何保障当synchronized代码块中出现了异常，还能正确的执行解锁操作呢？下面就从字节码的角度来分析一下底层原理<ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_38</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1                          <span class="comment">// lock引用 -&gt; lock</span></span><br><span class="line">       <span class="number">8</span>: aload_1                           <span class="comment">// &lt;- lock （synchronized开始）</span></span><br><span class="line">       <span class="number">9</span>: dup</span><br><span class="line">      <span class="number">10</span>: astore_2                          <span class="comment">// lock引用 -&gt; slot 2</span></span><br><span class="line">      <span class="number">11</span>: monitorenter                      <span class="comment">// monitorenter(lock引用)</span></span><br><span class="line">      <span class="number">12</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">15</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String ok</span></span><br><span class="line">      <span class="number">17</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">20</span>: aload_2                           <span class="comment">// &lt;- slot 2(lock引用)</span></span><br><span class="line">      <span class="number">21</span>: monitorexit                       <span class="comment">// monitorexit(lock引用)</span></span><br><span class="line">      <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">      <span class="number">25</span>: astore_3                          <span class="comment">// any -&gt; slot 3</span></span><br><span class="line">      <span class="number">26</span>: aload_2                           <span class="comment">// &lt;- slot 2(lock引用)</span></span><br><span class="line">      <span class="number">27</span>: monitorexit                       <span class="comment">// monitorexit(lock引用)</span></span><br><span class="line">      <span class="number">28</span>: aload_3</span><br><span class="line">      <span class="number">29</span>: athrow</span><br><span class="line">      <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">          <span class="number">12</span>    <span class="number">22</span>    <span class="number">25</span>   any</span><br><span class="line">          <span class="number">25</span>    <span class="number">28</span>    <span class="number">25</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">6</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">20</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">30</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">          <span class="number">8</span>      <span class="number">23</span>     <span class="number">1</span>  lock   Ljava/lang/Object;</span><br></pre></td></tr></table></figure></li><li><code>[12, 22)</code>是监测的释放锁的流程，如果出现了异常，则跳转到25行，将异常信息存储到slot 3，同时再次尝试释放锁</li><li><code>[25, 28)</code>也是监测异常，如果有异常，</li></ul></li></ul><h1 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h1><ul><li>所谓<code>语法糖</code>，其实就是指Java编译器把<code>.java</code>编译为<code>.class</code>字节码的过程中，自动生成的和转换的一些代码，主要是为了减轻程序员的负担，算是Java编译器给我们的一个额外福利</li><li>下面的代码分析，借助了javap工具、idea的反编译功能、idea插件jclasslib等工具。另外，编译器转换的结果直接就是class字节码，只是为了便于阅读，给出了<code>几乎等价</code>的Java源码</li></ul><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><ul><li>如果一个类没有声明任何构造函数，Java 编译器会自动为该类生成一个无参构造函数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译成class后的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个无参构造是编译器帮助我们加上的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><ul><li>这个特性是 <code>JDK 5</code> 开始加入的，<code>代码片段1：</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>但是这段代码在<code>JDK 5</code>之前是无法编译通过的，比如改写为如下形式，<code>代码片段2</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer x = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> y = x.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间相互转换（尤其是集合类中的操作都是包装类型），因此这些转换的事情在<code>JDK 5</code>以后都由编译器在编译阶段完成。即<code>代码片段1</code>都会在编译阶段转换成<code>代码片段2</code></li></ul><h2 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h2><ul><li>泛型也是<code>JDK 5</code>开始加入的特性，但Java在编译泛型后会执行<code>泛型擦除</code>的动作，即泛型信息在编译为字节码后就丢失了，实际的类型都当做Object类型来处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>);               <span class="comment">// 实际调用的是 List.add(Object e)</span></span><br><span class="line">        Integer x = list.get(<span class="number">0</span>);    <span class="comment">// 实际调用的是 Object obj = List.get(int index);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>所以在取值时，编译器真正生成的字节码中，还需要额外做一个类型转换的操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 Object 转为 Integer</span></span><br><span class="line">Integer x = (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li>如果前面的x遍历修改为int基本类型，那么最终生成的字节码为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = (Integer)list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure></li><li>还好这些麻烦事都不用自己做，要么叫语法糖呢</li><li>擦除的是字节码上的泛型信息，可以看到LocalVariableTypeTable仍然保留了方法参数泛型的信息<ul><li>从下面字节码的第26行，我们可以清楚的看到add方法其实添加的是Object类型对象</li><li>从下面字节码的第30行，我们可以清楚的看到get方法的返回值也是Object类型对象</li><li>同时第31行是将类型强制转换为Integer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> com.demo.Candy03();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/demo/Candy03;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/util/ArrayList</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">      <span class="number">11</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">      <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: iconst_0</span><br><span class="line">      <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">27</span>: checkcast     #<span class="number">7</span>                  <span class="comment">// class java/lang/Integer</span></span><br><span class="line">      <span class="number">30</span>: astore_2</span><br><span class="line">      <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">20</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">31</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">          <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List;</span><br><span class="line">         <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span>     x   Ljava/lang/Integer;</span><br><span class="line">    LocalVariableTypeTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br></pre></td></tr></table></figure></li></ul></li><li>使用反射，能够获取到方法类型参数的泛型和方法返回值泛型的信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        Method test = Candy03.class.getMethod(<span class="string">&quot;test&quot;</span>, List.class, Map.class);</span><br><span class="line">        Type[] types = test.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                System.out.println(<span class="string">&quot;原始类型 - &quot;</span> + parameterizedType.getRawType());</span><br><span class="line">                Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;泛型参数[%d] - %s\n&quot;</span>, i, arguments[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回类型 - &quot;</span> + test.getGenericReturnType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Integer&gt; <span class="title">test</span><span class="params">(List&lt;String&gt; list, Map&lt;Integer, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始类型 - interface java.util.List</span><br><span class="line">泛型参数[0] - class java.lang.String</span><br><span class="line">原始类型 - interface java.util.Map</span><br><span class="line">泛型参数[0] - class java.lang.Integer</span><br><span class="line">泛型参数[1] - class java.lang.Object</span><br><span class="line">返回类型 - java.util.Set&lt;java.lang.Integer&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>可变参数也是<code>JDK 5</code>开始加入的新特性，示例代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] array = args;</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>可变参数String… args 其实是一个String[] args，同样Java编译器会在编译期间将上述代码转换为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy04</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        foo(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = args;          <span class="comment">// 直接赋值</span></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ul><li>注意：如果调用foo()时没有提供任何参数，那么则等价为foo(new String<a href=""></a>)，创建了一个空的数组，而不是传一个null进去</li></ul></div></li></ul><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><ul><li>仍然是JDK 5开始引入的语法糖，数组的循环<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;      <span class="comment">// 数组的赋初值的简化，也是语法糖 new int[]&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : array) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>会被编译器转换为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> e = array[i];</span><br><span class="line">            System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>而集合的循环<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实际上会被编译器转换为对迭代器的调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy06</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Integer next = (Integer) iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ul><li>foreach循环写法，能够配合数组，以及所有实现了Iterable接口的集合类一起使用，其中Iterable用来获取集合的迭代器Iterator</li></ul></div></li></ul><h2 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h2><ul><li>从<code>JDK 7</code>开始，switch可以作用于字符串和枚举类，这个功能其实也是语法糖，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ul><li>注意：swtich配合Spring和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码，自然就清楚了</li></ul></div></li><li>会被编译器转换为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>:                  <span class="comment">// hello 的 hashCode</span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">                    x = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>:                 <span class="comment">// world 的 hashCode</span></span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">                    x = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以看到，执行了两边switch，第一遍是根据字符串的hashCode和queals将字符串转换为相应byte类型，第二遍才是利用byte进行比较</li><li>那为什么第一遍既要比较hashCode又利用equals比较呢？<ul><li>hashCode是为了提高效率，减少可能的比较</li><li>而equals是为了防止哈希冲突，例如<code>BM</code>和<code>C.</code>这两个字符串的hashCode值都是2123，例如下面的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;BM&quot;</span>: &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C.&quot;</span>: &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>会被编译器转换为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (str.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2123</span>:                  <span class="comment">// hashCode 值可能相同，需要进一步用 equals 比较</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;C.&quot;</span>)) &#123;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;BM&quot;</span>)) &#123;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h2><ul><li>switch枚举的例子，原始代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sex)&#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            System.out.println(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>转换后的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy08</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个合成类（仅 jvm 使用，对我们不可见）</span></span><br><span class="line"><span class="comment">     * 用来映射枚举的 ordinal 与数组元素的关系</span></span><br><span class="line"><span class="comment">     * 枚举的 ordinal 表示枚举对象的序号，从 0 开始</span></span><br><span class="line"><span class="comment">     * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组大小即为枚举元素个数，里面存储case用来对比的数字</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            map[Sex.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">            map[Sex.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Sex sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = $MAP.map[sex.ordinal()];</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ul><li>JDK 7 新增了枚举类，以前面的性别枚举为例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>转换后的代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex[] $VALUES;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;MALE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;FEMALE&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $VALUES = <span class="keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sole constructor. Programmers cannot invoke this constructor.</span></span><br><span class="line"><span class="comment">     * It is for use by code emitted by the compiler in response to</span></span><br><span class="line"><span class="comment">     * enum type declarations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name    - The name of this enum constant, which is the identifier</span></span><br><span class="line"><span class="comment">     *                used to declare it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ordinal - The ordinal of this enumeration constant (its position</span></span><br><span class="line"><span class="comment">     *                in the enum declaration, where the initial constant is</span></span><br><span class="line"><span class="comment">     *                assigned</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sex[] values() &#123;</span><br><span class="line">        <span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Enum.valueOf(Sex.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Sex</code>被声明为一个<code>final</code>类，它继承了<code>Enum&lt;Sex&gt;</code>类，Enum是Java中定义枚举的抽象类。MALE和FEMALE是Sex类的两个枚举值，它们被定义为静态常量。</li><li>除此之外，还有一个私有的、<code>final</code>的<code>Sex</code>类型数组<code>$VALUES</code>，它用于存储Sex类的所有枚举值。在类的静态块中，<code>$VALUES</code>数组被初始化为一个包含<code>MALE</code>和<code>FEMALE</code>的数组。</li><li>构造函数<code>Sex(String name, int ordinal)</code>是私有的，这意味着无法在类的外部使用这个构造函数来创建<code>Sex</code>的实例。只有Java编译器生成的代码才能调用这个构造函数来创建Sex的实例。</li><li><code>values()</code>和<code>valueOf(String name)</code>是从Enum类继承的两个静态方法。<code>values()</code>方法返回一个包含Sex类所有枚举值的数组，<code>valueOf(String name)</code>方法返回指定名称的枚举值。</li><li>当我们使用MALE或者FEMALE时，其实底层调用的是<code>Enum.valueOf(Sex.class, &quot;MALE&quot;)</code>和<code>Enum.valueOf(Sex.class, &quot;FEMALE&quot;)</code></li></ul><h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><ul><li>JDK 7 开始新增了对需要关闭的自愿处理的特殊语法 try-with-resources<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (资源变量 = 创建资源对象) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>其中资源对象需要实现AutoCloseable接口，例如InputStream、OutputStream、Connection、Statement、ResultSet等接口都实现了AuthCloseable接口，使用try-with-resources 可以不用写finally语句块，编译器会帮助我们生成关闭资源代码，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\tmp.test&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>会被编译器转换为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Candy09</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\tmp.txt&quot;</span>);</span><br><span class="line">            Throwable t = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(is);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">                <span class="comment">// t 是我们代码出现的异常</span></span><br><span class="line">                t = e1;</span><br><span class="line">                <span class="keyword">throw</span> e1;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 判断了资源不为空</span></span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果我们代码有异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            is.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">                            <span class="comment">// 如果 close 出现异常，作为被压制异常添加</span></span><br><span class="line">                            t.addSuppressed(e2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e</span></span><br><span class="line">                        is.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>为什么要设计一个addSuppressed(Throwable e)（添加被压制异常）的方法呢？<ul><li>这是为了防止异常信息的丢失<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (MyResource resource = <span class="keyword">new</span> MyResource()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;close 异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出如下，两个异常信息都不会丢失<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.demo.Test.main(Test.java:6)</span><br><span class="line">    Suppressed: java.lang.Exception: close 异常</span><br><span class="line">        at com.demo.MyResource.close(Test.java:14)</span><br><span class="line">        at com.demo.Test.main(Test.java:7)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h2><ul><li>方法重写时，对返回值分两种情况    <ol><li>父类与子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（比较绕口，直接看下面的例子来理解） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 父类A方法的返回值是Number类型，子类B方法的返回值是Integer类型，Integer是Number的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么对于子类，编译器会做如下处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法才是真正重写了父类 public Number m() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synthetic bridge Number <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 public Integer m()</span></span><br><span class="line">        <span class="keyword">return</span> m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>其中的桥接方法比较特殊，仅对Java虚拟机课件，并且与原来的public Integer m()没有命名冲突</li></ul></li></ol></li></ul><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>转换后代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Candy10$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Candy10$<span class="number">1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对于匿名内部类，它的底层实现是类似于普通内部类的，只不过没有命名而已。在生成匿名内部类的class文件时，Java编译器会自动为该类生成一个类名，在原始类名上加后缀<code>$1</code>，如果有多个匿名内部类，则<code>$2</code>、<code>$3</code>以此类推</li><li>引用局部变量的匿名内部类，原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span>  <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span> + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>转换后代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 额外生成的类</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val$x;</span><br><span class="line">    Candy11$<span class="number">1</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val$x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok:&quot;</span> + <span class="keyword">this</span>.val$x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Candy11$<span class="number">1</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ul><li>注意：这也解释了为什么匿名内部类引用局部变量时，局部变量必须为final的<ul><li>因为在创建Candy$11对象时，将x的值赋给了val$x属性，所以x不应该再发生变化了</li><li>如果变化，那么$val$x属性没有机会再跟着一起变化</li></ul></li></ul></div></li></ul><h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>将类的字节码载入方法区中，内部采用C++的instanceKlass描述Java类，它的重要field有<ol><li>_java_mirror：Java的类镜像，例如对String来说，就是String.class，作用是把klass暴露给Java使用</li><li>_super：父类</li><li>_fields：成员变量</li><li>_methods：方法</li><li>_constants：常量池</li><li>_class_loader：类加载器</li><li>_vtable：需方发表</li><li>_itable：接口方法表</li></ol></li><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的<div class="note warning no-icon flat"><ul><li>instanceKlass这样的<code>元数据</code>是存储在方法区（1.8后是在元空间内），但_java_mirror是存储在堆中</li><li>可以通过HSDB工具查看</li></ul></div></li></ul><p><img src="https://s1.ax1x.com/2023/04/09/ppHhCmn.png" alt=""></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol><li>验证<ul><li>验证类是否符合JVM规范，安全性检查</li><li>使用支持二进制的编辑器修改HelloWorld.class的魔数<code>ca fe ba be</code>，在控制台运行后悔报错<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and try again</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value 3405691578 <span class="keyword">in</span> class file cn/itcast/jvm/t5/HelloWorld</span><br><span class="line">    at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><br><span class="line">    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)</span><br><span class="line">    at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)</span><br><span class="line">    at java.net.URLClassLoader.access<span class="variable">$100</span>(URLClassLoader.java:73)</span><br><span class="line">    at java.net.URLClassLoader<span class="variable">$1</span>.run(URLClassLoader.java:368)</span><br><span class="line">    at java.net.URLClassLoader<span class="variable">$1</span>.run(URLClassLoader.java:362)</span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:361)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at sun.misc.Launcher<span class="variable">$AppClassLoader</span>.loadClass(Launcher.java:331)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)</span><br></pre></td></tr></table></figure></li></ul></li><li>准备<ul><li>为static变量分配空间，设置默认值<ul><li>static变量在<code>JDK 7</code>之前存储于instanceKlass末尾，从<code>JDK 7</code>开始，存储于_java_mirror末尾</li><li>static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果static遍历是final的基本类型以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果static遍历是final的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul></li><li>原始Java代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String d = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object e = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>编译后的字节码文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: <span class="keyword">int</span> <span class="number">20</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> java.lang.String d;</span><br><span class="line">  descriptor: Ljava/lang/String;</span><br><span class="line">  flags: ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: String Hello</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> java.lang.Object e;</span><br><span class="line">  descriptor: Ljava/lang/Object;</span><br><span class="line">  flags: ACC_STATIC, ACC_FINAL</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> com.demo.Load01();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/demo/Load01;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">2</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field b:I</span></span><br><span class="line">       <span class="number">5</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">       <span class="number">8</span>: dup</span><br><span class="line">       <span class="number">9</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">12</span>: putstatic     #<span class="number">4</span>                  <span class="comment">// Field e:Ljava/lang/Object;</span></span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li>变量a和b都是静态变量，但是只有变量b被赋予了初始值10，赋值操作在初始化阶段体现，也就是在 static 块中实现</li><li>变量c和d都被声明为静态final变量，它们的值在编译时就已经确定了，分别是20和”Hello”，并且在字节码中使用了 ConstantValue 指令来指定这些常量的值。</li><li>变量e也是静态final变量，但它是一个引用类型变量，因此在初始化阶段才会被赋值，也就是在 static 块中实现。</li></ul></li><li>解析<ul><li>将常量池中的符号引用解析为直接引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">        ClassLoader classloader = Load02.class.getClassLoader();</span><br><span class="line">        <span class="comment">// loadClass 方法不会导致类的解析和初始化</span></span><br><span class="line">        Class&lt;?&gt; c = classloader.loadClass(<span class="string">&quot;com.demo.C&quot;</span>);</span><br><span class="line">        <span class="comment">// new C();</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    D d = <span class="keyword">new</span> D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>默认情况下，类的加载都是懒惰式的，如果用到了类C，没有用到类D的话，那么类D是不会主动加载的</li><li>使用loadClass方法不会导致类的解析和初始化<br>  <img src="https://s1.ax1x.com/2023/04/09/ppHo4r4.png" alt=""><ul><li>可以看到类D现在是<code>UnresolvedClass</code>，也就是未经解析的类，在常量池中仅仅是一个符号</li></ul></li><li>使用new C()的方式会导致类的解析和初始化<br>  <img src="https://s1.ax1x.com/2023/04/09/ppHoqG6.png" alt=""><ul><li>可以看到此时类D已经加载成功了，同时在类C的常量池中也可以解析类D的地址</li></ul></li></ul></li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code> 方法，虚拟机ui保证这个类的<code>构造方法</code>的线程安全</li><li>发生的时机：总的来说，类的初始化是懒惰的<ol><li>main方法所在的类，总会被首先初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台会输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br></pre></td></tr></table></figure></li></ul></li><li>首次访问这个类的静态变量或静态方法时，会进行初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br><span class="line">a init</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li></ul></li><li>子类初始化，如果父类还没未初始化，则父类也会进行初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(B.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br><span class="line">a init</span><br><span class="line">b init</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li></ul></li><li>默认的Class.forName会导致初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.demo.A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br><span class="line">a init</span><br></pre></td></tr></table></figure></li></ul></li><li>new对象会导致初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br><span class="line">a init</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li>不会导致类初始化的情况<ol><li>访问类的 static final 静态常量（基本类型和字符串） 不会触发初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(B.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure></li></ul></li><li>调用类对象.class不会触发初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(B.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br><span class="line">class com.demo.B</span><br></pre></td></tr></table></figure></li></ul></li><li>类加载器的loadClass方法不会触发初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        classLoader.loadClass(<span class="string">&quot;com.demo.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> b = <span class="number">5.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> c = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br></pre></td></tr></table></figure></li></ul></li><li>Class.forName的参数2为false时(initalize = false)，不会触发初始化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load03</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        Class.forName(<span class="string">&quot;com.demo.A&quot;</span>, <span class="keyword">false</span>, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制台输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main init</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>从字节码分析，使用a、b、c这三个常量，是否会导致E初始化  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(E.a);</span><br><span class="line">        System.out.println(E.b);</span><br><span class="line">        System.out.println(E.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String b = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结论：a和b不会导致E的初始化，c会导致E的初始化</li><li>a和b是基本类型和字符串常量，而c是包装类型，其底层还需要调用Integer.valueOf()方法来装箱，只能推迟到初始化阶段运行，字节码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String b;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: String hello</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.Integer c;</span><br><span class="line">    descriptor: Ljava/lang/Integer;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"></span><br><span class="line">  com.demo.E();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/demo/E;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">         <span class="number">5</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field c:Ljava/lang/Integer;</span></span><br><span class="line">         <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String init E</span></span><br><span class="line">        <span class="number">13</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>典型应用 -&gt; 完成懒惰初始化的单例模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上的实现特点是：<ol><li>懒惰实例化</li><li>初始化时的线程安全是有保障的</li></ol></li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>以<code>JDK 8</code>为例</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">加载哪的类</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Bootstrap ClassLoader</td><td style="text-align:center">JAVA_HOME/jre/lib</td><td style="text-align:center">无法直接访问</td></tr><tr><td style="text-align:center">Extension ClassLoader</td><td style="text-align:center">JAVA_HOME/jre/lib/ext</td><td style="text-align:center">上级为 Bootstrap，显示为 null</td></tr><tr><td style="text-align:center">Application ClassLoader</td><td style="text-align:center">classpath</td><td style="text-align:center">上级为 Extension</td></tr><tr><td style="text-align:center">自定义类加载器</td><td style="text-align:center">自定义 上级为</td><td style="text-align:center">Application</td></tr></tbody></table></div><ul><li>当JVM需要加载一个类时，它会首先委托父类加载器去加载这个类，如果父类加载器无法加载这个类，就会由当前类加载器来加载。如果所有的父类加载器都无法加载这个类，那么就会抛出ClassNotFoundException异常。</li></ul><h2 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h2><ul><li><code>Bootstrap ClassLoader</code>是所有类加载器中最早的一个，负责加载JRE/lib下的核心类库，如java.lang.Object、java.lang.String等。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出的结果是null，因为引导类加载器是由JVM的实现者用C/C++等语言编写的，而不是由Java编写的。在Java虚拟机的实现中，引导类加载器不是Java对象，也没有对应的Java类，因此它的ClassLoader属性为null。</li></ul><h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><ul><li>编写一个Tmp类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;classpath Tmp init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>加载Tmp类，并获取classLoader<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.demo.load.Tmp&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出如下，可以看到此时是由应用类加载器加载的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath Tmp init</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure></li><li>那我们现在写一个同名的Tmp类，将输出内容改为<code>ext Tmp init</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ext Tmp init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将其打成一个jar包，放到JAVA_HOME/jre/ext目录下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jar -cvf tmp.jar com/demo/load/Tmp.class</span><br><span class="line">已添加清单</span><br><span class="line">正在添加: Tmp.class(输入 = 479) (输出 = 321)(压缩了 32%)</span><br></pre></td></tr></table></figure></li><li>重新执行Load06，输出结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext Tmp init</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br></pre></td></tr></table></figure></li><li>此时就是从扩展类加载器加载的Tmp类了，因为当JVM需要加载一个类时，它会首先委托父类加载器去加载这个类</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul><li>所谓双亲委派机制，就是指调用类加载器的loadClass方法时，查找类的规则<div class="note warning no-icon flat"><p>感觉这个<code>双亲</code>翻译成<code>上级</code>更合适，因为它们之间并没有继承关系</p></div></li><li>我们来看看ClassLoader中的loadClass()方法的源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>精简一下逻辑，双亲委派的核心思路如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果类没有被加载，则委托给父ClassLoader加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果父ClassLoader加载失败，则在自身查找类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><ul><li>我们在使用JDBC时，都需要加载Driver驱动，但是我们好像并没有显示的调用Class.forName来加载Driver类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>那么实际上是如何加载这个驱动的呢？让我们来追踪一下源码，这里只看最核心的部分<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们试着输出一下DirverManager的类加载器是谁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());</span><br></pre></td></tr></table></figure></li><li>输出的结果是<code>null</code>，那么说明它是由<code>Bootstrap ClassLoader</code>加载的，那么按理说应该是去<code>JAVA_HOMT/jre/lib</code>下搜索驱动类。</li><li>但<code>JAVA_HOMT/jre/lib</code>显然没有mysql-connector-java-5.7.31.jar包，在DriverManager的静态代码块中，是如何正确加载<code>com.mysql.jdbc.Driver</code>的呢？</li><li>继续来看看loadInitialDrivers()方法的源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        drivers = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">    <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">    <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">    <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 ServiceLoader 机制加载驱动，即 SPI</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">             * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">             * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">             * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">             * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">             * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">             * and load the service.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">             * if driver not available in classpath but it&#x27;s</span></span><br><span class="line"><span class="comment">             * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用 jdbc.drivers 定义的驱动名加载驱动</span></span><br><span class="line">    <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">    <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">            Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>先看2，它最后是使用的Class.forName完成类的加载和初始化，关联的是应用类加载器，因此可以顺利完成驱动类的加载</li><li>在看1，它就是大名鼎鼎的Service Provider Interface（SPI）<ul><li>约定如下，在jar包的META-INF/services包下，以接口全限定名名为文件，文件内容是实现类名称<br><img src="https://imgse.com/i/ppqEGM8" alt=""></li><li>这样就可以使用如下代码遍历来得到实现类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;接口类型&gt; allImpls = ServiceLoader.load(接口类型.class);</span><br><span class="line">Iterator&lt;接口类型&gt; iter = allImpls.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>体现的是<code>面向接口编程 + 解耦</code>的思想，在下面的一些框架中都运用了此思想<ul><li>JDBC</li><li>Servlet初始化器</li><li>Spring容器</li><li>Dubbo（对SPI进行了扩展）</li></ul></li><li>接着看ServiceLoader.load方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线程上下文类加载器是当前线程使用的类加载器，默认就是应用类加载器，它内部又是由Class.forName调用了线程上下文类加载器完成类加载，具体代码在ServiceLoader的内部类LazyIterator中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">    String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String fullName = PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                 x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hasNextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><ul><li>先来思考一下：什么时候需要自定义类加载器<ol><li>自定义类加载器可用于加载非 Classpath 路径中的类文件，例如外部配置文件夹、网络资源或其他自定义路径。这种需求在一些动态扩展或插件化的场景中比较常见。</li><li>在应用程序中使用的类可以通过接口来使用，而不是直接引用类。这种做法可以减少应用程序之间的依赖，从而提高代码的灵活性和可维护性。同时，这种做法也使得框架的设计更加清晰和可扩展。</li><li>在Tomcat容器中，每个Web应用程序都使用自己的类加载器，从而避免了不同Web应用程序之间的类冲突问题。</li></ol></li><li>步骤<ol><li>继承ClassLoader类</li><li>遵从双亲委派机制，重写findClass方法<ul><li>注意不要重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用类加载器的loadClass方法</li></ol></li><li>示例<ol><li>准备一个Tmp类，编译后将其.class文件放至D盘根目录下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myclasspath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init myclasspath.Tmp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>自定义MyClassLoader类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String path = <span class="string">&quot;D:\\myclasspath\\&quot;</span> + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path), outputStream);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = outputStream.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类文件未找到:&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>调用自定义的类加载器loadClass方法来加载Tmp类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Load07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">&quot;myclasspath.Tmp&quot;</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>控制台输出如下，成功加载Tmp类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init myclasspath.Tmp</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><h3 id="分层编译（TieredComlilation）"><a href="#分层编译（TieredComlilation）" class="headerlink" title="分层编译（TieredComlilation）"></a>分层编译（TieredComlilation）</h3><ul><li>先来举个例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JIT1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">new</span> Object();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\n&quot;</span>, i, (end - start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>输出结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">028300</span><br><span class="line">127700</span><br><span class="line">228500</span><br><span class="line">326400</span><br><span class="line">426400</span><br><span class="line">526700</span><br><span class="line">627200</span><br><span class="line">727800</span><br><span class="line">826200</span><br><span class="line">926000</span><br><span class="line">1026200</span><br><span class="line">1128500</span><br><span class="line">1242900</span><br><span class="line">1326900</span><br><span class="line">1426900</span><br><span class="line">1526000</span><br><span class="line">1628300</span><br><span class="line">1725500</span><br><span class="line">1828500</span><br><span class="line">1926500</span><br><span class="line">2026100</span><br><span class="line">2127300</span><br><span class="line">2226600</span><br><span class="line">2326100</span><br><span class="line">2428300</span><br><span class="line">2525000</span><br><span class="line">2626400</span><br><span class="line">2726000</span><br><span class="line">2826500</span><br><span class="line">2926700</span><br><span class="line">3026400</span><br><span class="line">3126400</span><br><span class="line">3226100</span><br><span class="line">3326600</span><br><span class="line">3426300</span><br><span class="line">3526300</span><br><span class="line">3637600</span><br><span class="line">3726400</span><br><span class="line">3826000</span><br><span class="line">3928500</span><br><span class="line">4031700</span><br><span class="line">4143700</span><br><span class="line">4227000</span><br><span class="line">4326200</span><br><span class="line">4425600</span><br><span class="line">4530400</span><br><span class="line">4626400</span><br><span class="line">4726200</span><br><span class="line">4833800</span><br><span class="line">4926700</span><br><span class="line">5027700</span><br><span class="line">5126300</span><br><span class="line">5234100</span><br><span class="line">5326300</span><br><span class="line">5437400</span><br><span class="line">5533700</span><br><span class="line">5625100</span><br><span class="line">5728200</span><br><span class="line">5826000</span><br><span class="line">5941300</span><br><span class="line">6033500</span><br><span class="line">6126500</span><br><span class="line">6226300</span><br><span class="line">6326200</span><br><span class="line">6426500</span><br><span class="line">6526100</span><br><span class="line">6626300</span><br><span class="line">6726500</span><br><span class="line">6828800</span><br><span class="line">6926400</span><br><span class="line">7027100</span><br><span class="line">7127700</span><br><span class="line">7226500</span><br><span class="line">7316300</span><br><span class="line">747000</span><br><span class="line">758900</span><br><span class="line">768800</span><br><span class="line">7713500</span><br><span class="line">788300</span><br><span class="line">799000</span><br><span class="line">8011900</span><br><span class="line">819300</span><br><span class="line">8211700</span><br><span class="line">839400</span><br><span class="line">847700</span><br><span class="line">8510200</span><br><span class="line">868800</span><br><span class="line">876100</span><br><span class="line">887300</span><br><span class="line">897000</span><br><span class="line">907200</span><br><span class="line">915800</span><br><span class="line">927100</span><br><span class="line">937800</span><br><span class="line">946800</span><br><span class="line">955900</span><br><span class="line">967300</span><br><span class="line">976800</span><br><span class="line">986900</span><br><span class="line">995900</span><br><span class="line">1006800</span><br><span class="line">1018100</span><br><span class="line">1026700</span><br><span class="line">1036100</span><br><span class="line">1046700</span><br><span class="line">1056900</span><br><span class="line">1066700</span><br><span class="line">1075700</span><br><span class="line">1087100</span><br><span class="line">10913000</span><br><span class="line">1107000</span><br><span class="line">1116000</span><br><span class="line">1126700</span><br><span class="line">1137300</span><br><span class="line">1146700</span><br><span class="line">1156000</span><br><span class="line">1166700</span><br><span class="line">1176700</span><br><span class="line">11811400</span><br><span class="line">1195900</span><br><span class="line">1207000</span><br><span class="line">1216900</span><br><span class="line">1228400</span><br><span class="line">1236700</span><br><span class="line">12410100</span><br><span class="line">1259900</span><br><span class="line">12611500</span><br><span class="line">1278300</span><br><span class="line">1286700</span><br><span class="line">1297000</span><br><span class="line">1307000</span><br><span class="line">1316900</span><br><span class="line">1327500</span><br><span class="line">1336800</span><br><span class="line">1347800</span><br><span class="line">1357400</span><br><span class="line">1367000</span><br><span class="line">1377000</span><br><span class="line">1387000</span><br><span class="line">1397000</span><br><span class="line">1407100</span><br><span class="line">1417100</span><br><span class="line">14211400</span><br><span class="line">14310100</span><br><span class="line">1446800</span><br><span class="line">1457100</span><br><span class="line">1466800</span><br><span class="line">1476700</span><br><span class="line">1487000</span><br><span class="line">1496600</span><br><span class="line">1506600</span><br><span class="line">1516800</span><br><span class="line">1526700</span><br><span class="line">1539400</span><br><span class="line">1545700</span><br><span class="line">1557100</span><br><span class="line">1566600</span><br><span class="line">1577100</span><br><span class="line">1586000</span><br><span class="line">1597800</span><br><span class="line">16011800</span><br><span class="line">1616800</span><br><span class="line">1625800</span><br><span class="line">1636700</span><br><span class="line">1646600</span><br><span class="line">1657100</span><br><span class="line">1666800</span><br><span class="line">1677900</span><br><span class="line">1687000</span><br><span class="line">16910100</span><br><span class="line">1706900</span><br><span class="line">1716600</span><br><span class="line">1727200</span><br><span class="line">17310000</span><br><span class="line">1746700</span><br><span class="line">17551100</span><br><span class="line">17614900</span><br><span class="line">177300</span><br><span class="line">178300</span><br><span class="line">179300</span><br><span class="line">180300</span><br><span class="line">181300</span><br><span class="line">182300</span><br><span class="line">183300</span><br><span class="line">184200</span><br><span class="line">185300</span><br><span class="line">186200</span><br><span class="line">187200</span><br><span class="line">188300</span><br><span class="line">189300</span><br><span class="line">190300</span><br><span class="line">191300</span><br><span class="line">192300</span><br><span class="line">193300</span><br><span class="line">194300</span><br><span class="line">195300</span><br><span class="line">196300</span><br><span class="line">197200</span><br><span class="line">198300</span><br><span class="line">199300</span><br></pre></td></tr></table></figure></li><li>可以看到循环到73次附近时，速度明显加快了，循环到178次时，速度又明显加快了，这是为什么呢？</li><li>JVM将执行状态分为5个层次<ol><li><code>0层</code>：解释执行（Interpreter）<ul><li>在0层，JVM使用解释器来直接解释Java字节码，并执行程序。这种方式简单但效率较低，因为解释器需要逐条解释字节码指令，并执行它们，每次执行时都需要对字节码进行解析</li></ul></li><li><code>1层</code>：使用C1即时编译器编译执行（不带profilling）<ul><li>在1层，JVM会使用即时编译器（JIT）将Java字节码编译成本地机器码，然后直接执行机器码。这种方式相比于解释器，可以提供更高的执行速度。C1即时编译器适合编译执行热点代码，即被频繁执行的代码</li></ul></li><li><code>2层</code>：使用C1即时编译器编译执行（带基本的profilling）<ul><li>在2层，JVM会收集一些基本的执行状态数据，即profilling。例如方法的调用次数、循环的回边次数等，然后根据这些数据来决定哪些代码块需要被编译执行。这种方式可以更加精确地编译热点代码，从而提高程序的执行速度</li></ul></li><li><code>3层</code>：使用C1即时编译器编译执行（带完全的profilling）<ul><li>在3层，JVM会收集更加详细的执行状态数据，例如内联调用的次数、方法的参数类型等，以便更好地优化代码。这种方式可以进一步提高程序的执行速度，但同时也会增加编译的开销</li></ul></li><li><code>4层</code>：使用C2即时编译器编译执行<ul><li>在4层，JVM会使用更高级别的即时编译器（C2）来对代码进行优化，包括对循环、分支和递归等结构的优化。C2编译器的编译时间比C1场，但编译出来的代码执行速度更快。<div class="note info no-icon flat"><p>profilling是指在运行过程中手机一些程序执行的状态数据，例如<code>方法的调用次数</code>、<code>循环的回边次数</code></p></div></li></ul></li></ol></li><li>即时编译器（JIT）和解释器的区别<ul><li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码，并存入<code>Code Cache</code>，下次遇到相同的代码，<code>直接执行</code>，无需再次编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型，生成平台特定的机器码</li></ul></li><li>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成<code>机器码</code>，而是采用<code>解释器执行</code>的方法运行；</li><li>另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成<code>机器码</code>，以达到理想的运行<code>速度</code>。</li><li>执行效率上简单比较一下：<code>Interceptor &lt; C1 &lt; C2</code>   </li><li>上面代码中最后的耗时都在<code>300</code>附近，这是C2即时编译器做了逃逸分析，因为上面的代码中，我们仅仅是<code>创建</code>了Object对象，而并没有<code>使用</code>它，也就是没有<code>逃逸</code>出当前作用域<ul><li>在进行逃逸分析时，JVM会分析对象是否可能被线程外的代码引用，如果对象不会逃逸出当前方法的作用域，那么JVM会将对象的分配<code>优化为栈上分配</code>，从而避免了堆内存的分配和垃圾回收的压力。</li></ul></li><li>将对象分配在栈上的<code>优点</code>是：<ol><li><code>快速分配和回收</code>：栈内存的分配和回收都非常快，比堆内存要快得多。如果对象可以在栈上分配，那么它的分配和回收都可以更快，从而提高程序的性能。</li><li><code>减少垃圾回收</code>：在Java中，对象的分配和回收是由垃圾回收器来完成的。如果对象可以在栈上分配，那么它就不会对堆内存的使用和垃圾回收产生影响，从而可以减少垃圾回收的频率和时间，提高程序的性能。</li></ol></li><li>我们可以添加VM参数<code>-XX:-DoEscapeAnalysis</code>关闭逃逸分析，然后再次执行代码，观察耗时情况<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">028100</span><br><span class="line">128100</span><br><span class="line">226400</span><br><span class="line">326700</span><br><span class="line">426700</span><br><span class="line">526600</span><br><span class="line">626600</span><br><span class="line">726300</span><br><span class="line">826400</span><br><span class="line">926400</span><br><span class="line">1026500</span><br><span class="line">1126700</span><br><span class="line">1225900</span><br><span class="line">1339200</span><br><span class="line">1426700</span><br><span class="line">1526400</span><br><span class="line">1626600</span><br><span class="line">1735300</span><br><span class="line">1826400</span><br><span class="line">1926800</span><br><span class="line">2028600</span><br><span class="line">2128100</span><br><span class="line">2228700</span><br><span class="line">2328100</span><br><span class="line">2429900</span><br><span class="line">2533800</span><br><span class="line">2631300</span><br><span class="line">2729700</span><br><span class="line">2828500</span><br><span class="line">2926700</span><br><span class="line">3030900</span><br><span class="line">3130100</span><br><span class="line">3226700</span><br><span class="line">3330300</span><br><span class="line">3429700</span><br><span class="line">3526200</span><br><span class="line">3626200</span><br><span class="line">3728700</span><br><span class="line">3826800</span><br><span class="line">3929700</span><br><span class="line">4028600</span><br><span class="line">4130100</span><br><span class="line">4230700</span><br><span class="line">4328300</span><br><span class="line">4434000</span><br><span class="line">4526400</span><br><span class="line">4626100</span><br><span class="line">4728800</span><br><span class="line">4826800</span><br><span class="line">4928000</span><br><span class="line">5037800</span><br><span class="line">5127600</span><br><span class="line">5233700</span><br><span class="line">5336600</span><br><span class="line">5426900</span><br><span class="line">5525900</span><br><span class="line">5635500</span><br><span class="line">5726100</span><br><span class="line">5826100</span><br><span class="line">5926300</span><br><span class="line">6026000</span><br><span class="line">6129800</span><br><span class="line">6227600</span><br><span class="line">6330800</span><br><span class="line">6426900</span><br><span class="line">6526800</span><br><span class="line">6627100</span><br><span class="line">6711800</span><br><span class="line">686800</span><br><span class="line">697500</span><br><span class="line">708500</span><br><span class="line">717100</span><br><span class="line">726900</span><br><span class="line">736900</span><br><span class="line">746800</span><br><span class="line">756800</span><br><span class="line">7611300</span><br><span class="line">778800</span><br><span class="line">7810200</span><br><span class="line">7910500</span><br><span class="line">808400</span><br><span class="line">816800</span><br><span class="line">828400</span><br><span class="line">837100</span><br><span class="line">846700</span><br><span class="line">857000</span><br><span class="line">868100</span><br><span class="line">876700</span><br><span class="line">886700</span><br><span class="line">897000</span><br><span class="line">909100</span><br><span class="line">9112700</span><br><span class="line">9213000</span><br><span class="line">9311100</span><br><span class="line">947700</span><br><span class="line">955700</span><br><span class="line">966900</span><br><span class="line">978600</span><br><span class="line">987100</span><br><span class="line">997400</span><br><span class="line">1006700</span><br><span class="line">10113100</span><br><span class="line">10220000</span><br><span class="line">1039600</span><br><span class="line">1047100</span><br><span class="line">1057200</span><br><span class="line">1066900</span><br><span class="line">1076000</span><br><span class="line">1086900</span><br><span class="line">1096700</span><br><span class="line">1106800</span><br><span class="line">1117000</span><br><span class="line">1126700</span><br><span class="line">1136900</span><br><span class="line">1149500</span><br><span class="line">1156100</span><br><span class="line">1167200</span><br><span class="line">1177000</span><br><span class="line">1187000</span><br><span class="line">1197000</span><br><span class="line">1206600</span><br><span class="line">1216800</span><br><span class="line">1227100</span><br><span class="line">1236100</span><br><span class="line">1246900</span><br><span class="line">1256800</span><br><span class="line">1267100</span><br><span class="line">1277100</span><br><span class="line">12811700</span><br><span class="line">12911400</span><br><span class="line">13010300</span><br><span class="line">13110500</span><br><span class="line">13227200</span><br><span class="line">13311800</span><br><span class="line">13413200</span><br><span class="line">13573400</span><br><span class="line">13633800</span><br><span class="line">1378200</span><br><span class="line">1387500</span><br><span class="line">1396400</span><br><span class="line">1406200</span><br><span class="line">1416200</span><br><span class="line">1426200</span><br><span class="line">14313100</span><br><span class="line">1447400</span><br><span class="line">1456600</span><br><span class="line">1467100</span><br><span class="line">1476000</span><br><span class="line">1486200</span><br><span class="line">1496000</span><br><span class="line">1505200</span><br><span class="line">1516100</span><br><span class="line">1526000</span><br><span class="line">1536000</span><br><span class="line">1545200</span><br><span class="line">1559600</span><br><span class="line">1568800</span><br><span class="line">1576300</span><br><span class="line">1585600</span><br><span class="line">1596700</span><br><span class="line">1606200</span><br><span class="line">1617100</span><br><span class="line">1625800</span><br><span class="line">1636500</span><br><span class="line">1646200</span><br><span class="line">1656100</span><br><span class="line">1666000</span><br><span class="line">1676100</span><br><span class="line">1686200</span><br><span class="line">1696100</span><br><span class="line">1705900</span><br><span class="line">1717100</span><br><span class="line">1727900</span><br><span class="line">1736400</span><br><span class="line">1746400</span><br><span class="line">1756100</span><br><span class="line">1766300</span><br><span class="line">1776300</span><br><span class="line">1786300</span><br><span class="line">1796100</span><br><span class="line">1806900</span><br><span class="line">1816100</span><br><span class="line">1826500</span><br><span class="line">1835900</span><br><span class="line">1846300</span><br><span class="line">1856100</span><br><span class="line">1866300</span><br><span class="line">1876300</span><br><span class="line">1886100</span><br><span class="line">1896200</span><br><span class="line">1909100</span><br><span class="line">1918500</span><br><span class="line">1926300</span><br><span class="line">1936100</span><br><span class="line">1946000</span><br><span class="line">1956100</span><br><span class="line">1966300</span><br><span class="line">1976100</span><br><span class="line">1986200</span><br><span class="line">1995900</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法内联-Inlining"><a href="#方法内联-Inlining" class="headerlink" title="方法内联(Inlining)"></a>方法内联(Inlining)</h3><ul><li>方法内联<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(square(<span class="number">9</span>));</span><br></pre></td></tr></table></figure></li><li>如果发现square是热点方法，且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝，并粘贴到调用者的位置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure></li><li>还能够进行常量折叠(constant folding)的优化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure></li><li>下面来验证一下，还是输出耗时<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span><span class="number">81</span><span class="number">25200</span></span><br><span class="line"><span class="number">1</span><span class="number">81</span><span class="number">24100</span></span><br><span class="line"><span class="number">2</span><span class="number">81</span><span class="number">19800</span></span><br><span class="line"><span class="number">3</span><span class="number">81</span><span class="number">20000</span></span><br><span class="line"><span class="number">4</span><span class="number">81</span><span class="number">20200</span></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="number">73</span><span class="number">81</span><span class="number">19600</span></span><br><span class="line"><span class="number">74</span><span class="number">81</span><span class="number">20000</span></span><br><span class="line"><span class="number">75</span><span class="number">81</span><span class="number">9000</span></span><br><span class="line"><span class="number">76</span><span class="number">81</span><span class="number">2300</span></span><br><span class="line"><span class="number">77</span><span class="number">81</span><span class="number">2300</span></span><br><span class="line"><span class="number">78</span><span class="number">81</span><span class="number">3400</span></span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="number">267</span><span class="number">81</span><span class="number">3900</span></span><br><span class="line"><span class="number">268</span><span class="number">81</span><span class="number">51900</span></span><br><span class="line"><span class="number">269</span><span class="number">81</span><span class="number">15900</span></span><br><span class="line"><span class="number">270</span><span class="number">81</span><span class="number">100</span></span><br><span class="line"><span class="number">271</span><span class="number">81</span><span class="number">0</span></span><br><span class="line"><span class="number">272</span><span class="number">81</span><span class="number">0</span></span><br><span class="line"><span class="number">273</span><span class="number">81</span><span class="number">100</span></span><br><span class="line"><span class="number">274</span><span class="number">81</span><span class="number">100</span></span><br><span class="line"><span class="number">275</span><span class="number">81</span><span class="number">0</span></span><br><span class="line"><span class="number">276</span><span class="number">81</span><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>最后耗时为0，就是进行了常量折叠的优化</li><li>我们可以添加VM参数<code>-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</code>打印内联信息，可以看到我们的square方法被标记为了热点代码<br><img src="https://s1.ax1x.com/2023/04/10/ppqMt5F.png" alt=""></li><li>同时也可以禁止某个方法的内联<code>-XX:CompileCommand=dontinline,*JIT2.square</code>，不能进行常量折叠优化了，速度不会到达0<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="number">495</span><span class="number">81</span><span class="number">3300</span></span><br><span class="line"><span class="number">496</span><span class="number">81</span><span class="number">3700</span></span><br><span class="line"><span class="number">497</span><span class="number">81</span><span class="number">3000</span></span><br><span class="line"><span class="number">498</span><span class="number">81</span><span class="number">2900</span></span><br><span class="line"><span class="number">499</span><span class="number">81</span><span class="number">2900</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h3><ul><li>JMH基准测试参考：<a target="_blank" rel="noopener" href="https://openjdk.org/projects/code-tools/jmh/">https://openjdk.org/projects/code-tools/jmh/</a></li><li>添加如下依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>编写基准测试代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1)</span></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1)</span></span><br><span class="line"><span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benchmark1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] elements = randomInts(<span class="number">1_000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomInts(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        Random random = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            values[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            doSum(elements[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] local = <span class="keyword">this</span>.elements;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; local.length; i++) &#123;</span><br><span class="line">            doSum(local[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> element : elements) &#123;</span><br><span class="line">            doSum(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CompilerControl(CompilerControl.Mode.INLINE)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(Benchmark1.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>@Warmup</code>注解表示在基准测试运行之前需要进行预热，以使JVM达到最佳运行状态。在这个例子中，预热进行了2次，每次持续1秒钟。</li><li><code>@Measurement</code>注解表示运行5次基准测试，每次持续1秒钟。</li><li><code>@State</code>注解定义了Benchmark1类的实例作用域为Scope.Benchmark，表示这个类的实例可以在不同的测试方法之间共享，并保持在整个基准测试运行期间的状态。</li><li>这个类包含了三个测试方法：test1、test2和test3。这些测试方法执行相同的操作，即对数组elements中的所有元素进行求和操作，但使用不同的方法来访问数组中的元素。test1使用了数组索引，test2使用了本地数组变量，而test3使用了foreach循环。</li><li>启用doSum的方法内联<code>@CompilerControl(CompilerControl.Mode.INLINE)</code>，测试结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark          Mode  Cnt        Score       Error  Units</span><br><span class="line">Benchmark1.test1  thrpt    5  2830851.513 ± 68534.850  ops/s</span><br><span class="line">Benchmark1.test2  thrpt    5  2844317.417 ±  8097.137  ops/s</span><br><span class="line">Benchmark1.test3  thrpt    5  2849940.840 ±  7190.091  ops/s</span><br></pre></td></tr></table></figure></li><li><p>我们这里重点关注的是Score，现在开启了doSum的内联，这三种遍历方式的性能没有显著差异</p></li><li><p>那现在禁用doSum方法的内联<code>@CompilerControl(CompilerControl.Mode.DONT_INLINE)</code>，测试结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark          Mode  Cnt       Score       Error  Units</span><br><span class="line">Benchmark1.test1  thrpt    5  313751.710 ± 34874.348  ops/s</span><br><span class="line">Benchmark1.test2  thrpt    5  388759.125 ± 90456.387  ops/s</span><br><span class="line">Benchmark1.test3  thrpt    5  394614.041 ± 50721.161  ops/s</span><br></pre></td></tr></table></figure></li><li>这三种遍历方式的性能与之前相比，都下降了一个数量级，test2和test3的性能差异不大，test1的性能明显要差一点，这是为什么呢？</li><li>因为doSum方法是否内联，会影响elements成员变量的读取的优化<ul><li>如果doSum方法内联了，那么刚刚的test1方法会被优化成下面的样子（伪代码）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// elements.length 首次读取会缓存起来 -&gt; int[] local</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;     <span class="comment">// 后续 999 次 求长度 &lt;- local</span></span><br><span class="line">        sum += elements[i];                         <span class="comment">// 1000 次取下标 i 的元素 &lt;- local</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果doSum方法被内联，则循环中的每次对elements数组的访问都可以被优化，编译器可以将数组长度的读取操作提到循环外部，将elements数组的引用保存在本地变量中，从而避免了循环中每次访问数组引用的开销。这样，循环中只需要进行一次数组长度的读取，以及1000次对数组元素的访问操作，可以节省1999次对数组引用的访问。</li><li>如果doSum方法没有被内联，则循环中的每次对elements数组的访问都需要通过方法调用来完成，这会导致每次循环中都需要进行一次对数组引用的读取操作，因此不能进行上述优化。</li></ul></li></ul><h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><ul><li>示例代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;foo...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method foo = Reflect1.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">            foo.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>首先定义了一个名为<code>foo</code>的静态方法，该方法只是简单地输出一条字符串。</li><li>然后在main方法中，使用<code>Reflect1</code>类的<code>getMethod</code>方法获取名为<code>foo</code>的<code>Method</code>对象，以便之后进行反射调用。</li><li>接着使用循环调用反射方法，循环次数从0到16，每次循环都调用反射获取的Method对象的<code>invoke</code>方法，传入<code>null</code>作为静态方法的调用者。因为<code>foo</code>方法是静态方法，所以调用者可以为null。</li><li>最后使用<code>System.in.read()</code>方法暂停程序的运行，以便我们可以观察程序的输出结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sun.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.misc.ReflectUtil;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>前15次调用使用的是NativeMethodAccessorImpl实现的MethodAccessor，该实现类使用JNI调用底层的C/C++代码实现方法调用。由于NativeMethodAccessorImpl的实现开销较大，因此前15次的反射调用的性能相对较差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inflationThreshold = <span class="number">15</span>;</span><br></pre></td></tr></table></figure></li><li><p>而第16次调用则采用了GeneratedMethodAccessor1实现的MethodAccessor，这个实现类通常是使用Java字节码动态生成的，因此方法调用的性能比NativeMethodAccessorImpl更好。这是因为在第15次调用时，生成了一个新的MethodAccessorImpl实现类（MethodAccessorGenerator），并在下一次方法调用时使用该实现类，即第16次调用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring知识点</title>
      <link href="/2023/04/25/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/04/25/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ol><li>什么是Spring<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring是一个Java企业级应用开发框架，它提供了一系列的组件和工具，可以帮助开发者快死构建高效、可扩展、易维护的企业级应用。Spring的核心特性包括依赖注入(Dependency Injection)、面向切面编程(Aspect-Oriented Programming)、控制反转(Inversion of Control)等。同时，Spring还提供了多种插件和扩展，如Spring MVC用于Web开发、SpringBoot用于快速构建微服务等。Spring的成功在于它的灵活性和可扩展性，可以根据具体需求进行定义配置和集成</li></ul>              </div>            </details></li><li>你的项目中为什么使用Spring框架<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>由于Spring框架具有强大的功能和良好的可扩展性，所以我的项目使用Spring框架来构建企业级应用。具体来说，我们使用Spring框架的依赖注入功能来实现松耦合的组件设计及，提高了应用的可维护性和可测试性。同时，我们还使用Spring的面向切面编程来实现日志记录、性能监控、事务管理等横切关注点，使得代码更加简洁和易于维护。此外，我们还使用SpringBoot来快速构建微服务应用，以提高应用的可扩展性和部署效率。综合来说，Spring框架为我们的项目带来了很多好处，使得我们能够更加高效地开发和维护企业及应用</li></ul>              </div>            </details></li><li>Autowired和Resource关键字的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>@Autowired和@Resource都是用于进行依赖注入的注解，区别如下<ol><li><code>来源不同</code>：<code>@Autowired</code>是<code>Spring框架</code>提供的注解，而<code>@Resource</code>是<code>JavaEE</code>提供的注解，需要使用<code>javax.annotation</code>包</li><li><code>自动装配方式不同：</code><ul><li><code>@Autowired</code>默认按照类型进行自动装配，如果有多个相同类型的Bean，则按照属性名进行匹配。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在上面的示例代码中，Spring 会自动寻找类型为 <code>MyService</code> 的 Bean，并将其注入到 <code>myService</code> 属性中。如果有多个 <code>MyService</code> 类型的 Bean，Spring 将根据属性名（即 myService）进行匹配。如果我们想按照名称来装配，需要结合<code>@Qualifier</code>注解一起使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;service&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyService service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>@Resource</code>按照名称自动装配，如果指定了name属性，则按照名称匹配，如果没有指定，则默认按照属性名匹配<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name=&quot;myService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyService service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在上面的示例代码中，Spring 会自动寻找名称为 <code>myService</code> 的 Bean，并将其注入到 <code>service</code> 属性中。如果没有指定 <code>name</code> 属性，Spring 将根据属性名（即 service）进行匹配。</li></ul></li><li><code>支持的注入类型不同</code>：<code>@Autowired</code>支持的注入类型包括Bean、集合类型</li></ol></li></ul>              </div>            </details></li><li>依赖注入的方式有几种，各是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>依赖注入(Dependence Injection)是一种设计模式，它的主要思想是通过构造器、Setter方法或接口来向对象传递依赖关系，而不是让对象自己创建或查找依赖对象。在Spring框架中，依赖注入是实现松耦合、可测试和易维护的重要手段，通常有以下几种方式<ol><li><code>构造器注入(Constructor Injection)：</code>通过对象的构造器来注入依赖对象，通常在对象创建时就完成了依赖注入 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造器注入方式，将UserRepository类型的依赖项注入到UserService中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserRepositoryImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><code>Setter方法注入(Setter Injection)：</code>通过对象的Setter方法来注入依赖对象，通常在对象创建后进行依赖注入 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserRepositoryImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><code>接口注入(Interface Injection)：</code>依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。侵入性太强，不建议使用</li></ol></li><li>关于构造器注入和Setter注入的详细叙述可以参考我这篇文章的第5小节<div class="tag link"><a class="link-card" title="Spring" href="https://cyborg2077.github.io/2022/08/29/Spring/"><div class="left"><img src="https://s1.ax1x.com/2023/03/06/ppZ9JIS.png"/></div><div class="right"><p class="text">Spring</p><p class="url">https://cyborg2077.github.io/2022/08/29/Spring/</p></div></a></div></li></ul>              </div>            </details></li><li>讲一下什么是Spirng<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发。Spring的核心思想是通过依赖注入和面向切面编程来实现松耦合、可测试和易维护的应用程序</li><li>Spring框架提供了许多核心功能，包括    <ol><li><code>控制反转(Inversion of Control, IoC)：</code>讲对象的创建和依赖关系的管理交给框架来完成，使得应用程序更加松耦合</li><li><code>依赖注入(Dependency Injection, DI)：</code>将对象之间的依赖关系通过注入的方式来实现，提高了应用程序的可测试性和可维护性</li><li><code>面向切面编程(Aspect-Oriented Programming, AOP)：</code>通过切面来解决横切关注点的问题，如事务控制、安全控制、日志记录等</li><li><code>数据访问层(Data Access)：</code>提供了一套方便的API来访问数据库和其他数据存储系统，包括JDBC、ORM、NoSQL等</li><li><code>Web开发(Web Development)：</code>提供了一套强大的Web开发框架，包括Spring MVC、Spring WebFlux等</li><li><code>消息队列(Messaging)：</code>提供了一套消息传递机制，支持JMC、RabbitMQ等</li></ol></li><li>除此之外，Spring还提供了许多其他功能，如集成测试、批处理、缓存等。</li></ul>              </div>            </details></li><li>说说你对SpringMVC的理解<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>SpringMVC</code>是Spring框架的一个模块，它提供了一种基于<code>MVC(Model-View-Controller)</code>架构的Web应用程序开发模型，通过<code>控制器(Controller)</code>来管理用户请求，通过模型(Model)来处理业务逻辑，通过视图(View)来呈现响应结果，从而实现了Web应用程序的分层架构和模块化开发</li><li>在<code>SpringMVC</code>中，用户请求首先由<code>前端控制器(DispatcherServlet)</code>接收，并将其分派给相应的<code>处理器(Handler)</code>，处理器根据请求的<code>URL</code>和<code>请求方法</code>来选择具体的处理方法，并返回相应的数据模型和视图名称，前端控制器根据模型数据和视图名称来生成响应结果，并将其返回给用户</li><li><code>SpringMVC</code>提供了许多特性，如<code>请求映射</code>、<code>参数绑定</code>、<code>数据验证</code>、<code>异常处理</code>、<code>国际化</code>、<code>文件上传</code>等，同时也支持多种<code>视图技术</code>，如<code>JSP</code>、<code>Thymeleaf</code>、<code>Freemarker</code>等。<code>SpringMVC</code>还支持<code>RESTful</code>风格的<code>Web服务</code>开发，并提供了一些Web相关的功能，如<code>SpringWebSockets</code>、<code>SpringWebFlux</code>等</li></ul>              </div>            </details></li><li>SpringMVC常用的注解有哪些<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>SpringMVC中的注解是用来标识<code>处理器(Handler)</code>和<code>请求映射(RequestMapping)</code>之间的关系的。下面是一些常用的注解<ol><li><code>@Controller：</code>标记一个类为处理器(Handler)</li><li><code>@RequestMapping：</code>标记处理器的方法和请求之间的映射关系，可以指定请求的URL、请求方法、请求参数等</li><li><code>@RequestParam：</code>用于将请求参数绑定方法参数上</li><li><code>@PathVariable：</code>用于将URL路径变量绑定到方法参数上</li><li><code>@ResponseBody：</code>用于将方法的返回值转换为HTTP响应的正文内容</li><li><code>@RequestBody：</code>用于将HTTP请求的正文内容绑定到方法参数上。</li></ol></li></ul>              </div>            </details></li><li>谈谈你对Spring的AOP的理解<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>AOP(Aspect-Oriented Programming, 面向切面编程)</code>是Spring框架的一个核心特性之一，它通过在程序运行期间动态地将额外的行为(例如日志、安全检查等)插入到代码中，以实现更加灵活和可维护的程序设计</li><li>在Spring框架中，AOP主要通过以下几个概念来实现 <ol><li><code>切点(Pointcut)</code>；指定在哪些程序执行点上插入额外的行为，通常使用表达式来定义切点</li><li><code>通知(Advice)</code>：插入到切点上的额外行为，通常包括前置通知、后置通知、异常通知、环绕通知等</li><li><code>切面(Aspect)</code>：由切点和通知组成第一个横切逻辑单元，可以看做是一种特殊的类</li><li><code>织入(Weaving)</code>：将切面与目标对象合并，生成一个新的代理对象，并在运行期间插入额外行为</li></ol></li><li>在Spring框架中，AOP可以应用于各种场景，如事务管理、缓存、日志、权限控制等，可以大大简化程序设计和代码维护工作，同时Spring框架还提供了各种AOP相关的注解和工具类，使得AOP的使用变得更加简单和方便</li></ul>              </div>            </details></li><li><code>Spring AOP</code>和<code>AspectJ AOP</code>有什么区别 <details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>SpringAOP</code>和<code>AspectJ AOP</code>都是AOP实现的凡事，它们都可以在运行时动态地为程序添加额外的行为，但是他们之间有如下几个区别<ol><li><code>实现方式不同</code>：<code>SpringAOP</code>是基于JDK动态代理和CGLIB的代理机制实现的，而<code>AspectJ AOP</code>则是基于字节码操纵实现的</li><li><code>支持的切点表达式不同</code>：<code>AspectJ AOP</code>支持更加强大和灵活的切点表达式，例如正则表达式、类型模式匹配、注解匹配等，而<code>SpringAOP</code>仅支持基于方法名、参数列表和异常类型的切点表达式</li><li><code>适用范围不同</code>：<code>SpringAOP</code>主要适用于Spring框架中的IOC容器和SpringMVC中的Web应用程序，而<code>AspectJ AOP</code>则是一个独立的AOP框架，可以用于任何Java应用程序</li><li><code>集成方式不同</code>：<code>Spring AOP</code>可以与Spring框架的其他特性(如IOC、事务管理等)无缝集成，而<code>AspectJ AOP</code>需要通过AspectJ编译器来实现</li></ol></li></ul>              </div>            </details></li><li>在Spring AOP中，关注点和横切关注的区别是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>关注点(Concern)是指在软件系统中，需要关注和处理的某一方面或功能模块，例如日志、事务、安全等。在AOP中，关注点被表示为切点(Pointcut)，用于指定在哪些代码位置需要执行额外的行为</li><li>横切关注(Cross-cutting Concern)是指在软件系统中，不同的关注点可能相互交叉或重叠，例如一个方法既需要进行日志记录，又需要进行事务管理。在AOP中，横切关注通常被表示为切面(Aspect)，由切点和通知组成，用于将多个关注点的行为织入到代码中</li></ul>              </div>            </details></li><li>什么是通知呢？有哪些类型<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在SpringAOP中，通知(Advice)是指在横切关注中执行的额外代码块，它可以在方法调用前后、异常抛出时或者方法执行成功后执行。通知是实现AOP的核心机制之一，用于将横切关注的行为织入到目标对象的方法中</li><li>SpringAOP提供了以下五种类型的通知<ol><li><code>前置通知(Before Advice)：</code>在目标方法执行前执行的通知</li><li><code>后置通知(After Advice)：</code>在目标方法执行后执行的通知，无论方法是正常返回还是抛出异常，都会执行</li><li><code>返回通知(After Returning Advice)：</code>在目标方法执行后执行的通知，只有在方法正常返回孩时才会执行</li><li><code>异常通知(After Throwing Advice)：</code>在目标方法抛出异常后执行的通知</li><li><code>环绕通知(Around Advice)：</code>在目标方法执行前后都可以执行的通知，可以控制目标方法的执行过程，甚至可以完全取代目标方法的执行</li></ol></li><li>这些通知可以在切面中指定对应的切点，实现对目标对象方法的相应拦截和处理</li></ul>              </div>            </details></li><li>说说你对Spring的IoC是怎么理解的 <details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring的IOC(Inversion of Control)是指将对对象的创建、组装、管理的责任交给容器，由容器负责对象之间的依赖关系。在IOC模式中，对象不再自己管理其他对象的依赖，而是将依赖关系反转给容器进行管理</li><li>在Spring中，IOC是通过依赖注入(Dependency Injection, DI)实现的，依赖注入是指容器通过自动或者手动的方式，将对象所依赖的其他对象或者资源注入到对象中，从而达到对象之间的松耦合。</li><li>通过使用IOC容器，可以实现对象之间的解耦，增加代码的灵活性和可维护性。同时IOC容器也提供了很多功能，例如对象的生命周期管理、AOP、事务管理等，可以大大减少开发者的工作量，提高开发效率</li><li>总的来说，Spring的IOC是通过依赖注入实现的，将对象之间的依赖关系交给容器进行管理，从而实现对象之间的松耦合和增强系统的可维护性和可扩展性</li></ul>              </div>            </details></li><li>解释一下Spring的Bean的生命周期<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring的Bean生命周期包括以下阶段<ol><li><code>实例化(Instantiation)：</code>在这个阶段，Spring容器会通过Bean定义中指定的构造函数或者工厂方法来创建Bean的实例</li><li><code>属性赋值(Populate Properties)：</code>在这个阶段，Spring容器会将配置文件中指定的Bean属性或者引用注入到Bean实例中</li><li><code>初始化(Initalization)：</code>在这个阶段，Spring容器会调用Bean的初始化方法(如果有)，并完成Bean的一些初始化操作</li><li><code>使用(In Use)：</code>在这个阶段，Bean可以被应用程序使用</li><li><code>销毁(Destruction)：</code>在这个阶段，Spring容器会调用Bean的销毁方法(如果有)，并完成Bean的销毁操作w</li></ol></li></ul>              </div>            </details></li><li>解释Spring支持的几种bean的作用域<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring支持一下物种Bean作用域<ol><li><code>Singleton(单例)：</code>在整个应用程序中，只存在一个Bean实例。默认情况下，Spring中的Bean都是单例的</li><li><code>Prototype(原型)：</code>每次通过容器获取Bean时，都会创建一个新的Bean实例</li><li><code>Request：</code>在一次HTTP请求中，Bean的实例是唯一的</li><li><code>Session：</code>在一个HTTP Session中，Bean的实例是唯一的</li><li><code>Global Session：</code>在一个全局的HTTP Session中，Bean的实例是唯一的</li></ol></li></ul>              </div>            </details></li><li>Spring基于XML注入的Bean有几种方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>Setter注入</li><li>构造器注入</li><li>静态工厂注入</li><li>实例工厂</li></ol><ul><li>具体实现方式可以参考我的另一篇文章<div class="tag link"><a class="link-card" title="Spring" href="https://cyborg2077.github.io/2022/08/29/Spring/"><div class="left"><img src="https://s1.ax1x.com/2023/03/06/ppZ9JIS.png"/></div><div class="right"><p class="text">Spring</p><p class="url">https://cyborg2077.github.io/2022/08/29/Spring/</p></div></a></div></li></ul>              </div>            </details></li><li>Spring框架中都用到了哪些设计模式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>单例模式：</code>S`pring中的Bean默认是单例的，通过IOC容器对Bean进行管理，保证整个应用程序中只存在一个Bean实例</li><li><code>工厂模式：</code>S`prig中的IOC容器负责创建和管理Bean实例，可以将IOC容器看做是一个工厂，通过工厂方法来创建Bean实例</li><li><code>代理模式：</code>S`pring中的AOP基于代理实现，可以通过JDK动态代理或CGLIB动态代理来实现AOP功能</li><li><code>观察者模式：</code>Spring中的事件驱动机制是基于观察者模式实现，Bean可以发布事件，其他Bean可以通过监听器来响应事件</li><li><code>模板方法模式：</code>Spring中的JdbcTemplate和Hibernate Template等模板类，使用了模板方法模式，将重复性的操作封装到父类中，自雷只需要实现特定方法即可</li></ol>              </div>            </details></li><li>说说Spring中ApplicationContext和BeanFactory的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring中的ApplicationContext和BeanFactory都是IOC容器，负责管理和创建Bean实例，但他们之间有一些区别<ol><li>ApplicationContext是BeanFactory的子接口，它提供了更多的功能，例如国际化、事件驱动等</li><li>ApplicationContext会在启动时预先实例化所有的单例Bean，而BeanFactory则是按需创建Bean</li><li>ApplicationContext支持Bean的自动装配、AOP等功能，而BeanFactory需要手动配置</li><li>ApplicationContext支持多种资源加载方式，例如XML、注解、属性文件等，而BeanFactory只支持XML格式的配置文件</li><li>ApplicationContext提供了更多的扩展点，例如BeanPostProcessor、ApplicationListener等，可以对Bean的生命周期和时间进行监听和处理</li></ol></li><li>如果需要使用Spring的更高级特性，例如AOP、国际化、事件驱动等，可以选择使用ApplicationContext；如果只需要简单地创建和管理Bean实例，可以选择使用BeanFactory</li></ul>              </div>            </details></li><li>Spring框架中的单例Bean是线程安全的吗<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在Spring框架中，默认情况下，所有的Bean都是单例的，也就是说在整个应用中只有一个bean实例。对于单例Bean是否线程安全，需要根据具体的实现来判断<ul><li>如果单例Bean是无状态的，即没有实例变量，或者所有的实例变量都是线程安全的(例如final修饰的常量)，那么单例Bean就是线程安全的</li><li>如果单例Bean是有状态的，即包含实例变量，并且这些变量是非线程安全的，那么单例bean就不是线程安全的。在多线程并发访问单例Bean时，可能会出现数据竞争和并发安全问题</li><li>为了解决这个问题，可以考虑将单例Bean的实例变量使用ThreadLocal进行封装，保证每个线程访问时都拥有自己的实例变量。此外，也可以考虑将单例Bean的作用域改为原型(Prototype)，每次请求都会创建一个新的Bean实例，避免并发访问问题</li></ul></li></ul>              </div>            </details></li><li>Spring是怎样解决循环依赖的<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <p><img src="https://s1.ax1x.com/2023/05/01/p9Gnrd0.png" alt=""></p><ul><li>整个流程大致如下：<ol><li>首先 A 完成初始化第一步并将自己提前曝光出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来；</li><li>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来；</li><li>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)。这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</li><li>回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。 </li></ol></li></ul>              </div>            </details></li><li>说说事务的隔离级别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>事务隔离级别是指在并发情况下，不同事务之间的隔离程度。在数据库中一般有4种隔离级别<ol><li><code>读未提交(Read Uncommitted)：</code>事务中的修改即使没有提交，也能被其他事务看到，存在脏读、不可重复读和幻读的问题</li><li><code>读已提交(Read Committed)：</code>事务提交后才能被其他事务看到，解决了脏读的问题，但不可重复读和幻读问题仍然存在</li><li><code>可重复读(Repeatable Read)：</code>保证同一事务中多次读取同一数据的结果是一致的，解决了不可重复读的问题，但幻读问题仍然存在</li><li><code>串行化(Serializable0)：</code>事务串行执行，可以完全解决并发问题，但是效率最低</li></ol></li><li>在Spring中，可以使用@Transactional注解来声明一个事务，通过设置isolation属性来指定事务的隔离级别，默认为Isolation.DEFAULT，表示使用数据库默认隔离级别(通常为Read Committed)。可以通过Isolation枚举类来设置隔离级别<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li>说说事务的传播级别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>事务的传播级别是指当在一个事务范围内调用另一个带有事务的方法时，当前事务如何与调用方法的事务进行交互的一种方式。Spring中定义了7种事务传播级别<ol><li><code>REQUIRED：</code>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务，这是默认传播级别</li><li><code>SUPPORTS：</code>支持当前事务，如果当前存在事务，则加入改事务；如果当前没有事务，则以非事务的方式继续执行</li><li><code>MANDATORY：</code>强制要求存在事务，如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</li><li><code>REQUIRES_NEW：</code>创建一个新的事务，如果当前存在事务，则挂起当前事务</li><li><code>NOT_WUPPORTED：</code>以非事务方式执行操作，如果当前存在事务，则挂起当前事务</li><li><code>NEVER：</code>以非事务方式执行操作，如果当前存在事务，则抛出异常</li><li><code>NESTEDD：</code>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与REQUIRED传播级别类似的操作</li></ol></li></ul>              </div>            </details></li><li>Spring事务实现方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Spring中事务的实现方式主要有两种：编程式事务和声明式事务<ol><li><code>编程式事务</code>：是指通过编写代码来控制事务的提交和回滚。在编程式事务中，开发人员需要手动获取事务管理器，并在需要的地方进行事务的开启、提交和回滚等操作。编程式事务虽然灵活，但是代码侵入性较高，容易造成代码臃肿和难以维护，因此Spring推荐使用声明式事务来实现事务管理</li><li><code>声明式事务</code>：是指通过配置来控制事务的提交和回滚。在声明式事务中，开发人员只需使用注解或XML配置文件来声明事务的属性和行为即可，具体的事务管理操作则由Spring框架自动完成</li></ol></li><li>声明式事务的优点是代码简洁，易于维护，而且可以灵活切换事务管理方式。Spring中主要通过AOP技术实现声明式事务，其底层实现依赖于DataSourceTransactionManager和TransactionInterceptor等组件</li></ul>              </div>            </details></li><li>Spring框架管理的事务有哪些优点<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>简化代码：</code>使用Spring框架观念里事务可以大大简化代码量，使代码更易于维护</li><li><code>降低耦合性：</code>使用Spring框架管理事务可以将业务逻辑与事务处理分离，降低了耦合性</li><li><code>避免重复代码：</code>使用Spring框架管理事务可以避免在每个业务方法中重复编写事务管理代码</li><li><code>支持声明式事务：</code>Spring框架支持声明式事务，可以通过注解或XML配置来定义事务的属性和行为</li><li><code>支持多种事务管理器：</code>Spring框架支持多种事务管理器，包括JDBC事务、Hibernate事务、JPA事务、JTA事务等</li><li><code>支持事务的回滚和提交：</code>Spring框架可以自动管理事务的提交和回滚，从而保证事务的一致性和完整性</li><li><code>提高事务的性能：</code>Spring框架使用缓存和批处理等技术来提高事务的性能和效率</li></ol>              </div>            </details> </li><li>事务注解的本质是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>事务注解的本质是通过Spring AOP机制，在方法执行前后动态创建代理对象，将方法包装在一个事务中。事务注解在执行方法前开启一个事务，如果方法执行成功，则提交事务；如果方法执行过程中发生异常，则回滚事务。通过事务注解，我们可以在方法上标记事务的属性，方便灵活地控制事务的执行行为。同时，由于Spring框架在底层处理事务，因此可以避免一些常见的事务处理问题，比如并发访问、死锁等问题。事务注解的使用简单，可以提高开发效率，降低代码复杂度。</li></ul>              </div>            </details></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(3)</title>
      <link href="/2023/04/25/JVMPart/JVM_3/"/>
      <url>/2023/04/25/JVMPart/JVM_3/</url>
      
        <content type="html"><![CDATA[<h1 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li>当一个对象被引用是，就当引用对象的值<code>+1</code>，当引用对象的值为<code>0</code>时，则说明该对象没有被引用，那么就可以被垃圾回收器回收</li><li>当一个对象被引用是，就当引用对象的值<code>+1</code>，当引用对象的值为<code>0</code>时，则说明该对象没有被引用，那么就可以被垃圾回收器回收</li><li>这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这两个对象都无法被释放<br><img src="https://s1.ax1x.com/2023/04/01/ppWDSuq.png" alt=""></li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><ul><li>JVM垃圾回收机制的可达性分析算法，是一种基于引用的垃圾回收算法。其基本思想是通过一系列被称为”GC Roots”的根对象作为起点，寻找所有被根对象直接或间接引用的对象，将这些对象称为”可达对象”，而没有被找到的对象则被视为”不可达对象”，需要被回收。<div class="note info no-icon flat"><ul><li>形象一点理解就是我有一串葡萄，我把这串葡萄拿起来，连在根上的葡萄就是可达对象，而掉在盘子里的葡萄就是不可达对象，需要被回收</li></ul></div></li><li>在JVM中，有四种类型的GC Roots对象：<ol><li><code>虚拟机栈中引用的对象</code>：虚拟机栈是用于存储方法调用和执行的栈空间。当一个方法被调用时，会在栈中创建一个栈帧，用于存储该方法的局部变量、参数和返回值等信息。如果栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>方法区中类静态属性引用的对象</code>：方法区是用于存储类信息、常量池、静态变量等信息的内存区域。当一个类被加载到方法区时，其中的静态属性会被分配在方法区中，如果这些静态属性中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>方法区中常量引用的对象</code>：常量池是方法区的一部分，用于存储常量。如果常量池中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>本地方法栈中JNI引用的对象</code>：JNI是Java Native Interface的缩写，用于在Java程序中调用本地方法（即由C或C++等语言编写的方法）。当本地方法被调用时，会在本地方法栈中创建一个栈帧，如果该栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li></ol></li><li>可达性分析算法基于这些GC Roots对象，通过遍历所有的引用链，找到所有可达对象，将它们标记为存活对象，而没有被找到的对象则被视为不可达对象，需要被回收。</li><li>可达性分析算法的主要优点是可以处理复杂的引用结构，例如循环引用、交叉引用等情况，能够识别出所有可达对象，从而准确地进行垃圾回收。但是，它也有一些缺点，例如需要耗费较多的时间进行垃圾回收、可能会出现漏标和误标等问题。为了解决这些问题，JVM中还采用了其他的垃圾回收算法，如标记-清除算法、复制算法、标记-整理算法等，以提高垃圾回收的效率和准确性。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>在Java中，对象不仅可以被正常引用，还可以被特殊的引用类型引用。这些引用类型决定了垃圾回收器如何对对象进行回收。</li><li>JVM中共有五种引用类型，它们分别是<ol><li><code>强引用（Strong Reference）：</code>是最常见的引用类型，也是默认的引用类型。如果一个对象具有强引用，那么即使内存空间不足，垃圾回收器也不会回收它。只有当该对象的所有强引用都失效时，对象才会被回收</li><li><code>软引用（Soft Reference）：</code>是一种比强引用弱一些的引用类型。如果一个对象<code>只具有</code>软引用，那么当内存空间不足时，垃圾回收器可能会回收它。软引用通常用于实现内存敏感的缓存<ul><li>可以配合引用队列来释放软引用自身</li></ul></li><li><code>弱引用（Weak Reference）：</code>是一种比软引用更弱一些的引用类型。如果一个对象<code>只具有</code>弱银用，那么垃圾回收器在下一次运行时，无论内存空间是否足够，都会回收该对象。若引用通常用于实现在对象可用时进行操作的场景<ul><li>可以配合引用队列来释放软引用自身</li></ul></li><li><code>虚引用（Phantom Reference）：</code>是最弱的一种引用类型。如果一个对象只具有虚引用，那么在任何时候都可能被垃圾回收器回收。虚引用通常用于追踪对象被垃圾回收的状态<ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul></li><li><code>终结器引用（Final Reference）：</code>是一种特殊的弱引用类型，它只在对象被回收时被添加到引用队列中。当垃圾回收器准备回收一个对象时，会先执行对象的finallize()方法，如果finalize()方法中没有重新让对象与其他对象建立联系，那么这个对象就会被回收，并且它的Final引用会被加入到引用队列中。Final引用通常用于对象回收后的清理工作</li></ol></li><li>软引用、弱引用和虚引用则是用于管理一些比较特殊的对象。使用引用队列可以方便地跟踪这些特殊对象的垃圾回收状态，帮助我们及时释放对象占用的资源。</li><li>使用引用队列来管理这些特殊对象的方式是，在创建这些对象时，同时指定一个引用队列。当垃圾回收器回收这些对象时，会自动将其添加到与之关联的引用队列中。我们可以在某个时刻检查引用队列中是否有特殊对象，并对其进行处理，比如将其从相应的数据结构中删除，以便释放特殊对象占用的资源。</li></ul><h3 id="软引用应用"><a href="#软引用应用" class="headerlink" title="软引用应用"></a>软引用应用</h3><ul><li>前面说软引用通常用于实现内存敏感的缓存，那现在我们来演示一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加VM参数-Xmx20m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_18</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>上面的代码中，由于我们设置堆内存为20M，而代码中5次循环也需要20M的内存，所以到最后肯定会报内存溢出的错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.demo.Demo_18.main(Demo_18.java:20)</span><br></pre></td></tr></table></figure></li><li>强引用会报堆内存错误，那我们来试试弱引用，前面说弱引用会在内存不足时被垃圾回收器回收，那我们额外添加两个VM参数，监测垃圾回收情况<code>-XX:+PrintGCDetails</code>、<code>-verbose:gc</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示软引用</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_18</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">/*        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 15; i++) &#123;</span></span><br><span class="line"><span class="comment">            list.add(new byte[_4MB]);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        soft();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[B@27c170f0</span><br><span class="line">1</span><br><span class="line">[B@5451c3a8</span><br><span class="line">2</span><br><span class="line">[B@2626b418</span><br><span class="line">3</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(6144K)] 14495K-&gt;13153K(19968K), 0.0031771 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] </span><br><span class="line">[B@5a07e868</span><br><span class="line">4</span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4704K-&gt;4704K(6144K)] 17362K-&gt;17378K(19968K), 0.0012234 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4704K-&gt;4500K(6144K)] [ParOldGen: 12673K-&gt;12634K(13824K)] 17378K-&gt;17135K(19968K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0054571 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4500K-&gt;4500K(6144K)] 17135K-&gt;17167K(19968K), 0.0007514 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4500K-&gt;0K(6144K)] [ParOldGen: 12666K-&gt;733K(8704K)] 17167K-&gt;733K(14848K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0063756 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[B@76ed5528</span><br><span class="line">5</span><br><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li><li>我们来分析一下运行结果<ul><li>前三次循环时内存充足，没有触发垃圾回收。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[B@27c170f0</span><br><span class="line">1</span><br><span class="line">[B@5451c3a8</span><br><span class="line">2</span><br><span class="line">[B@2626b418</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li><li>但是第四次循环时，内存已经很紧张了，所以回收了一些新生代的内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(6144K)] 14495K-&gt;13153K(19968K), 0.0031771 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] </span><br><span class="line">[B@5a07e868</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li>第五次循环时，一次垃圾回收后，内存空间仍然不足，然后又触发了一次垃圾回收，回收了大部分新生代和老年代的内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4704K-&gt;4704K(6144K)] 17362K-&gt;17378K(19968K), 0.0012234 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4704K-&gt;4500K(6144K)] [ParOldGen: 12673K-&gt;12634K(13824K)] 17378K-&gt;17135K(19968K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0054571 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4500K-&gt;4500K(6144K)] 17135K-&gt;17167K(19968K), 0.0007514 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4500K-&gt;0K(6144K)] [ParOldGen: 12666K-&gt;733K(8704K)] 17167K-&gt;733K(14848K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0063756 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[B@76ed5528</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li><li>其代价就是将前四个byte数组占据的内存释放掉了，只保留了第五次循环时的byte数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li></ul></li><li>软连接在内存敏感的程序下的好处，当内存空间比较有限时，一些不重要的对象可以用软连接去管理它，当空间紧张时，就可以将它释放掉</li></ul><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><ul><li>前面说软引用可以配合引用队列来释放软引用自身，用下面的代码来演示一下（其实就是上面的代码修改了一下），注意添加VM参数<code>-Xmx20m -XX:+PrintGCDetails -verbose:gc</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示软引用, 配合引用队列, VM参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_19</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============下面输出引用队列中的软引用对象============&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行上面的代码，结果如下，软引用对象只剩一个，符合我们的预期<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[B@27c170f0</span><br><span class="line">1</span><br><span class="line">[B@5451c3a8</span><br><span class="line">2</span><br><span class="line">[B@2626b418</span><br><span class="line">3</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(6144K)] 14495K-&gt;13087K(19968K), 0.0011815 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[B@5a07e868</span><br><span class="line">4</span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4704K-&gt;4704K(6144K)] 17296K-&gt;17352K(19968K), 0.0008897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4704K-&gt;4549K(6144K)] [ParOldGen: 12647K-&gt;12585K(13824K)] 17352K-&gt;17135K(19968K), [Metaspace: 3359K-&gt;3359K(1056768K)], 0.0051949 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4549K-&gt;4549K(6144K)] 17135K-&gt;17183K(19968K), 0.0007508 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4549K-&gt;0K(6144K)] [ParOldGen: 12633K-&gt;733K(8704K)] 17183K-&gt;733K(14848K), [Metaspace: 3359K-&gt;3359K(1056768K)], 0.0058980 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[B@76ed5528</span><br><span class="line">5</span><br><span class="line">============下面输出引用队列中的软引用对象==============</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li><li>但如果我们不移除队列中无用的引用对象，那么输出结果是这样的，队列中存储的null会占据存储空间，最终可能会导致内存泄漏，所以我们一定要记得手动移除队列中无用的引用对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============下面输出引用队列中的软引用对象===========</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><ul><li><p>标记清除是一种常见的垃圾回收算法之一，其工作原理如下：</p><ol><li><code>标记阶段（Mark）</code>：从根对象开始遍历内存中的所有对象，将所有能够被访问到的对象做上标记，表示这些对象是活动的。</li><li><code>清除阶段（Sweep）</code>：遍历整个内存空间，将未被标记的对象视为垃圾，将其占用的内存资源进行回收。</li></ol></li><li><p>标记清除算法的优点在于它简单易用，可以快速地回收大量的垃圾对象。但是，它也存在一些缺点，例如在清除和压缩阶段中可能会产生较大的内存碎片，从而影响后续的内存分配效率。此外，标记清除算法无法处理循环引用的情况，需要借助其他算法来处理循环引用问题，例如标记-压缩算法和复制算法等。</p></li></ul><p><img src="https://s1.ax1x.com/2023/04/02/ppflgm9.png" alt=""></p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><ul><li>在标记整理算法中，标记和清除阶段和标记清除算法是一样的，只有在内存整理阶段不同。在整理阶段，标记整理算法会将所有存活的对象向内存的一端移动，之后将移动后的内存末尾地址作为堆的新起始地址，之前的地址空间被标记为空闲，可以用来分配新的对象。</li><li>需要注意的是，标记整理算法的整理阶段可能会比较耗时，因为它需要移动对象，这也是它的一个缺点。但是，由于它可以消除内存碎片，提高内存利用率，所以在需要长时间运行的应用程序中，标记整理算法通常比标记清除算法更加适用。<br><img src="https://s1.ax1x.com/2023/04/02/ppf1MnJ.png" alt=""></li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul><li>复制算法是一种基于内存分区的垃圾回收算法，它将内存分成两个区域：From空间和To空间。在正常情况下，所有的对象都被分配在From空间中。当需要进行垃圾回收时，算法会扫描From空间中的所有对象，并将存活的对象复制到To空间中。复制完成后，From空间中的对象都可以被视为垃圾，并可以被回收。</li><li>接下来，详细介绍一下复制算法的工作原理：<ol><li><code>内存分配：</code>在程序运行过程中，对象的内存分配只在From空间中进行。当From空间快要用完时，算法会触发一次垃圾回收操作。</li><li><code>扫描存活对象：</code>在进行垃圾回收时，算法会遍历From空间中的所有对象，并标记存活的对象。为了标记存活对象，复制算法使用了一种叫做<code>可达性分析</code>的技术，这个技术可以判断一个对象是否是存活对象。与标记清除算法和标记整理算法不同的是，复制算法并不需要进行标记和清除的分离过程，因为复制算法是将存活对象复制到To空间中，所以只要扫描完From空间中的所有对象，并将存活对象复制到To空间中，就可以直接清除From空间了。</li><li><code>复制存活对象：</code>在扫描存活对象之后，算法会将所有存活对象从From空间复制到To空间。复制的过程是按照对象的存活顺序进行的，也就是说，如果对象A引用了对象B，那么对象B会被先复制到To空间中。复制完成后，To空间的使用量会变得很满，From空间的使用量则变得很少。</li><li><code>交换空间：</code>在复制完所有存活对象之后，From空间中剩余的对象都可以视为垃圾，并可以被回收。为了保证下一次的内存分配，To空间和From空间会进行交换，也就是说，To空间成为了新的From空间，From空间成为了新的To空间。这样一来，内存分配就可以在新的From空间中进行了。</li></ol></li></ul><p><img src="https://s1.ax1x.com/2023/04/02/ppf18tx.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>总结一下这三种垃圾回收算法的优缺点<ol><li><code>标记清除：</code>速度较快，但会产生内存碎片</li><li><code>标记整理：</code>速度较慢，但是不会产生内存碎片</li><li><code>复制：</code>不会产生内存碎片，但是需要占用双倍内存空间</li></ol></li></ul><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><ul><li>JVM（Java虚拟机）的分代垃圾回收是一种优化内存回收的技术。它利用对象的生命周期来将堆（heap）分为不同的区域，然后针对不同区域的特点采用不同的垃圾回收算法。<br><img src="https://s1.ax1x.com/2023/04/02/ppf8hYq.png" alt=""></li><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发<code>minor gc</code>，<code>伊甸园</code>和<code>from</code>存活的对象使用<code>copy</code>复制到<code>to</code>中，存活的对象年龄<code>+1</code>并且交换<code>from</code>和<code>to</code></li><li><code>minor gc</code>会引发<code>stop the world（砸瓦鲁多！！）</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15<ul><li>Java中的对象头中确实分配了一定的字节用来记录对象的年龄，而这个字节的位数是4，因此其二进制最大值为1111，即十进制的15</li></ul></li><li>当老年代空间不足，会先尝试触发<code>minor gc</code>，如果之后空间仍不足，那么触发<code>full gc</code>，STW的时间更长</li></ul><h2 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">含义</th><th style="text-align:center">参数</th></tr></thead><tbody><tr><td style="text-align:center">堆初始大小</td><td style="text-align:center">-Xms</td></tr><tr><td style="text-align:center">堆最大大小</td><td style="text-align:center">-Xmx 或 -XX:MaxHeapSize=size</td></tr><tr><td style="text-align:center">新生代大小</td><td style="text-align:center">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td></tr><tr><td style="text-align:center">幸存区比例（动态）</td><td style="text-align:center">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td style="text-align:center">幸存区比例</td><td style="text-align:center">-XX:SurvivorRatio=ratio</td></tr><tr><td style="text-align:center">晋升阈值</td><td style="text-align:center">-XX:MaxTenuringThreshold=threshold</td></tr><tr><td style="text-align:center">晋升详情</td><td style="text-align:center">-XX:+PrintTenuringDistribution</td></tr><tr><td style="text-align:center">GC 详情</td><td style="text-align:center">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td style="text-align:center">Full GC 前 Minor GC</td><td style="text-align:center">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table></div><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="串行收集器（Serial收集器）"><a href="#串行收集器（Serial收集器）" class="headerlink" title="串行收集器（Serial收集器）"></a>串行收集器（Serial收集器）</h2><ul><li>这是最简单的垃圾回收器，它通过一个单线程进行垃圾回收，因此它的优点是简单高效，但缺点是在大型应用程序中可能会出现停顿时间过长的问题。</li><li>串行收集器的缺点主要是单线程执行垃圾回收操作，不能充分利用多核CPU的计算能力，同时垃圾回收操作会阻塞应用程序的运行，可能会导致长时间的停顿。因此，在大型的、多线程的应用程序中，通常不适合使用串行收集器进行垃圾回收。</li><li><p>对应的VM参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></p></li><li><p>下图中，其他CPU需要等待<code>CPU 2</code>执行完垃圾回收后，才能继续运行<br><img src="https://s1.ax1x.com/2023/04/02/ppfDKTf.png" alt=""></p></li></ul><h2 id="吞吐量优先收集器（Parallel收集器）"><a href="#吞吐量优先收集器（Parallel收集器）" class="headerlink" title="吞吐量优先收集器（Parallel收集器）"></a>吞吐量优先收集器（Parallel收集器）</h2><ul><li>JDK 1.8 默认采用的就是这种垃圾回收器</li><li>它是一种基于多线程并行执行的垃圾回收器，它的主要目标是提高应用程序的吞吐量，即在单位时间内处理更多的请求。</li><li>相关VM参数<ol><li><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC：</code><ul><li>这两个参数分别用于开启并行垃圾回收器和并行老年代垃圾回收器。其中，-XX:+UseParallelGC用于开启并行垃圾回收器，-XX:+UseParallelOldGC用于开启并行老年代垃圾回收器。使用这两个参数可以开启Parallel收集器。</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy：</code><ul><li>这个参数用于自适应地调整Java堆大小和垃圾收集器的参数，以达到更好的垃圾回收效果。当开启该参数时，JVM会自动调整Eden区、Survivor区、老年代的大小以及垃圾回收线程的数量等参数，以达到更高的垃圾回收效率。</li></ul></li><li><code>-XX:GCTimeRatio=ratio：</code><ul><li>这个参数用于设置垃圾回收所占用CPU时间和应用程序运行时间的比率。默认值是99，表示垃圾回收时间最多可以占用1%的CPU时间，计算公式为<code>1/(1 + ratio)</code></li></ul></li><li><code>-XX:MaxGCPauseMillis=ms：</code><ul><li>这个参数用于设置最大垃圾回收暂停时间。默认值是200ms。如果设置该参数，JVM会尽可能地控制垃圾回收暂停的时间不超过该值。如果需要更短的垃圾回收暂停时间，则可以将该值设置为较小的数值。</li></ul></li><li><code>-XX:ParallelGCThreads=n：</code><ul><li>这个参数用于设置垃圾回收线程的数量。默认值是CPU核心数的1/4。可以根据应用程序的需求和硬件环境来调整该参数的值，以达到更好的垃圾回收效果。</li></ul></li></ol></li></ul><p><img src="https://s1.ax1x.com/2023/04/03/pphfXnO.png" alt=""></p><h2 id="CMS收集器（响应时间优先）"><a href="#CMS收集器（响应时间优先）" class="headerlink" title="CMS收集器（响应时间优先）"></a>CMS收集器（响应时间优先）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>CMS（Concurrent Mark Sweep）是一种垃圾回收算法，它的设计目标是在最短的停顿时间内回收垃圾。它通过在一个线程中进行垃圾回收并在应用程序线程中同时运行，从而减少停顿时间。下面详细介绍CMS垃圾收集器的工作原理和优缺点。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>CMS垃圾收集器的工作可以分为以下几个阶段：<ol><li>初始标记阶段（Initial Marking）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且在内存中标记出所有被直接引用的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><li>并发标记阶段（Concurrent Marking）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时标记出所有被间接引用的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li><li>重新标记阶段（Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发标记阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><li>并发清除阶段（Concurrent Sweeping）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时清除所有标记为垃圾的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li><li>最终标记阶段（Final Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发清除阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li></ol></li></ul><p><img src="https://s1.ax1x.com/2023/04/03/pph4Ca4.png" alt=""></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ol><li>可以在最短的停顿时间内回收垃圾，不会出现长时间的停顿现象，因此适合响应时间比较敏感的应用程序。</li><li>采用并发的垃圾收集方式，能够与应用程序并发执行，不会阻塞应用程序的执行，因此对于需要保证应用程序响应性能的场景非常适用。</li></ol></li><li><p>缺点</p><ol><li>对 CPU 的使用比较敏感，在高负载情况下可能会影响应用程序的性能。</li><li>由于并发清除阶段无法整理内存，可能会出现内存碎片化的问题，导致后续垃圾回收过程需要更多的时间。</li><li>在处理大量的垃圾时可能会导致应用程序的性能下降，因为需要占用一定的 CPU 资源。</li></ol></li></ul><h3 id="相关VM参数-1"><a href="#相关VM参数-1" class="headerlink" title="相关VM参数"></a>相关VM参数</h3><ol><li><code>-XX:ParallelGCThreads=n：</code><ul><li>指定并行垃圾回收器的线程数。默认值是处理器核心数。</li></ul></li><li><code>-XX:ConcGCThreads=threads：</code><ul><li>指定并发垃圾回收器的线程数。默认值是处理器核心数的<code>1/4</code>。</li></ul></li><li><code>-XX:CMSInitiatingOccupancyFraction=percent：</code><ul><li>指定 CMS 垃圾回收器开始执行垃圾回收的阈值。当老年代空间使用达到指定百分比时，CMS 垃圾回收器会开始执行垃圾回收。</li></ul></li><li><code>-XX:+CMSScavengeBeforeRemark：</code><ul><li>启用 CMS 垃圾回收器在进行重新标记之前执行新生代的垃圾回收。这可以减少重新标记的时间，从而减少应用程序暂停的时间。</li></ul></li></ol><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>G1（Garbage-First）是一种现代化的垃圾回收器，它在<code>JDK 7</code>中首次引入，并在<code>JDK 9</code>中被标记为默认垃圾回收器。<ul><li>与之前的垃圾回收器相比，G1的最大优势在于它可以更好地处理占据大量堆内存的Java应用程序，从而避免了传统垃圾回收器在大内存情况下可能出现的停顿</li></ul></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>G1采用了一种不同于传统垃圾回收器的回收方式，它将内存划分为大小相等的多个区域（Region），每个区域的大小通常为<code>1MB</code>到<code>32MB</code>。G1将这些区域分为新生代和老年代，其中新生代通常占整个堆内存的5%到10%，老年代则占90%到95%。</li><li>G1将堆内存划分为多个区域后，它就可以对每个区域分别进行垃圾回收，从而避免了FULL GC带来的长时间停顿。</li></ul><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>G1的垃圾回收流程如下  <ol><li><code>初始标记（Initial Mark）：</code>G1在此阶段会扫描堆内存中的根对象，并标记所有的根对象，以便后续回收时可以快速定位到这些根对象</li><li><code>并发标记（Concurrent Mark）：</code>在此阶段，G1会与应用程序并发的执行，扫描堆内存中的所有存活对象，并标记这些对象。在整个过程中，应用程序可以继续执行，因此在这个阶段不会产生长时间的停顿</li><li><code>确定标记（Remark）：</code>在并发标记结束后，G1需要在一个短暂的停顿期间重新扫描堆内存，以便确定所有的存活对象已经被标记</li><li><code>清除（Cleanup）：</code>在确定标记阶段结束后，G1会对未标记的区域进行回收，并将回收得到的空闲区域加入到空闲列表中，以便下次回收内存时使用</li></ol></li></ul><h3 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h3><ul><li><p>在G1垃圾回收器中，垃圾回收的过程可以分为三种阶段：<code>Young Collection</code>、<code>Young Collection + Concurrent Mark</code>（简称Young Collection + CM）和<code>Mixed Collection</code>。<br><img src="https://s1.ax1x.com/2023/04/03/pphHKdf.png" alt=""></p></li><li><p>下面我们分别介绍一下这三种垃圾回收阶段和特点：</p><ol><li><p><code>Young Collection</code>（年轻代垃圾回收）</p><ul><li>Young Collection是指对年轻代（Young Generation）的垃圾回收。在G1垃圾回收器中，年轻代通常是由几个连续的Region组成的。在年轻代垃圾回收期间，G1垃圾回收器会扫描年轻代内的所有对象，并标记那些被引用的对象。然后，它会将未被引用的对象回收掉，并将被引用的对象移动到下一个垃圾回收周期的存活区域（Survivor Region）中。<br><img src="https://s1.ax1x.com/2023/04/03/pphH2ex.png" alt=""></li></ul></li><li><p><code>Young Collection + Concurrent Mark</code>（年轻代垃圾回收 + 并发标记）</p><ul><li>Young Collection + CM是：指在<code>Young GC</code>时会进行<code>GC Root</code>的初始标记，当老年代占用堆空间比例达到阈值时，对整个堆内存进行并发标记。由下面的VM参数决定<ul><li>-XX:InitiatingHeapOccupancyPercent=percent （默认45%）</li></ul></li><li>在并发标记过程中，G1垃圾回收器会扫描所有的可达对象，并标记它们。并发标记可以与应用程序并行进行，不会停顿应用程序的线程。当并发标记完成后，G1垃圾回收器就可以知道哪些对象是存活的，哪些对象是垃圾了。<br><img src="https://s1.ax1x.com/2023/04/03/pphHWTK.png" alt=""></li></ul></li><li><p><code>Mixed Collection</code>（混合垃圾回收）</p><ul><li>Mixed Collection是指对整个堆内存进行垃圾回收，包括年轻代和老年代（Old Generation）的垃圾回收。在Mixed Collection期间，G1垃圾回收器会尽可能地回收那些垃圾占用空间较大的Region，并将它们标记为”空闲”状态，以便在以后的内存分配中使用。与Young Collection不同，Mixed Collection不仅回收年轻代的对象，还回收老年代的对象，因此它需要更长的停顿时间。同时，Mixed Collection也会和并发标记一起执行，以最小化应用程序的停顿时间。<br><img src="https://s1.ax1x.com/2023/04/03/pphH4YD.png" alt=""></li></ul></li></ol></li><li><p>新生代内存不足发生的垃圾收集：minor gc</p></li><li>当G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发FULL GC。</li></ul><h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><ul><li>当进行新生代垃圾回收时，需要找到新生代对象的跟对象来确定哪些对象是存活的，那些对象需要被回收。然而根对象中可能有一部分存活在老年代中，如果每次都要遍历老年代来查找这些根对象，将会导致效率低下</li><li>为了解决这个问题，G1垃圾回收器采用了一种卡表技术，将老年代划分为多个区域，并将每个区域划分为一组成为<code>卡</code>的块。每个卡的大小约为512KB，如果老年代中的一个对象引用了新生代中的对象，那么该卡就被标记为脏卡</li><li>在新生代对象引用发生变化时，使用post-write barrier和dirty card queue技术来更新卡表，将引用变更信息添加到Remembered Set中，标记为脏卡</li><li>在进行新生代垃圾回收时，只需要扫描这些脏卡中的对象，即可找到所有的跨代引用对象，避免了对整个老年代进行遍历的开销，提高了垃圾回收的效率。<br><img src="https://s1.ax1x.com/2023/04/04/pp4XhcD.png" alt=""></li></ul><h3 id="重新标记阶段"><a href="#重新标记阶段" class="headerlink" title="重新标记阶段"></a>重新标记阶段</h3><ul><li>在G1垃圾回收器的remark阶段中，它使用三色标记法来标记存活对象，并结合SATB和写屏障来跟踪对象的引用关系，以便在标记阶段中更准确地标记存活对象。</li><li>remark阶段开始时，G1垃圾回收器会将所有被标记为灰色的对象加入到处理队列中，然后开始遍历处理队列中的对象。对于每个灰色对象，G1垃圾回收器会扫描其所有引用域，并将任何未被标记为黑色的引用加入到SATB中，以便在后续标记阶段中更准确地跟踪引用关系。</li><li>同时，在遍历处理队列中的对象时，G1垃圾回收器会将灰色对象的引用对象标记为灰色，将灰色对象标记为黑色，并将其从处理队列中移除。这个过程会一直持续，直到处理队列中不再有灰色对象。</li><li>在remark阶段中，SATB写屏障起到了重要作用。当程序在运行时修改一个对象的引用时，SATB写屏障会记录这个修改，并将相关信息保存到一个记录缓存中。在remark阶段中，G1垃圾回收器会遍历记录缓存中所有被标记为脏的对象，并遍历这些对象的引用域，以确定它们所引用的对象是否需要被标记为灰色。</li><li>通过三色标记法、SATB和写屏障的结合使用，G1垃圾回收器可以更准确地标记存活对象，并且在标记阶段中只标记那些需要被标记的对象，从而提高垃圾回收器的性能和效率。</li></ul><h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><ul><li><p>当新生代中的对象被晋升到老年代时，如果这些对象是字符串类型，那么会将它们放入一个特殊的队列中，而不是直接将它们放入老年代中。这个队列称为String Deduplication Queue，可以理解为字符串去重队列。</p></li><li><p>G1垃圾回收器在remark阶段中会扫描String Deduplication Queue中的所有字符串，检查是否有重复的字符串。如果发现有重复的字符串，就会让它们引用同一个<code>char[]</code>，以达到字符串去重的目的。需要注意的是，这里去重的对象是<code>char[]</code>，而不是String对象本身，与<code>String.intern()</code>不同。</p></li><li><p>为了实现这一功能，G1垃圾回收器内部维护了一个字符串表，用来存储所有已经去重的<code>char[]</code>。当遍历String Deduplication Queue时，G1垃圾回收器会将每个字符串的<code>char[]</code>进行哈希，然后在字符串表中查找是否存在相同哈希值的<code>char[]</code>，如果存在，就会比较这两个<code>char[]</code>的内容是否相同，从而确定是否是同一个字符串。如果是同一个字符串，就将这个字符串对象的引用指向字符串表中的<code>char[]</code>，从而达到字符串去重的目的。</p></li><li><p>总之，G1垃圾回收器的字符串去重功能可以大幅度减少堆内存中的重复字符串，从而降低垃圾回收器的内存占用和垃圾回收的开销，提高程序的性能。</p><ul><li>优点：节省大量内存</li><li>缺点：稍微多占用了CPU时间，新生代回收时间略微增加</li></ul></li></ul><h3 id="并发标记类卸载"><a href="#并发标记类卸载" class="headerlink" title="并发标记类卸载"></a>并发标记类卸载</h3><ul><li>在 G1 垃圾回收器进行并发标记后，它可以识别出哪些类不再被使用。当一个类加载器的所有类都不再被使用时，就可以卸载该类加载器所加载的所有类。</li><li>G1 垃圾回收器默认开启了类卸载功能，可以通过 <code>JVM</code> 参数 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 显式启用。</li></ul><h3 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h3><ul><li>对象大小超过了G1 Heap中的Region大小的一半时，被称为巨型对象（Huge Object）。</li><li>G1不会将巨型对象分配到Region中，而是直接分配在Humongous区域中。Humongous区域是一组连续的Region，大小为2的幂次方倍。如果一个巨型对象的大小超过了Humongous区域的大小，则会跨越多个Humongous区域。</li><li>在标记阶段，G1会优先处理巨型对象，以便在回收过程中更好地利用它们的空间。这样可以避免因巨型对象被其他对象占用而导致的内存浪费。</li><li>在G1中，老年代中所有的incoming引用会被跟踪，如果某个巨型对象的incoming引用计数为0，说明该对象不再被其他对象引用，可以直接被回收。这个过程发生在新生代回收之前，可以帮助释放空间。<br><img src="https://s1.ax1x.com/2023/04/04/pp4zsxK.png" alt=""></li></ul><h3 id="并发表及起始时间调整"><a href="#并发表及起始时间调整" class="headerlink" title="并发表及起始时间调整"></a>并发表及起始时间调整</h3><ul><li>前面说如果G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发<code>FULL GC</code>。</li><li>并发标记阶段是 G1 垃圾回收的一个重要阶段，需要在堆空间占满之前完成，否则就会退化为 FullGC。为了避免这种情况的发生，JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数来手动设置并发标记的触发阈值（默认为45%），以确保在这个阈值之前就完成并发标记。而在 JDK 9 及以后的版本中，可以根据实际情况动态调整并发标记的触发阈值，以避免 <code>Full GC</code> 的发生。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数用于设置并发标记的初始触发阈值，但是 G1 在进行并发标记时会进行数据采样，并根据采样数据动态调整并发标记的触发阈值，以确保并发标记可以在堆空间不被填满的情况下完成。同时，G1 还会在堆空间中留出一定的安全空档空间，以避免因为堆空间占满而触发 <code>Full GC</code>。</li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：<ol><li><code>分区回收：</code>G1将堆内存划分为多个区域，并对每个区域分别进行回收，从而避免<code>FULL GC</code>带来的长时间停顿</li><li><code>并发回收：</code>G1在标记和清除阶段都可以与应用程序并发执行，从而避免了长时间的停顿</li><li><code>预测性停顿：</code>G1可以根据应用程序的内存使用情况预测合适需要进行<code>FULL GC</code>，从而在垃圾回收过程中尽可能地减少停顿时间</li><li><code>空间整合：</code>G1可以在回收过程中对空间进行整合，从而可以更好的利用堆内存</li><li><code>可预测性：</code>G1可以设置预期的停顿时间，以便开发人员可以更好地控制应用程序的性能</li></ol></li><li>缺点<ol><li>初始标记和确定标记阶段需要短暂的停顿时间，虽然停顿时间短暂，但是仍然可能影响应用程序的性能</li><li>G1需要更多的CPU资源来完成垃圾回收，因为它需要同时处理多个分区</li><li>对于小型应用程序，G1可能会产生过多的内存分配和垃圾回收开销，从而导致应用程序性能下降</li></ol></li></ul><h1 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ol><li>掌握GC相关的VM参数，会基本的空间调整</li><li>掌握相关工具<ul><li><code>jsp</code></li><li><code>jmap</code></li><li><code>jconsole</code></li><li><code>jvisualvm</code></li></ul></li><li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则，都是具体情况具体分析</li></ol><h2 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h2><ul><li>JVM的GC调优是Java应用程序性能调优的一个重要方面。在进行GC调优之前，需要先确定应用程序的性能瓶颈，通常可以从内存、锁竞争、CPU占用和IO等方面入手进行调优。</li></ul><ol><li><code>内存调优</code><ul><li>内存调优主要是针对JVM的堆内存和非堆内存进行调优。在Java应用程序中，大部分的对象都是分配在堆内存中的。因此，对于堆内存的调优非常重要。</li><li>如果堆内存的大小设置过小，就会频繁地进行垃圾回收，导致应用程序的性能下降。如果堆内存的大小设置过大，就会浪费系统资源。</li><li>对于非堆内存，可以考虑调整JVM的元空间大小来减少元数据的内存占用。</li></ul></li><li><p><code>锁竞争调优</code></p><ul><li>Java中的锁机制是实现并发的重要手段，但是锁的竞争会导致应用程序的性能下降。因此，锁竞争调优是Java应用程序性能调优的一个重要方面。</li><li>可以通过使用synchronized关键字和Lock接口来进行锁竞争调优。synchronized关键字是Java中实现锁的一种简单方式，但是在高并发场景下，由于锁粒度较大，容易导致锁竞争。</li><li>因此，在高并发场景下，可以考虑使用Lock接口来实现锁。Lock接口支持更细粒度的锁，并且可以控制锁的获取和释放。</li></ul></li><li><p><code>CPU占用调优</code></p><ul><li>CPU占用调优是指通过优化代码来减少CPU的占用率，提高应用程序的性能。</li><li>可以通过以下方式来进行CPU占用调优：<ol><li><code>减少线程数：</code>线程数过多会导致CPU占用率上升，因此可以通过减少线程数来降低CPU占用率。</li><li><code>避免无用循环：</code>无用循环会导致CPU占用率上升，因此可以通过优化代码来减少无用循环的出现。</li><li><code>避免递归调用：</code>递归调用会导致CPU占用率上升，因此可以通过优化代码来避免递归调用的出现。</li></ol></li></ul></li><li><code>IO调优</code><ul><li>IO调优是指通过优化IO操作来提高应用程序的性能。</li><li>可以通过以下方式来进行IO调优：<ol><li><code>减少IO操作：</code>减少IO操作可以减少IO调用的次数，从而提高应用程序的性能。</li><li><code>使用缓存：</code>缓存可以减少IO调用的次数，从而提高应用程序的性能。</li><li><code>使用异步IO：</code>异步IO可以在IO操作期间释放CPU资源，从而提高应用程序的性能。</li></ol></li></ul></li></ol><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><ul><li>我们首先要清楚我们的应用程序是干什么的，即确定一个垃圾回收的目标<ul><li>如果是做一些科学运算、批量处理，那么追求的就是高吞吐量，延长一点点响应时间对我们没有太大影响</li><li>如果是做一些互联网、金融、电子商务项目，那么响应时间就是一个非常重要的指标了，如果每次垃圾回收都延长了响应时间，就会给用户造成不好的体验</li></ul></li><li>确定了目标以后，我们再来选择合适的垃圾回收器<ul><li>对于高吞吐量的应用程序，通常可以选择 <code>Parallel GC</code> 等并行垃圾回收器来实现高效的垃圾回收。</li><li>而对于需要低延迟、高响应时间的应用程序，可以选择 <code>CMS</code>、<code>G1</code>、<code>ZGC</code>、<code>Zing</code> 等低延迟垃圾回收器来实现。</li></ul></li></ul><h2 id="最快的GC"><a href="#最快的GC" class="headerlink" title="最快的GC"></a>最快的GC</h2><ul><li>最快的GC是不发生GC，即尽可能减少内存分配和回收的次数。因此，建议在代码中尽量避免频繁地创建和销毁对象，或者使用不必要的大型数据结构。</li><li>查看<code>FULL GC</code>前后的内存占用，考虑以下几个问题<ol><li>数据是不是太多？<ul><li>例如下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 大表</span><br></pre></td></tr></table></figure></li><li>查询大表时，如果数据量太大，会占用大量的内存空间，导致频繁的GC，甚至可能直接内存溢出，建议在查询时加上限制条件（如limit）来减小数据量。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 大表 LIMIT n</span><br></pre></td></tr></table></figure></li></ul></li><li>数据表示是否太臃肿？<ul><li>如果数据结构过于庞大，例如包含大量不必要的字段或者对象引用，也会占用大量内存空间。</li><li>例如在Java中，Integer是一个对象，而int是一个基本数据类型。因此，当我们使用Integer时，实际上是创建了一个对象来存储整数值。相对地，使用int时，只需要直接在栈上分配一个内存空间来存储整数值，不需要再创建对象，因此内存占用更小。<ul><li>Integer对象占用的内存空间包含了对象头、对象的值等信息，一般需要占据16个字节</li><li>而int类型只需要占用4个字节的内存空间。</li></ul></li></ul></li><li>是否存在内存泄露？<ul><li>例如我们创建一个静态的Map对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li>一直向静态Map中存储数据，会导致静态Map中的内存占用越来越大，可能导致频繁的GC和内存溢出。因为静态变量属于类，不会被垃圾回收器自动释放。这种情况可以使用软引用或弱引用来引用该对象，以便在内存不足时自动释放缓存数据。</li><li>但还是不建议使用Java来实现缓存，而是推荐使用第三方缓存实现，例如Redis等</li></ul></li></ol></li></ul><h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><ul><li>在新生代调优之前，我们先来回顾一下新生代的特点<ol><li>所有的new操作的内存分配都非常廉价，即分配速度很快。</li><li>死亡对象的回收：Java虚拟机有自动垃圾回收机制，用于回收不再被使用的对象。在新生代中，回收死亡对象的代价为零，因为它们可以很容易地被回收。</li><li>大部分对象用过即死：大部分对象的生命周期很短，使用一次就被丢弃了，这是因为Java中的对象通常用于执行一些特定的任务，而不是被持续使用。</li><li>Minor GC：Java虚拟机会周期性地进行垃圾回收操作，其中一种是Minor GC，用于回收新生代中的对象。由于新生代中的对象生命周期短，因此Minor GC的时间通常比Full GC（用于回收老年代中的对象）短很多。</li></ol></li><li><p>调优参数：<code>-Xmn</code>设置新生代大小</p><ul><li>那么是设置的越大越好吗？不是的，官方文档中给出的解释如下<div class="note info no-icon flat"><ul><li>-Xmn<ul><li>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC isperformed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</li><li>设置新生代堆的初始大小和最大大小（以字节为单位）。垃圾回收在新生代中比其他区域更频繁地进行。如果新生代的大小过小，则会执行很多次<code>Minor GC</code>。如果大小过大，则只执行<code>FULL GC</code>，这可能需要很长时间才能完成。Oracle 建议您将新生代的大小保持在总堆大小的 25% 以上且低于 50%。</li></ul></li></ul></div></li></ul></li><li><p>新生代大小最好能容纳所有<code>并发量 * (请求-响应)</code>的数据</p><ul><li>例如一次请求响应需要<code>512KB</code>内存，并发量为<code>10000</code>，那么差不多就是<code>5GB</code></li></ul></li><li>幸存区要大到能够保留<code>当前活跃的对象 + 需要晋升的对象</code>    <ul><li>如果幸存区过小，JVM会灵活调整晋升的阈值，从而可能导致某些对象被提前晋升到老年代，从而将其从幸存区释放。当幸存区不足以容纳所有存活的对象时，垃圾回收器会选择将一部分对象直接晋升到老年代，而不是等待这些对象达到晋升的阈值再晋升。</li><li>这样做的问题在于，新生代中的对象通常比老年代中的对象生命周期短，如果过早地将这些对象晋升到老年代，可能会导致老年代中存在许多生命周期很短的对象，从而增加垃圾回收的压力，甚至导致堆内存溢出。</li><li>因此，为了变过早地将对象晋升到老年代，通常建议将幸存区设置的足够大，以便能够<code>容纳当前活跃对象与需要晋升对象的总和</code>。这也可以减少对象直接晋升到老年代的情况，提高了年轻代的空间利用率，并减轻垃圾回收的压力。</li></ul></li><li>晋升阈值也要配置得当<ul><li>调整晋升阈值是为了让存活时间较长的对象能尽早进入老年代，这样可以减少在幸存区进行复制操作的次数和数量。</li><li>相关VM参数：<ul><li>调整最大晋升阈值：<code>-XX:MaxTenuringThreshold=threshold</code></li><li>垃圾回收时打印存活对象详情：<code>-XX:+PrintTenuringDistribution</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size 48286924 bytes, new threshold 10 (max 10)</span><br><span class="line">- age 1: 28992024 bytes, 28992024 total</span><br><span class="line">- age 2: 1366864 bytes, 30358888 total</span><br><span class="line">- age 3: 1425912 bytes, 31784800 total</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h2><ul><li>以CMS为例<ul><li>CMS的老年代内存越大越好</li><li>先不进行调优，如果没有发生FULL GC，那么说明程序运行良好，应该先尝试新生代调优</li><li>观察发生FULL GC时老年代内存占用，将老年代内存预设增加 1/4 ~ 1/3。<ul><li>然后逐步调整-XX:CMSInitiatingOccupancyFraction参数的值，找到一个合适的设置值。</li><li>一般来说，可以将该参数设置在75% ~ 85%之间</li></ul></li></ul></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><div class="note info no-icon flat"><ul><li><code>Full GC</code> 和 <code>Minor GC</code> 频繁</li></ul></div><ul><li>如果 <code>Full GC</code> 和 <code>Minor GC</code> 频繁发生<ul><li>那么可能就是我们之前提到过的，幸存区过小，导致某些短生命周期对象晋升到了老年代</li></ul></li><li>可以尝试调整内存分配比例<ul><li>通过调整新生代和老年代的内存分配比例来减少 <code>Minor GC</code> 和 <code>Full GC</code> 的频率。</li><li>一般情况下，新生代的大小应该比老年代小，可以尝试逐步增加新生代的大小，减少老年代的大小</li></ul></li></ul><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><div class="note info no-icon flat"><ul><li>请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</li></ul></div><ul><li>首先我们来分析一下具体是哪部分耗时较长，由于我们采用的是CMS收集器，在 CMS 收集器中，重新标记阶段通常是导致单次暂停时间变长的主要因素之一。</li><li>如果我们在重新标记之前进行一次新生代的垃圾回收，可以减少堆中对象的数量，从而减少重新标记的时间。</li><li>具体使用 <code>-XX:+CMSScavengeBeforeRemark</code> 参数，可以让 CMS 在重新标记之前进行一次新生代的垃圾回收。</li></ul><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><ul><li>老年代充裕情况下，发生 Full GC （CMS jdk1.7）</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(2)</title>
      <link href="/2023/04/25/JVMPart/JVM_2/"/>
      <url>/2023/04/25/JVMPart/JVM_2/</url>
      
        <content type="html"><![CDATA[<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzoLT.png" alt=""></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>JVM中的程序计数器(Program Counter Register)是一块较小的内存空间，它用来保存当前线程下一条要执行的指令的地址。每个线程都有自己独立的程序计数器，它是线程私有的，生命周期与线程相同。程序计数器是JVM中的一种轻量级的内存区域，因为它不会发生内存溢出（OutOfMemoryError）的情况。</li><li>程序计数器的作用在于线程切换后能够恢复到正确的执行位置，也就是下一条需要执行的指令地址。<ul><li>因为在Java虚拟机的多线程环境下，为了支持线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，否则就会出现线程切换后执行位置混乱的问题。</li></ul></li><li>程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError（内存溢出）</code>情况的区域。因为程序计数器是线程私有的，所以它所占用的内存空间非常小，一般不会导致内存溢出的问题。</li><li>程序计数器是JVM中的一种非常重要的内存区域，它是实现Java虚拟机字节码解释器的必要组成部分。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">二进制字节码（JVM指令）               // Java源代码</span><br><span class="line">0: getstatic #20                    // PrintStream out = System.out;</span><br><span class="line">3: astore_1                         // --</span><br><span class="line">4: aload_1                          // out.println(1);</span><br><span class="line">5: iconst_1                         // --</span><br><span class="line">6: invokevirtual #26                // --</span><br><span class="line">9: aload_1                          // out.println(2);</span><br><span class="line">10: iconst_2                        // --</span><br><span class="line">11: invokevirtual #26               // --</span><br><span class="line">14: aload_1                         // out.println(3);</span><br><span class="line">15: iconst_3                        // --</span><br><span class="line">16: invokevirtual #26               // --</span><br><span class="line">19: aload_1                         // out.println(4);</span><br><span class="line">20: iconst_4                        // --</span><br><span class="line">21: invokevirtual #26               // --</span><br><span class="line">24: aload_1                         // out.println(5);</span><br><span class="line">25: iconst_5                        // --</span><br><span class="line">26: invokevirtual #26               // --</span><br><span class="line">29: return</span><br></pre></td></tr></table></figure><ul><li>Java源代码首先编译成二进制字节码，然后交由解释器解释成机器码，最终由CPU执行机器码<ul><li>程序计数器在其中的作用就是记住下一条JVM指令的执行地址，解释器从程序计数器取到下一条指令地址</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>程序计数器<ul><li>作用：保存当前线程下一条要执行的指令的地址</li><li>特点：<ul><li>线程私有</li><li>不存在内存溢出</li></ul></li></ul></li></ul><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzoLT.png" alt=""></p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul><li>Java虚拟机栈（Java Virtual Machine Stacks）是Java虚拟机为每个线程分配的一块内存区域，用于存储线程的方法调用和局部变量等信息。</li><li>每个线程在运行时都有自己的Java虚拟机栈，线程开始时会创建一个新的栈帧（Stack Frame），用于存储该线程的方法调用信息。当方法调用完成后，该栈帧会被弹出，回到上一次方法调用的位置。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>Java虚拟机栈<ol><li>每个线程运行是所需的内存，就称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ol></li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ul><li>我们编写两个简单的方法，在method1中调用method2，然后断点调试，调试窗口的左边就是虚拟机栈<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在第二行打断点，然后F7步入，当我们第一次步入的时候，method1会入栈</li><li>由于我们在method1中调用了method2，所以再次步入时，method2也会入栈，如下图<br><img src="https://s1.ax1x.com/2023/03/27/ppyPbp4.png" alt=""></li><li>当我们点击步出时，method2执行完毕，释放内存，出栈，返回上一次方法调用的位置，即method1</li><li>再次步出，method1执行完毕，释放内存，出栈</li><li>再次步出，main方法执行完毕</li></ul><h3 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h3><div class="note info no-icon flat"><ul><li><code>Q:</code> 垃圾回收是否涉及栈内存？</li></ul></div><div class="note pink no-icon flat"><ul><li><code>A:</code> 垃圾回收通常不涉及栈内存。栈内存是在程序运行时自动分配和释放的，因此不需要垃圾回收来处理。相反，垃圾回收主要关注堆内存中的对象，以及这些对象是否还在被引用。垃圾回收器通常会扫描堆内存中的对象，并标记哪些对象仍然被引用，哪些对象可以被清理。</li></ul></div><div class="note info no-icon flat"><ul><li><code>Q:</code> 栈内存分配越大越好吗？</li></ul></div><div class="note pink no-icon flat"><ul><li><code>A:</code> 栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的<ul><li>Linux/x64（64 位）：1024 KB</li><li>macOS（64 位）：1024 KB</li><li>Oracle Solaris/x64（64 位）：1024 KB</li><li>Windows：默认值取决于虚拟内存</li></ul></li><li>当然我们也可以手动设置线程堆栈大小为1024kb<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure></li><li>栈内存划的越大，会让线程数变少，因为物理内存大小是一定的<ul><li>一个线程用1M，物理内存500M，理论上可以支持500个线程同时运行（但实际还需要一定数量的堆内存和其他系统资源，实际到不了500个线程）</li><li>但如果一个线程设置2M，那么只有250个线程</li></ul></li><li>栈内存划分大了，通常只是能够进行更多次的方法递归调用，而不会增强运行效率，反而会使线程数量变少，一般采用系统默认的栈内存就好</li></ul></div><div class="note info no-icon flat"><ul><li><code>Q:</code> 方法内的局部变量是否线程安全？</li></ul></div><div class="note pink no-icon flat"><ul><li><code>A:</code> 方法内的局部变量通常是线程安全的，因为它们只能在方法内部访问。每个线程都有自己的栈帧，栈帧包含方法的参数、局部变量和返回值等信息，因此不同的线程可以在不相互干扰的情况下同时访问相同的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread thread3 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>上述代码中，我是用三个线程执行method方法，最终的值都会是5000</li><li>但如果此时的x是静态变量，那么结果就大不相同了，最终结果都会大于5000<ul><li>因为static变量是多个线程共享的，它如果不加安全保护的话，就会产生线程安全问题</li></ul></li><li>另外，如果方法内局部变量没有逃离方法的作用范围，那么它是线程安全的。如果局部变量引用了对象，并且逃离了方法的作用范围，需要考虑线程安全</li><li>例如这里的m2方法就不是线程安全的，因为StringBuilder对象是我们外部传入的，主线程和新线程都在修改StringBuilder对象，此时StringBuilder对象就不再是线程私有的，而是多个线程共享的一个对象</li><li>这里的m3方法也不是线程安全的，因为m3方法将StringBuilder对象返回了，其他线程就可以拿到这个StringBuilder对象进行修改</li><li>不过这里的m1方法是线程安全的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">4</span>);</span><br><span class="line">        sb.append(<span class="number">5</span>);</span><br><span class="line">        sb.append(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            m2(sb);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><ul><li>栈内存溢出有两种情况<ol><li>栈帧过多导致栈内存溢出<ul><li>死循环递归<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最终输出的count为<code>23568</code>，也就是此时递归了<code>23568</code>次就内存溢出了</li><li>还记得前面可以修改栈内存吗，现在我们将栈内存设置的小一些，再次执行此方法，只递归了<code>3929</code>次<br><img src="https://s1.ax1x.com/2023/03/27/ppyZTbj.png" alt=""></li></ul></li><li>栈帧过大导致栈内存溢出<ul><li>下面这个例子中，Emp中引入了Dept，而Dept中又引入了Emp，他们现在在循环引用，导致json解析时会出现StackOverFlow<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        Dept d = <span class="keyword">new</span> Dept();</span><br><span class="line">        d.setName(<span class="string">&quot;Market&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Emp e1 = <span class="keyword">new</span> Emp();</span><br><span class="line">        e1.setName(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        e1.setDept(d);</span><br><span class="line"></span><br><span class="line">        Emp e2 = <span class="keyword">new</span> Emp();</span><br><span class="line">        e2.setName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        e2.setDept(d);</span><br><span class="line"></span><br><span class="line">        d.setEmps(Arrays.asList(e1, e2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        System.out.println(mapper.writeValueAsString(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//    @JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dept <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">getEmps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmps</span><span class="params">(List&lt;Emp&gt; emps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emps = emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>需要导的依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>此时就需要我们手动打破这种循环关系，解决方案就是使用<code>@JsonIgnore</code>注解来忽略序列化中的循环引用</li></ul></li></ol></li></ul><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzoLT.png" alt=""></p><ul><li>本地方法栈，我们先来理解一下什么叫<code>本地方法</code><ul><li><code>本地方法</code>是指由非Java语言编写的代码，如C或C++，并被编译为本地二进制代码。</li></ul></li><li>因为<code>JAVA</code>没法直接和操作系统底层交互，所以需要用到本地方法栈来调用本地的C或C++的方法</li><li>例如Object类的源码中就有本地方法，用<code>native</code>关键字修饰本地方法<ul><li>本地方法只有函数声明，没有函数体，因为函数体是C或C++写的，通常是通过JNI（Java Native Interface）技术来实现的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up a single thread that is waiting on this object&#x27;s</span></span><br><span class="line"><span class="comment"> * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment"> * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment"> * the discretion of the implementation. A thread waits on an object&#x27;s</span></span><br><span class="line"><span class="comment"> * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The awakened thread will not be able to proceed until the current</span></span><br><span class="line"><span class="comment"> * thread relinquishes the lock on this object. The awakened thread will</span></span><br><span class="line"><span class="comment"> * compete in the usual manner with any other threads that might be</span></span><br><span class="line"><span class="comment"> * actively competing to synchronize on this object; for example, the</span></span><br><span class="line"><span class="comment"> * awakened thread enjoys no reliable privilege or disadvantage in being</span></span><br><span class="line"><span class="comment"> * the next thread to lock this object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment"> * of this object&#x27;s monitor. A thread becomes the owner of the</span></span><br><span class="line"><span class="comment"> * object&#x27;s monitor in one of three ways:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment"> *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment"> *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Only one thread at a time can own an object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment"> *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object&#x27;s monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object&#x27;s monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The awakened threads will not be able to proceed until the current</span></span><br><span class="line"><span class="comment"> * thread relinquishes the lock on this object. The awakened threads</span></span><br><span class="line"><span class="comment"> * will compete in the usual manner with any other threads that might</span></span><br><span class="line"><span class="comment"> * be actively competing to synchronize on this object; for example,</span></span><br><span class="line"><span class="comment"> * the awakened threads enjoy no reliable privilege or disadvantage in</span></span><br><span class="line"><span class="comment"> * being the next thread to lock this object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment"> * of this object&#x27;s monitor. See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment"> * description of the ways in which a thread can become the owner of</span></span><br><span class="line"><span class="comment"> * a monitor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment"> *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment"> * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The current thread must own this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span></span><br><span class="line"><span class="comment"> * place itself in the wait set for this object and then to relinquish</span></span><br><span class="line"><span class="comment"> * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;</span></span><br><span class="line"><span class="comment"> * becomes disabled for thread scheduling purposes and lies dormant</span></span><br><span class="line"><span class="comment"> * until one of four things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@code</span> notify&#125; method for this</span></span><br><span class="line"><span class="comment"> * object and thread &lt;var&gt;T&lt;/var&gt; happens to be arbitrarily chosen as</span></span><br><span class="line"><span class="comment"> * the thread to be awakened.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@code</span> notifyAll&#125; method for this</span></span><br><span class="line"><span class="comment"> * object.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt() interrupts&#125;</span></span><br><span class="line"><span class="comment"> * thread &lt;var&gt;T&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The specified amount of real time has elapsed, more or less.  If</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> timeout&#125; is zero, however, then real time is not taken into</span></span><br><span class="line"><span class="comment"> * consideration and the thread simply waits until notified.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this</span></span><br><span class="line"><span class="comment"> * object and re-enabled for thread scheduling. It then competes in the</span></span><br><span class="line"><span class="comment"> * usual manner with other threads for the right to synchronize on the</span></span><br><span class="line"><span class="comment"> * object; once it has gained control of the object, all its</span></span><br><span class="line"><span class="comment"> * synchronization claims on the object are restored to the status quo</span></span><br><span class="line"><span class="comment"> * ante - that is, to the situation as of the time that the &#123;<span class="doctag">@code</span> wait&#125;</span></span><br><span class="line"><span class="comment"> * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span></span><br><span class="line"><span class="comment"> * invocation of the &#123;<span class="doctag">@code</span> wait&#125; method. Thus, on return from the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; method, the synchronization state of the object and of</span></span><br><span class="line"><span class="comment"> * thread &#123;<span class="doctag">@code</span> T&#125; is exactly as it was when the &#123;<span class="doctag">@code</span> wait&#125; method</span></span><br><span class="line"><span class="comment"> * was invoked.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A thread can also wake up without being notified, interrupted, or</span></span><br><span class="line"><span class="comment"> * timing out, a so-called &lt;i&gt;spurious wakeup&lt;/i&gt;.  While this will rarely</span></span><br><span class="line"><span class="comment"> * occur in practice, applications must guard against it by testing for</span></span><br><span class="line"><span class="comment"> * the condition that should have caused the thread to be awakened, and</span></span><br><span class="line"><span class="comment"> * continuing to wait if the condition is not satisfied.  In other words,</span></span><br><span class="line"><span class="comment"> * waits should always occur in loops, like this one:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     synchronized (obj) &#123;</span></span><br><span class="line"><span class="comment"> *         while (&amp;lt;condition does not hold&amp;gt;)</span></span><br><span class="line"><span class="comment"> *             obj.wait(timeout);</span></span><br><span class="line"><span class="comment"> *         ... // Perform action appropriate to condition</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * (For more information on this topic, see Section 3.2.3 in Doug Lea&#x27;s</span></span><br><span class="line"><span class="comment"> * &quot;Concurrent Programming in Java (Second Edition)&quot; (Addison-Wesley,</span></span><br><span class="line"><span class="comment"> * 2000), or Item 50 in Joshua Bloch&#x27;s &quot;Effective Java Programming</span></span><br><span class="line"><span class="comment"> * Language Guide&quot; (Addison-Wesley, 2001).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment"> * interrupted&#125; by any thread before or while it is waiting, then an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> InterruptedException&#125; is thrown.  This exception is not</span></span><br><span class="line"><span class="comment"> * thrown until the lock status of this object has been restored as</span></span><br><span class="line"><span class="comment"> * described above.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that the &#123;<span class="doctag">@code</span> wait&#125; method, as it places the current thread</span></span><br><span class="line"><span class="comment"> * into the wait set for this object, unlocks only this object; any</span></span><br><span class="line"><span class="comment"> * other objects on which the current thread may be synchronized remain</span></span><br><span class="line"><span class="comment"> * locked while the thread waits.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment"> * of this object&#x27;s monitor. See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment"> * description of the ways in which a thread can become the owner of</span></span><br><span class="line"><span class="comment"> * a monitor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment"> *               negative.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment"> *               the owner of the object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment"> *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment"> *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment"> *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment"> *             this exception is thrown.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzoLT.png" alt=""></p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><ul><li>JVM的堆（Heap）是Java虚拟机（JVM）在内存中用来存放对象的区域，是Java程序中最大的一块内存区域。JVM的堆被所有线程共享，在JVM启动时就已经被创建，并且一直存在于JVM的整个生命周期中。</li><li>堆可以被分成两部分：新生代（Young Generation）和老年代（Old Generation）。新生代又被进一步分为Eden空间、幸存区From空间和幸存区To空间。</li><li>新生代是用来存放新创建的对象的，其中大部分对象都很快就会被垃圾回收掉。当堆空间不足时，JVM会触发垃圾回收机制（GC），对新生代的对象进行清理。清理过程一般是将存活的对象移到老年代或幸存区，而其余的对象则被回收。</li><li>老年代是用来存放生命周期较长的对象的，这些对象一般是从新生代晋升而来，或者是本身就比较大的对象。老年代的对象存活时间较长，因此垃圾回收的频率比新生代低得多。</li><li>JVM堆的大小可以通过启动JVM时的参数进行调整，如-Xms和-Xmx参数分别控制堆的初始大小和最大大小。如果应用程序需要创建大量的对象，而堆空间不足，则会抛出OutOfMemoryError异常。</li></ul><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul><li>Heap堆<ul><li>通过new关键字创建的对象都会使用堆空间</li></ul></li><li>特点<ul><li>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li></ul><h2 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h2><ul><li>用下面的代码举个例子<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示堆内存溢出：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//Hello, HelloHello, HelloHelloHelloHello ···</span></span><br><span class="line">            String a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;  <span class="comment">// HelloHelloHelloHello</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>list对象的作用域是在try块中，list对象是通过new出来的，所以占用的是堆空间。</li><li>由于a的字符串长度是指数增长的，所以堆空间很快就会不足，此时会触发垃圾回收机制，尝试清理新生代对象，但由于list对象一直处于存活状态，无法释放，最终导致堆内存溢出，最终我这里输出的i为<code>27</code></li><li>但是由于堆空间很大，所以有些堆内存溢出的情况可能不是很容易能诊断出来，所以我们可以通过添加JVM参数，将堆空间修改的小一些来进行测试，此时最终输出的i为<code>17</code><br><img src="https://s1.ax1x.com/2023/03/30/pp2Jr6g.png" alt=""></li></ul><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><ol><li>jps工具<ul><li>查看当前系统中有哪些Java进程</li></ul></li><li>jmap工具<ul><li>查看堆内存占用情况<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id <span class="comment"># 进程id就是jps查出来的进程</span></span><br></pre></td></tr></table></figure></li></ul></li><li>jconsole工具<ul><li>图形化界面的多功能监测工具，可以连续监测</li></ul></li></ol><ul><li>案例代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示堆内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 在休眠期间查询当前新生代内存占用情况</span></span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 10 Mb</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2...&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 由于这里new了一个10M大小的数组，所以新生代内存占用情况应该比上一次多10M左右</span></span><br><span class="line">        Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        <span class="comment">// 3. 这里将数组置空，并进行垃圾回收，此时数组占用的10M就会呗回收掉，内存占用应该比2少</span></span><br><span class="line">        array = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;3...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对应的诊断指令及结果<ol><li>查询到目标进程id为17756<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">18640 Jps</span><br><span class="line">5592 RemoteMavenServer36</span><br><span class="line">8008 Launcher</span><br><span class="line">17756 Demo_05           </span><br><span class="line">2124</span><br></pre></td></tr></table></figure></li><li>当控制台输出 “1…”后，查询当前堆内存占用情况<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 18188</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">    capacity = 100663296 (96.0MB)</span><br><span class="line">    used     = 8053144 (7.680076599121094MB)     # 主要看这个，这个是新生代内存占用，当前为7.6M</span><br><span class="line">    free     = 92610152 (88.3199234008789MB)</span><br><span class="line">    8.000079790751139% used</span><br></pre></td></tr></table></figure></li><li>当控制台输出 “2…”后，再次查看当前堆内存占用情况<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 18188</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 100663296 (96.0MB)</span><br><span class="line">   used     = 18538920 (17.680091857910156MB)   # new了一个10M大小的数组，当前内存占用17.6M，符合我们的预期</span><br><span class="line">   free     = 82124376 (78.31990814208984MB)</span><br><span class="line">   18.416762351989746% used</span><br></pre></td></tr></table></figure></li><li>当控制台输出 “3…”后，再次查看当前堆内存占用情况<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 18188</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 100663296 (96.0MB)</span><br><span class="line">   used     = 2013288 (1.9200210571289062MB)    # 进行垃圾回收，占用内存比上一步少</span><br><span class="line">   free     = 98650008 (94.0799789428711MB)</span><br><span class="line">   2.0000219345092773% used</span><br></pre></td></tr></table></figure></li></ol></li><li>下面使用jconsole进行测试<br><img src="https://s1.ax1x.com/2023/03/30/pp2Y55t.png" alt=""></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>垃圾回收后，内存占用仍然很高<ul><li>先根据前面<code>新生代</code>和<code>老年代</code>的定义来推测一下可能是什么原因</li><li>垃圾回收主要回收的是新生代对象，同时将存活的新生代对象移到老年代的空间</li><li>那么原因可能就是新生代对象一直存活，导致垃圾回收的时候回收不了多少内存，同时这些存活的新生代转为老年代</li></ul></li><li>下面使用jvisualvm进行诊断<br><img src="https://s1.ax1x.com/2023/03/30/pp2tjyD.png" alt=""></li><li>可以看到有一个集合占了200M左右，那我们继续查找最大的对象<br><img src="https://s1.ax1x.com/2023/03/30/pp2Nmwj.png" alt=""></li><li>诊断结果中是有200个student对象在占用内存</li><li>再来看看代码是否真的跟我们想的一样，students集合要等main方法执行完毕后才能释放，而下面休眠了1000000秒，就导致students无法被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示查看对象个数 堆转储 dump</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            students.add(<span class="keyword">new</span> Student());</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000000000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>真实场景中的业务逻辑会比这个复杂，但是诊断方式都是相通的</li></ul><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzoLT.png" alt=""></p><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><ul><li>在JVM中，方法区是一块用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，它是Java虚拟机规范中的一个概念。<code>Java SE 7</code>及之前版本中，方法区被称为<code>永久代</code>，但在<code>Java SE 8</code>之后的版本中，<code>永久代</code>被废弃了，被<code>元空间</code>所替代。</li><li>元空间是JVM在<code>Java SE 8</code>之后引入的一个新的概念，它与永久代类似，都是用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，但元空间的实现方式与永久代有所不同。</li><li>与永久代不同的是，元空间使用的是<code>本地内存（Native Memory）</code>，而不是<code>虚拟机内存（堆内存）</code>，这样就避免了OutOfMemoryError错误，因为在使用本地内存时，可以动态地调整大小，而且可以使用操作系统的虚拟内存机制，使得Java应用程序不会被限制在固定的内存大小中。</li><li>此外，元空间还引入了一些新的概念和机制，例如MetaspaceSize、MaxMetaspaceSize、CompressedClassSpaceSize等，这些概念和机制都是为了更好地管理元空间的内存使用和性能。</li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="https://s1.ax1x.com/2023/03/30/pp2d51x.png" alt=""></p><h2 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h2><ul><li>1.8之前会导致永久代内存溢出</li><li>1.8之后会导致源空间内存溢出，测试代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment"> * -XX:MaxMetaspaceSize=50m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_07</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123; <span class="comment">// 可以用来加载类的二进制字节码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Demo_07 test = <span class="keyword">new</span> Demo_07();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="comment">// ClassWriter 作用是生成类的二进制字节码</span></span><br><span class="line">                ClassWriter cw = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 版本号， public， 类名, 包名, 父类， 接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="keyword">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 执行了类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// Class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加VM参数<code>-XX:MaxMetaspaceSize=50m</code>，然后运行上面的代码，结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">70801</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:635)</span><br><span class="line">at com.demo.Demo_07.main(Demo_07.java:23)</span><br></pre></td></tr></table></figure></li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ul><li>常量池就是一行表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>我们先来编写一个简单的HelloWorld类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>然后通过命令将编译后的.class文件反汇编成可读的Java代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                                                                </span><br><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/HelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello, World!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure></li><li>上面的结果中主要包含三部分<div class="tabs" id="类基本信息、常量池、类方法定义"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#类基本信息、常量池、类方法定义-1">类的基本信息</button></li><li class="tab"><button type="button" data-href="#类基本信息、常量池、类方法定义-2">常量池</button></li><li class="tab"><button type="button" data-href="#类基本信息、常量池、类方法定义-3">类方法定义</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="类基本信息、常量池、类方法定义-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER        </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="类基本信息、常量池、类方法定义-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="类基本信息、常量池、类方法定义-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();     // 这里给了一个默认的无参构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/HelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);  // 这就是我们的main方法了</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello, World!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return                            </span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中如下内容就表示虚拟机的指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">3: ldc           #3                  // String Hello, World!    </span><br><span class="line">5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">8: return                            </span><br></pre></td></tr></table></figure></li><li>解释器去翻译虚拟机指令的时候，看到的只有这些<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #2</span><br><span class="line">ldc           #3</span><br><span class="line">invokevirtual #4</span><br></pre></td></tr></table></figure></li><li>解释器在解释的时候，就是拿着#2、#3、#4去查表翻译，查的就是常量池中的内容<ul><li>用#2举例，查表内容如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #2                        // 获取静态变量System.out</span><br><span class="line">#2 = Fieldref            #21.#22        // java/lang/System.out:Ljava/io/PrintStream;     </span><br><span class="line">#21 = Class              #28            // java/lang/System</span><br><span class="line">#28 = Utf8               java/lang/System</span><br><span class="line">#22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">#29 = Utf8               out</span><br><span class="line">#30 = Utf8               Ljava/io/PrintStream;</span><br></pre></td></tr></table></figure></li><li>用#3举例，查表内容如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldc           #3                        // 加载参数Hello, World!</span><br><span class="line">#3 = String              #23            // Hello, World!        </span><br><span class="line">#23 = Utf8               Hello, World!</span><br></pre></td></tr></table></figure></li><li>用#4举例，查表内容如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual #4                        // 执行虚方法调用，调用println，输出Hello, World!</span><br><span class="line">#4 = Methodref           #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">#24 = Class              #31            // java/io/PrintStream</span><br><span class="line">#31 = Utf8               java/io/PrintStream</span><br><span class="line">#25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">#32 = Utf8               println</span><br><span class="line">#33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li>常量池是 *.class 文件中的<code>Constant pool</code>中的内容</li><li>而运行时常量池是当该类被加载时，将常量池信息放入运行时常量池，并把里面的符号地址(#2、#3)变为内存地址</li></ul><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><ul><li>我们反编译一下这段代码，看看常量池里都有什么  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_08</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量池中的信息，都会被加载到运行时常量池中，此时a、b、ab都是常量池中的符号，还没有变成java对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果如下（只截取了我们需要的东西）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #1 = Methodref          #6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    #2 = String             #25            // a</span><br><span class="line">    #3 = String             #26            // b</span><br><span class="line">    #4 = String             #27            // ab</span><br><span class="line">    #5 = Class              #28            // com/demo/Demo_08</span><br><span class="line"></span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=1, locals=4, args_size=1</span><br><span class="line">        0: ldc           #2                  // String a</span><br><span class="line">        2: astore_1</span><br><span class="line">        3: ldc           #3                  // String b</span><br><span class="line">        5: astore_2</span><br><span class="line">        6: ldc           #4                  // String ab</span><br><span class="line">        8: astore_3</span><br><span class="line">        9: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 3</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 9</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  args   [Ljava/lang/String;</span><br><span class="line">            3       7     1    s1   Ljava/lang/String;</span><br><span class="line">            6       4     2    s2   Ljava/lang/String;</span><br><span class="line">            9       1     3    s3   Ljava/lang/String;</span><br></pre></td></tr></table></figure><ul><li><code>ldc #2</code> 会把a符号变成”a”字符串对象</li><li><code>ldc #3</code> 会把a符号变成”b”字符串对象</li><li><code>ldc #4</code> 会把a符号变成”ab”字符串对象</li></ul></li><li>下面添加两行代码，变成一道经典面试题，输出结果是true还是false呢？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>答案我先不说，我们还是先反编译一下这段代码，结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=5, args_size=1</span><br><span class="line">       0: ldc           #2                  // String a</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String b</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           #4                  // String ab</span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: astore        4</span><br><span class="line">      29: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      32: aload_3</span><br><span class="line">      33: aload         4</span><br></pre></td></tr></table></figure></li><li>通过反编译的结果，我们来分析一下s4对象是如何被创建的  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">12: dup</span><br><span class="line">13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">20: aload_2</span><br><span class="line">21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br></pre></td></tr></table></figure><ul><li><code>#5、#6</code>：调用StringBuilder的无参构造方法，创建对象</li><li><code>#7</code>：调用StringBuilder的append方法，加载参数为<code>aload_1</code>和<code>aload_2</code>，即<code>a、b</code></li><li><code>#8</code>：调用StringBuilder的toString方法</li></ul></li><li>总结一下，s4对象的创建方法如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="keyword">new</span> StringBuilder.append(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).toString();</span><br></pre></td></tr></table></figure></li><li>那么s4对象是new出来的对象，存放在堆空间里，而s3对象是存在于常量池中的，故<code>s3 == s4</code>的结果为<code>false</code></li><li>再来试试常量拼接的结果如何<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s4 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        String s5 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        System.out.println(s3 == s5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>反编译结果如下，可以看到s5对象的创建，就是去常量池中直接获取ab，而不会创建新的字符串对象，故<code>s3 == s5</code>的结果是<code>true</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=6, args_size=1</span><br><span class="line">       0: ldc           #2                  // String a</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String b</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           #4                  // String ab</span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: astore        4</span><br><span class="line">      29: ldc           #4                  // String ab</span><br><span class="line">      31: astore        5</span><br></pre></td></tr></table></figure></li><li>那s5对象为什么是直接从常量池中获取的呢？<ul><li>这是javac在编译期的优化，因为s5是由两个常量拼接而成，常量拼接的结果是确定的，那么在编译期间就能确定结果肯定是<code>&quot;ab&quot;</code> </li><li>而s4是由s1、s2两个变量拼接而成的，变量在运行的时候，引用的值可能被修改，那么结果就不能确定，所以只能在运行期间，使用StringBuilder来动态的拼接</li></ul></li></ul><h3 id="字符串延迟加载"><a href="#字符串延迟加载" class="headerlink" title="字符串延迟加载"></a>字符串延迟加载</h3><ul><li>每遇到一个没见过的字符串对象，才会将其放入常量池，如果池子中已经有了，则不会新增对象</li><li>使用下面的代码单步调试来验证一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println();       <span class="comment">// 字符串个数：2224</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);    <span class="comment">// 每步入到下一行，字符串个数 +1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println();       <span class="comment">// 字符串个数：2235</span></span><br><span class="line">        System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);    <span class="comment">// 字符串个数保持2235不在变化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s1.ax1x.com/2023/03/31/ppR1WjJ.png" alt=""></li></ul><h3 id="StringTable特性"><a href="#StringTable特性" class="headerlink" title="StringTable特性"></a>StringTable特性</h3><ol><li>常量池中的字符串仅是符号，第一次用到时才会变为对象</li><li>利用串池的机制，避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder（1.8）</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8中，将这个字符串对象尝试放入串池<ul><li>如果串池中已有，则不会放入</li><li>如果串池中没有，则放入串池，并将串池中的结果返回</li></ul></li><li>下面是示例代码讲解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;            <span class="comment">// 常量池：[&quot;a&quot;]</span></span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;            <span class="comment">// 常量池：[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">        String s3 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;      <span class="comment">// 常量池：[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span></span><br><span class="line">        String s4 = s1 + s2;        <span class="comment">// 堆：new String(&quot;ab&quot;)</span></span><br><span class="line">        String s5 = <span class="string">&quot;ab&quot;</span>;           <span class="comment">// s5引用常量池中已有的对象</span></span><br><span class="line">        String s6 = s4.intern();    <span class="comment">// 常量池中已有&quot;ab&quot;，将常量池中的&quot;ab&quot;的引用返回，s6引用常量池中已有的对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);   <span class="comment">// s3在常量池，s4在堆，false</span></span><br><span class="line">        System.out.println(s3 == s5);   <span class="comment">// s3在常量池，s5在常量池，true</span></span><br><span class="line">        System.out.println(s3 == s6);   <span class="comment">// s3在常量池，s6在常量池，true</span></span><br><span class="line"></span><br><span class="line">        String str1 = <span class="string">&quot;cd&quot;</span>;     <span class="comment">// 常量池：[&quot;cd&quot;]</span></span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;d&quot;</span>);    <span class="comment">// 堆：new String(&quot;cd&quot;)</span></span><br><span class="line">        str2.intern();  <span class="comment">// 常量池中已有&quot;cd&quot;，放入失败</span></span><br><span class="line">        System.out.println(str1 == str2);   <span class="comment">// str1在常量池，str2在堆，false</span></span><br><span class="line"></span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">&quot;e&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;f&quot;</span>);    <span class="comment">// 堆：new String(&quot;ef&quot;)</span></span><br><span class="line">        str4.intern();          <span class="comment">// 常量池中没有&quot;ef&quot;，放入成功，并返回常量池&quot;ef&quot;的引用</span></span><br><span class="line">        String str3 = <span class="string">&quot;ef&quot;</span>;     <span class="comment">// 常量池：[&quot;ef&quot;]</span></span><br><span class="line">        System.out.println(str3 == str4);   <span class="comment">// str4是常量池的引用，str3也是常量池的引用，true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="StringTable的位置"><a href="#StringTable的位置" class="headerlink" title="StringTable的位置"></a>StringTable的位置</h3><ul><li>在 <code>JDK 1.6</code> 中，字符串常量池（也就是 StringTable）是位于<code>永久代</code>中的。而在 <code>JDK 1.8</code> 中，永久代已经被移除，取而代之的是元空间（Metaspace），而字符串常量池也随之移动到了<code>堆</code>中。这意味着在 JDK 1.8 中，字符串常量池中的字符串也可以被垃圾回收器回收，而在 JDK 1.6 中则不行。</li></ul><h3 id="StringTable垃圾回收"><a href="#StringTable垃圾回收" class="headerlink" title="StringTable垃圾回收"></a>StringTable垃圾回收</h3><ul><li>在 Java 8 及更高版本中，字符串常量池位于堆中，而堆是 JVM 中的一部分，因此字符串常量池中的字符串可以被垃圾回收器回收。具体来说，只有当字符串没有被任何对象引用时，它才能被垃圾回收。当字符串被回收时，它的存储空间将被释放并可以被重新利用。</li><li>下面我们通过示例代码来验证一下，首先先添加几个VM参数<ol><li>-Xmx10m：指定堆内存大小</li><li>-XX:+PrintStringTableStatistics：打印字符串常量池信息</li><li>-XX:+PrintGCDetails：打印垃圾回收详细信息</li><li>-verbose:gc：打印 gc 的次数，耗费时间等信息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>打印的日志信息如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 2007K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 98% used [0x00000000ffd00000,0x00000000ffef5d50,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 0K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3256K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 356K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">SymbolTable statistics:</span><br><span class="line">Number of buckets       :     20011 =    160088 bytes, avg   8.000</span><br><span class="line">Number of entries       :     13446 =    322704 bytes, avg  24.000</span><br><span class="line">Number of literals      :     13446 =    574288 bytes, avg  42.711</span><br><span class="line">Total footprint         :           =   1057080 bytes</span><br><span class="line">Average bucket size     :     0.672</span><br><span class="line">Variance of bucket size :     0.677</span><br><span class="line">Std. dev. of bucket size:     0.823</span><br><span class="line">Maximum bucket size     :         6</span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :      1760 =     42240 bytes, avg  24.000</span><br><span class="line">Number of literals      :      1760 =    157872 bytes, avg  89.700</span><br><span class="line">Total footprint         :           =    680216 bytes</span><br><span class="line">Average bucket size     :     0.029</span><br><span class="line">Variance of bucket size :     0.030</span><br><span class="line">Std. dev. of bucket size:     0.172</span><br><span class="line">Maximum bucket size     :         3</span><br></pre></td></tr></table></figure></li><li>由于在上面的代码中，我们没有创建字符串常量，所以没有触发垃圾回收机制，我们重点只关注<code>StringTable statistics</code>中的内容<ul><li>这是字符串常量池的统计信息，包含以下三个方面的信息<ul><li>Number of buckets: 字符串常量池中的桶(bucket)数量。在这个例子中，共有60013个桶。</li><li>Number of entries: 字符串常量池中的实际条目(entry)数量。在这个例子中，共有1760个条目。</li><li>Number of literals: 字符串常量池中存储的字面量(literal)数量。在这个例子中，共有1760个字面量。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :      1760 =     42240 bytes, avg  24.000</span><br><span class="line">Number of literals      :      1760 =    157872 bytes, avg  89.700</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>那现在我们什么都没做，字符串常量池中有1760个字符串常量，那我现在尝试将5W个字符串存入常量池中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                String.valueOf(j).intern();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行，观察日志，可以看到，触发了垃圾回收机制，且串池中的数量也远小于5W个，所以StringTable确实是会发生垃圾回收的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2536K-&gt;488K(2560K)] 2833K-&gt;865K(9728K), 0.0011680 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :     13299 =    319176 bytes, avg  24.000</span><br><span class="line">Number of literals      :     13299 =    804392 bytes, avg  60.485</span><br></pre></td></tr></table></figure></li></ul><h3 id="StringTable性能调优1"><a href="#StringTable性能调优1" class="headerlink" title="StringTable性能调优1"></a>StringTable性能调优1</h3><ul><li>在JVM内部，字符串常量池就是通过哈希表实现的。<ul><li>添加VM参数-XX:StringTableSize=1024，实际上设置的是哈希表的大小（即桶的数量）。较小的哈希表意味着更多的哈希冲突。这会增加查找字符串的开销，因为需要在链表中进行顺序搜索才能找到一个字符串。因此，这将会导致字符串查找速度变慢。</li><li>示例代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 演示串池大小对性能的影响，读取文件，将内容存入字符串常量池，文件中约有48W个不同的字符串</span></span><br><span class="line"><span class="comment">* -XX:StringTableSize=50000  耗时0.318s</span></span><br><span class="line"><span class="comment">* -XX:StringTableSize=10000  耗时1.098s</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Workspace\\JVM\\demo\\linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line.intern();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>添加VM参数-XX:StringTableSize=50000，耗时0.318s</li><li>添加VM参数-XX:StringTableSize=10000，耗时1.098s</li></ul></li></ul><h3 id="StringTable性能调优2"><a href="#StringTable性能调优2" class="headerlink" title="StringTable性能调优2"></a>StringTable性能调优2</h3><ul><li>如果应用需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</li><li>实际应用：  <div class="note info no-icon flat"><ul><li>根据推特的工程师们所说，推特在存储用户地址信息时采用了字符串常量池的方法。推特上有大量的用户地址信息，而这些信息中有大量的重复内容，如街道名称、城市、州等。通过将这些常见的地址信息存储在字符串常量池中，推特可以节省大量的内存空间。</li><li>推特使用了Guava库中的Interners工具类来实现字符串常量池。该工具类提供了线程安全的字符串常量池实现，支持不同的策略和配置，例如并发级别、最大容量等。推特选择了使用一个全局的、不限容量的字符串常量池来存储用户地址信息。在存储用户信息时，推特使用了String.intern()方法来将地址信息存储在字符串常量池中，而不是直接使用新的字符串对象。这样，推特可以确保相同的地址信息只会在内存中存在一份拷贝，从而减少内存的占用。</li><li>通过这种方法，推特成功地实现了在存储大量用户信息时，有效地减少了内存占用。</li></ul></div></li><li>那我们现在来复现一个类似的场景，存储大量重复的字符串常量信息，然后使用Java VisualVM监测内存使用情况，示例代码如下<ul><li>每循环一次就有48W个字符串，循环十次就是480W个字符串放到内存中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Workspace\\JVM\\demo\\linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 没有入池</span></span><br><span class="line">                    list.add(line);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>监测内存String和char[]加起来大概占用了250M<br><img src="https://s1.ax1x.com/2023/04/01/ppWPpwj.png" alt=""></li><li>那现在我们将字符串入池，再来监测一下内存占用情况<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\Workspace\\JVM\\demo\\linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    line = reader.readLine();</span><br><span class="line">                    <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 入池</span></span><br><span class="line">                    list.add(line.intern());</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>内存占用情况如下，这下仅仅才占用50M内存<br><img src="https://s1.ax1x.com/2023/04/01/ppWPZXF.png" alt=""></li></ul></li></ul><div class="note info no-icon flat"><p>小结：如果我们需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p></div><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><ul><li>JVM的直接内存是指JVM中的一个内存区域，也被称为NIO直接缓冲区。和Java堆不同，直接内存并不是由JVM自动管理的，而是由操作系统直接管理的。直接内存的访问速度比Java堆要快，因为它们可以利用操作系统提供的一些优化机制来提高I/O的效率。</li><li>在Java程序中，可以通过ByteBuffer.allocateDirect()方法来创建直接缓冲区。当调用该方法创建直接缓冲区时，JVM会向操作系统申请一块直接内存，用于存储该缓冲区的数据。这个过程不会像在Java堆中创建对象一样，需要进行垃圾回收和堆内存分配的操作，因此创建直接缓冲区的效率要高于在Java堆中创建对象。</li><li>需要注意的是，直接内存是不受JVM的内存管理机制控制的，因此如果使用不当，可能会导致内存泄漏等问题。此外，因为直接内存的访问速度快，但申请和释放直接内存的开销较大，因此需要谨慎使用，避免频繁创建和销毁直接缓冲区。</li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li>Direct Memory<ol><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不收JVM内存回收管理</li></ol></li></ul><h3 id="比较示例"><a href="#比较示例" class="headerlink" title="比较示例"></a>比较示例</h3><ul><li>那这里比较一下传统IO和直接内存对文件拷贝的性能差异（这里建议准备一个比较大的视频文件）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 ByteBuffer 作用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_14</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FROM = <span class="string">&quot;D:\\BaiduNetdiskDownload\\星际牛仔.mp4&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TO = <span class="string">&quot;D:\\星际牛仔.mp4&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1Mb = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        io(); </span><br><span class="line">        directBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (FileChannel from = <span class="keyword">new</span> FileInputStream(FROM).getChannel();</span><br><span class="line">             FileChannel to = <span class="keyword">new</span> FileOutputStream(TO).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = from.read(bb);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bb.flip();</span><br><span class="line">                to.write(bb);</span><br><span class="line">                bb.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;directBuffer 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream from = <span class="keyword">new</span> FileInputStream(FROM);</span><br><span class="line">             FileOutputStream to = <span class="keyword">new</span> FileOutputStream(TO);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[_1Mb];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = from.read(buf);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                to.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;io 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>最终结果如下，可以发现，使用直接内存比传统IO快了一倍多<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io 用时：2248.1023</span><br><span class="line">directBuffer 用时：1097.9701</span><br></pre></td></tr></table></figure></li><li>原因是直接内存使用的是操作系统的文件映射机制，而传统IO则需要将文件内容读取到内存中再进行操作。直接内存可以避免将文件数据复制到Java堆内存中的过程，减少了不必要的数据复制，从而提高了效率。<ul><li>传统IO，将文件读取到系统缓冲区中，但是Java代码不能直接读取系统缓冲区，所以需要在堆内存中分配一块Java缓冲区，将数据从系统缓冲区读取到Java缓冲区后，才能进行写操作<br><img src="https://s1.ax1x.com/2023/04/01/ppWku7Q.png" alt=""></li><li>直接内存的Direct Memory对Java堆内存和系统内存是共享的一块内存区，那么磁盘文件就可以直接读取到Direct Memory，而Java堆内存也可以直接访问Direct Memory<br><img src="https://s1.ax1x.com/2023/04/01/ppWkNBF.png" alt=""></li></ul></li></ul><h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><ul><li>直接内存（Direct Memory）是一种Java NIO中用于高性能I/O操作的内存分配方式，与Java虚拟机中的Java堆不同，它不会受到Java堆大小的限制。直接内存是通过操作系统的内存来分配和释放，因此它不会受到Java堆大小限制的影响，可以更加灵活地使用。</li><li>然而，如果过度使用直接内存，也可能会导致直接内存溢出。直接内存的使用需要手动进行管理，如果不注意及时释放已经使用的直接内存，或者申请过多的直接内存，就会导致直接内存溢出。</li><li>当直接内存溢出时，通常会抛出java.lang.OutOfMemoryError异常。为了避免直接内存溢出，建议在使用完直接内存后及时进行释放</li><li>下面是一段示例代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示直接内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_10</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _100Mb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;ByteBuffer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_100Mb);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>循环了54次就内存溢出了，差不多是5.4G<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">54</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:695)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">at com.demo.Demo_15.main(Demo_15.java:18)</span><br></pre></td></tr></table></figure></li></ul><h2 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h2><ul><li>前面说直接内存不受JVM的管理，所以垃圾回收gc()对直接内存无效，那么直接内存是如何分配和回收的呢？<ul><li>来看一下我们的示例代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_16</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1GB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>因为是直接内存，所以我们想查看它的使用情况，可以单步调试，直接在Windows的任务管理器中查看<ol><li>分配内存前的内存使用情况<br><img src="https://s1.ax1x.com/2023/04/01/ppWeVeK.png" alt=""></li><li>分配内存完毕后的使用情况<br><img src="https://s1.ax1x.com/2023/04/01/ppWeuJH.png" alt=""></li><li>执行垃圾回收后的使用情况<br><img src="https://s1.ax1x.com/2023/04/01/ppWeQSA.png" alt=""></li></ol></li></ul></li><li>在我们的单步调试中，执行了垃圾回收后，<code>直接内存被释放了</code>，这显然与我们之前所说的冲突啊，这是怎么回事呢？</li><li>先别急，我们先来了解一下直接内存应该是怎样被释放的，Java里有一个非常底层的类<code>Unsafe</code>，它可以分配直接内存和释放直接内存，但是一般不建议我们直接使用Unsafe类，都是JDK内部自己去使用这个类的。</li><li>那现在为了演示直接内存的分配释放的流程，我们通过反射来获取一个Unsafe对象，然后来进行操作讲解  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 直接内存分配的底层原理：Unsafe</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_17</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1Gb = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        <span class="keyword">long</span> base = unsafe.allocateMemory(_1Gb);</span><br><span class="line">        unsafe.setMemory(base, _1Gb, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配内存&quot;</span>);</span><br><span class="line">        unsafe.freeMemory(base);</span><br><span class="line">        System.out.println(<span class="string">&quot;释放内存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 反射获取Unsafe对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  Unsafe对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>分配内存前的内存使用情况<br><img src="https://s1.ax1x.com/2023/04/01/ppWehlR.png" alt=""></li><li>分配内存完毕后的使用情况<br><img src="https://s1.ax1x.com/2023/04/01/ppWe7TO.png" alt=""></li><li>执行垃圾回收后的使用情况<br><img src="https://s1.ax1x.com/2023/04/01/ppWeLfH.png" alt=""></li></ol></li><li><p>所以对于直接内存需要使用<code>Unsafe</code>对象完成直接内存的分配回收，并且回收需要主动调用<code>freeMemory</code>方法</p></li><li><p>现在我们来看一下ByteBuffer.allocateDirect()的底层实现是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new direct byte buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; The new buffer&#x27;s position will be zero, its limit will be its</span></span><br><span class="line"><span class="comment"> * capacity, its mark will be undefined, and each of its elements will be</span></span><br><span class="line"><span class="comment"> * initialized to zero.  Whether or not it has a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #hasArray backing array&#125; is unspecified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  capacity</span></span><br><span class="line"><span class="comment"> *         The new buffer&#x27;s capacity, in bytes</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The new byte buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>顺藤摸瓜找到<code>DirectByteBuffer</code>对象的源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Primary constructor</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>从底层源码中我们可以看到，这里就是使用Unsafe对象对直接内存的分配，但是却没有看到回收方法<code>freeMemory</code><ul><li>其实释放的方法是在Deallocator()这个回调方法中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Paranoia</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>而它是由Cleaner调用的， Cleaner（虚引用类型）是用来监测<code>ByteBuffer</code>对象的，一旦<code>ByteBuffer</code>对象被垃圾<code>回收</code>，那么就会由<code>ReferenceHandler</code>线程通过<code>Cleaner</code>的<code>clean</code>方法调用<code>freeMemory</code>来释放直接内存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> Error(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="禁用垃圾回收对直接内存的影响"><a href="#禁用垃圾回收对直接内存的影响" class="headerlink" title="禁用垃圾回收对直接内存的影响"></a>禁用垃圾回收对直接内存的影响</h3><ul><li>由于垃圾回收是一个相对昂贵的操作，需要消耗CPU时间和系统资源。频繁调用System.gc()可能会导致性能下降，并且在某些情况下可能会造成应用程序的不稳定性。</li><li>所以为了避免有些程序员老是手动调用垃圾回收，我们一般会进制显式手动垃圾回收，添加VM参数<code>-XX:+DisableExplicitGC</code>禁用显式的垃圾回收</li><li>那么加上这个参数以后，可能就会影响到我们的直接内存的回收机制，例如下面的代码中，执行完System.gc()后（被禁用，相当于没执行），由于内存很充裕，所以ByteBuffer对象并不会被回收，那么ByteBuffer对象对应的那块直接内存，也不会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_16</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> _1GB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(<span class="string">&quot;分配完毕&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;释放完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>单步调试，观察直接内存占用情况，执行垃圾回收后，直接内存没有被释放，那么此时我们就只能通过Unsafe的freeMemory()方法来手动释放直接内存了<br><img src="https://s1.ax1x.com/2023/04/01/ppWYZjO.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(1)</title>
      <link href="/2023/04/24/JVMPart/JVM_1/"/>
      <url>/2023/04/24/JVMPart/JVM_1/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><ul><li>定义<ul><li><code>Java Virtual Machine</code>— Java程序的运行环境（Java二进制字节码的运行环境）</li></ul></li><li>好处<ol><li>一次编译，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下表越界检查</li><li>多态</li></ol></li><li>比较JVM、JRE、JDK<ul><li><code>JVM</code>（Java Virtual Machine），Java虚拟机</li><li><code>JRE</code>（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</li><li><code>JDK</code>（Java Development Kit）称为Java开发工具，包含了JRE和开发工具<br><img src="https://s1.ax1x.com/2023/03/26/pprzSaQ.png" alt=""></li></ul></li></ul><h1 id="学习JVM有什么用？"><a href="#学习JVM有什么用？" class="headerlink" title="学习JVM有什么用？"></a>学习JVM有什么用？</h1><ul><li><del>面试</del></li><li>理解底层实现原理</li><li>中高级程序员的必备技能</li></ul><h1 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzYZD.png" alt=""></p><h1 id="JVM-在-Java-中是如何工作的"><a href="#JVM-在-Java-中是如何工作的" class="headerlink" title="JVM 在 Java 中是如何工作的"></a>JVM 在 Java 中是如何工作的</h1><p><img src="https://s1.ax1x.com/2023/03/26/pprzoLT.png" alt=""></p><ul><li>JVM主要分为三个子系统<ol><li>类加载器（ClassLoader）</li><li>JVM运行时数据区（内存结构）</li><li>执行引擎</li></ol></li></ul><h2 id="类加载器系统"><a href="#类加载器系统" class="headerlink" title="类加载器系统"></a>类加载器系统</h2><ul><li>Java 的动态类加载功能由类加载器子系统处理。它在运行时第一次引用一个类时加载、链接和初始化该类，而不是在编译时。</li><li>它执行三个主要功能<ul><li>加载</li><li>链接</li><li>初始化</li></ul></li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>该组件将加载类。</li><li>BootStrap ClassLoader、Extension ClassLoader、Application ClassLoader 是三个有助于实现它的类加载器。<ul><li><code>BootStrap ClassLoader</code> 启动类加载器是所有其他类加载器的parent（rt.jar包下的类）</li><li><code>Extension ClassLoader</code> 扩展类加载器加载核心 Java 类的扩展类（ext/*.jar包下的类）</li><li><code>Application ClassLoader</code> 应用类加载器加载在classpath中的我们自己写的文件</li></ul></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul><li><p>这部分要做三件事</p><ol><li>验证（Verify）<ul><li>验证被加载的类的准确性，保证安全，不被恶意修改</li><li>有四种验证方式，文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul></li><li><p>准备（Prepare）</p><ul><li>为类变量分配内存并且设置该类变量的默认初始值，也就是零值，即在准备阶段，类的变量都会是默认值，只有到了初始化阶段（initization），才会赋值</li><li>如果用final修饰的static变量，那么在这个阶段，就会显示初始化，因为final在编译的时候就分配了空间和值</li></ul></li><li><p>解析（Resolve）</p><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>解析伴随着初始化执行完之后再执行</li></ul></li></ol></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>这是类加载的最后阶段，这里所有的静态变量 都将被赋予原始值并执行静态块。</li></ul><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><ol><li><code>方法区（Method Area）</code>：所有类级别的数据都将存储在这里，包括 静态变量。方法区是每个 JVM 一个，它是一种共享资源。</li><li><code>堆（Heap Area）</code>：所有的Objects及其对应的实例变量 和数组都将存储在这里。堆区也是每个 JVM 一个，因为方法区和堆区为多个线程共享内存，存储的数据不是线程安全的。</li><li><code>虚拟机栈（Stack Area）</code>：对于每个线程，都会创建一个单独的运行时堆栈。对于每个方法调用，都会在堆栈内存中创建一个条目，称为<code>栈帧</code>。所有局部变量都将在堆栈内存中创建。堆栈区域是线程安全的，因为它不是共享资源。<code>Stack Frame</code>分为三个子实体如下<ol><li><code>局部变量数组</code>：与方法有关，涉及多少个局部变量，相应的值将存储在这里。</li><li><code>操作数栈</code>：如果需要执行任何中间操作，操作数栈充当运行时工作空间来执行操作。</li><li><code>帧数据</code>：所有与方法对应的符号都存储在这里。在任何异常的情况下，catch块信息将在帧数据中维护。</li></ol></li><li><code>程序计数器（PC Registers）</code>：每个线程都有独立的程序计数器，用于保存当前执行指令的地址 ，一旦指令执行，程序计数器将被下一条指令更新</li><li><code>本地方法栈（Native Method stacks）</code>：保存本地方法信息。对于每个线程，将创建单独的本地方法堆栈。</li></ol><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><ul><li>分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐一执行。<ol><li><code>解释器</code>：读取字节码，解释并逐一执行。解释器解释字节码的速度更快，但执行速度较慢。解释器的缺点是当一个方法调用多次时，每次都需要解释。</li><li><code>JIT 编译器</code>：JIT 编译器抵消了解释器的缺点（一个方法调用多次，每次都需要解释），执行引擎将使用解释器的帮助进行转换，但当它发现重复代码时，它使用 JIT 编译器编译整个字节码并将其更改为本机代码。此本机代码将直接用于提高系统性能的重复方法调用。<ol><li>中间代码生成器：生成中间代码</li><li>代码优化器：负责优化上面生成的中间代码</li><li>目标代码生成器：负责生成机器代码/本机代码</li><li>Profiler：Profiler是一个特殊的组件，它负责发现热点（即）用于识别方法是否被多次调用。</li></ol></li><li>垃圾收集器：垃圾收集器是执行引擎的一部分，它收集/删除未引用的对象。可以通过调用<code>System.gc()</code>来触发垃圾收集，但不能保证执行。JVM 的垃圾收集器只收集那些由new关键字创建的对象。因此，如果您创建了任何没有使用new的对象，您可以使用finalize方法来执行清理。</li></ol></li><li>Java Native Interface（JNI）：JNI将与本机方法库交互，并提供执行引擎所需的本机库。</li><li>本地方法库：这是执行引擎所需的本地库的集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM知识点</title>
      <link href="/2023/04/18/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/04/18/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点汇总"><a href="#知识点汇总" class="headerlink" title="知识点汇总"></a>知识点汇总</h1><details class="folding-tag" cyan open><summary> 知识点汇总 </summary>              <div class='content'>              <ul><li>JVM是Java运行基础，面试时一定会遇到JVM相关的问题，内容相对集中，但只是对深度要求较高</li></ul><p><img src="https://s1.ax1x.com/2023/04/15/p9SowJU.png" alt=""></p><ul><li>其中内存模型、类加载机制、GC是重点方面，性能调优部分更偏向应用，重点突出实践能力，编译器优化和执行模式部分偏向于理论，重点掌握知识点</li><li>需了解<code>内存模型</code>各部分作用，保存哪些数据</li><li><code>类加载</code>：双亲委派机加载机制，常用加载器分别加载哪种类型的类</li><li><code>GC</code>分代回收的思想和依据，以及不同垃圾回收算法的回收思路和适合场景</li><li><code>性能调优</code>：常用JVM优化参数作用、参数调优的依据、常用的JVM分析工具能分析哪些问题以及使用方法</li><li><code>执行模式</code>：解释、编译、混合模式的优缺点，Java7提供的分层编译技术、JIT即时编译技术、OSR栈上替换、C1/C2编译器针对的场景</li><li><code>编译器优化</code>：javac的编译过程、ast抽象语法树、编译器优化和运行期优化</li></ul>              </div>            </details><h1 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h1><details class="folding-tag" cyan><summary> 知识点详解 </summary>              <div class='content'>              <ol><li><code>JVM内存模型</code><ul><li>线程独占：栈、本地方法栈、程序计数器</li><li>线程共享：堆、方法区</li></ul></li><li><code>栈</code><ul><li>又称方法栈，线程私有的，线程执行方法是都会创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈</li></ul></li><li><code>本地方法栈</code><ul><li>与栈类似，也是用来保存执行方法的信息，执行Java方法是使用占，执行Native方法时是使用本地方法栈</li></ul></li><li><code>程序计数器</code><ul><li>保存当前线程执行的字节码位置，每个线程工作时都有独立的计数器，值为执行Java方法服务，执行Native方法时，程序计数器为空</li></ul></li><li><code>堆</code><ul><li>JVM内存管理最大的一块，堆被线程共享，目的是存放对象的实例，几乎所有对象的实例都会放在这里。当堆没有可用空间时，会抛出OOM异常(Out of Menory内存溢出)，根据对象的存活周期不同，JVM把对象进行分代管理，由垃圾回收器进行垃圾的回收管理</li></ul></li><li><code>方法区</code><ul><li>又称非堆区，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器优化后的代码等数据</li><li>1.7的永久代和1.8的源空间都是方法区的一种实现</li></ul></li><li><code>JVM内存可见性</code><ul><li>JMM是定义程序中变量的访问规则，线程对变量的操作只能在自己的工作内存中进行，而不能直接对主内存操作，由于指令重排，可能会导致读写的顺序被打乱，因此JMM需要提供原子性、可见性、有序性保证</li></ul></li></ol>              </div>            </details><h1 id="说说类加载和卸载"><a href="#说说类加载和卸载" class="headerlink" title="说说类加载和卸载"></a>说说类加载和卸载</h1><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><details class="folding-tag" cyan><summary> 加载过程 </summary>              <div class='content'>              <p><img src="https://s1.ax1x.com/2023/04/15/p9SXRRP.png" alt=""></p><ol><li><code>加载</code>：通过类的全限定名，查找此类的字节码文件，利用字节码文件创建Class对象</li><li><code>链接</code>：分为三个阶段<ul><li><code>验证</code>：确保Class文件符合当前虚拟机的要求，不会危害到虚拟机自身安全（前面的文章中修改魔数cafebabe之后，验证就失败了）</li><li><code>准备</code>：进行内存分配，为static修饰的类变量分配内存，并设置初始值(0或null)，不包含final修饰的静态变量，因为final变量在编译时就分配好了</li><li><code>解析</code>：将常量池中的符号引用替换为直接引用的过程，直接引用为直接指向目标的指针或者相对偏移量等</li></ul></li><li><code>初始化</code>：主要完成静态块执行以及静态变量的复制，先初始化父类，再初始化当前类。初始化是懒惰的，只有对类主动使用的时候才会初始化</li></ol>              </div>            </details><h2 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h2><details class="folding-tag" cyan><summary> 加载机制 </summary>              <div class='content'>              <ul><li>加载机制：双亲委派模式<ul><li>当一个类加载器收到类加载请求时，它首先会将这个请求委托给父类加载器去处理。如果父类加载器无法加载该类，则该类加载器才会自己去加载这个类。</li><li>优点：避免类的重复加载，避免Java的核心API被篡改</li></ul></li></ul>              </div>            </details><h2 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h2><details class="folding-tag" cyan><summary> 卸载过程 </summary>              <div class='content'>              <ul><li>类卸载的实现依赖于JVM的垃圾回收机制。当一个类不再被引用时，JVM可能会通过垃圾回收机制将该类的实例回收</li></ul>              </div>            </details><h1 id="简述一下JVM内存模型"><a href="#简述一下JVM内存模型" class="headerlink" title="简述一下JVM内存模型"></a>简述一下JVM内存模型</h1><details class="folding-tag" cyan><summary> 简述一下JVM内存模型 </summary>              <div class='content'>              <ul><li>JVM内存模型（JVM Memory Model，JMM）是Java虚拟机用来描述多线程程序中各个线程之间以及线程和内存之间的交互关系的规范。JMM定义了线程的工作内存和主内存之间的交互方式，并规定了在何时如何把工作内存中的数据同步回主内存，或者如何从主内存中读取数据到工作内存中。JMM的设计目的是为了保证在多线程程序中，无论运行在什么平台和处理器架构上，Java程序都能达到一致的内存访问效果。Java开发人员在编写多线程时必须遵守JMM规范来保证程序的正确性</li></ul>              </div>            </details><h1 id="说说堆和栈的区别"><a href="#说说堆和栈的区别" class="headerlink" title="说说堆和栈的区别"></a>说说堆和栈的区别</h1><details class="folding-tag" cyan><summary> 说说堆和栈的区别 </summary>              <div class='content'>              <ol><li>内存管理方式：栈采用静态内存分配，而堆采用动态内存分配。栈的大小在编译时就已经确定，而堆的大小可以在运行时动态调整</li><li>存储内容：栈主要用于存储基本数据类型（int、float、boolean等）以及对象的引用，而堆主要负责存储对象实例</li><li>内存分配方式：栈的内存分配方式是后进先出，而堆是随意分配、随意释放</li><li>存储效率：由于栈采用静态内存分配，因此它的存取速度比堆更快，而堆则因为需要进行动态内存分配和垃圾回收等操作，因此存取速度相对较慢</li><li>内存回收机制：栈的内存由JVM自动管理，当方法结束时，栈中的内存会自动被释放；而堆内存则由JVM的垃圾回收机制进行管理，当对象没有被引用时，垃圾回收机制会自动回收该对象占用的内存空间 </li></ol>              </div>            </details><h1 id="什么时候会触发FULL-GC"><a href="#什么时候会触发FULL-GC" class="headerlink" title="什么时候会触发FULL GC"></a>什么时候会触发FULL GC</h1><details class="folding-tag" cyan><summary> 什么时候会触发FULL GC </summary>              <div class='content'>              <ul><li>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</li></ul><ol><li><p><code>老年代空间不足</code>   </p><ul><li>老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space。为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</li></ul></li><li><p><code>永久代空间满</code></p><ul><li>永久代中存放的为一些类的信息等，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</li></ul></li><li><p><code>CMS GC时出现晋升失败和并发模式失败</code></p><ul><li>对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有晋升失败和并发模式失败两种状况，当这两种状况出现时可能会触发Full GC。晋升失败是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；并发模式失败是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的。应对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。</li></ul></li><li><p><code>统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间</code></p><ul><li>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到老年代导致老年代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发Full GC。</li></ul></li></ol>              </div>            </details><h1 id="什么是Java虚拟机？为什么Java被称为平台无关的编程语言"><a href="#什么是Java虚拟机？为什么Java被称为平台无关的编程语言" class="headerlink" title="什么是Java虚拟机？为什么Java被称为平台无关的编程语言"></a>什么是Java虚拟机？为什么Java被称为平台无关的编程语言</h1><details class="folding-tag" cyan><summary> 什么是Java虚拟机？为什么Java被称为平台无关的编程语言 </summary>              <div class='content'>              <ul><li><p>Java虚拟机（JVM）是Java语言的核心组成部分之一，是一种在计算机上模拟运行Java字节码的虚拟机。Java虚拟机可以理解为一个运行Java程序的环境，它提供了一个统一的接口，将Java程序与底层操作系统隔离开来，使得Java程序可以在不同的操作系统上运行。</p></li><li><p>Java被称为平台无关的编程语言，这是因为Java程序是编译成Java字节码，而不是针对某个具体的操作系统或硬件架构编译的机器码。Java字节码可以在任何装有Java虚拟机的操作系统上运行，因为Java虚拟机会将字节码转换成操作系统能够理解的机器码，从而实现跨平台的能力。</p></li></ul>              </div>            </details><h1 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h1> <details class="folding-tag" cyan><summary> Java内存结构 </summary>              <div class='content'>              <ol><li><code>程序计数器</code>(Program Counter Register)：每个线程都有一个程序计数器，它是线程私有的，用于记录当前线程正在执行的字节码指令的地址或者下一条指令的地址。如果执行的是native方法，则计数器为空。</li><li><code>Java虚拟机栈</code>(Java Virtual Machine Stack)：Java虚拟机栈也是线程私有的，用于存储每个县城的方法调用栈。每当一个方法被调用时，JVM都会为该方法分配一个栈帧，该栈帧包含了该方法的参数、局部变量以及操作数栈等信息。方法在返回时，JVM会弹出该栈帧。栈的大小可以是固定的，也可以是动态扩展的。栈的大小决定了方法调用的可达深度（递归调用次数，或者嵌套调用层数等，可以使用<code>-Xss</code>参数设置虚拟机栈的大小）。如果请求的栈深度大于最大可用深度，则会抛出<code>StackOverFlowError</code>。如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutOfMemoryError</li><li><code>本地方法栈</code>(Native Method Stack)：本地方法栈也是线程私有的，与虚拟机栈类似，不同之处在于它为JVM执行本地方法(Native Method)服务</li><li><code>方法区</code>(Method Area)：方法区用于存储已被加载的类的信息、常量池、静态变量、即时编译器编译后的代码等信息。方法区也是由垃圾回收器进行管理和回收的</li><li><code>堆</code>(Java Heap)：堆是JVM中最大的内存区域，用于存储对象实例以及数组等数据。Java堆的内存空间是由垃圾回收器进行管理和回收的</li></ol>              </div>            </details><h1 id="说说对象分配规则"><a href="#说说对象分配规则" class="headerlink" title="说说对象分配规则"></a>说说对象分配规则</h1><details class="folding-tag" cyan><summary> 说说对象分配规则 </summary>              <div class='content'>              <ul><li>对象优先分配在Eden区，如果Eden区没有足够的空间，虚拟机执行一次Minor GC</li><li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区（from和to）之间发生大量的内存拷贝（新生代采用复制算法收集内存，避免产生大量内存碎片）</li><li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了一次Minor GC，那么对象就会进入Survivor区，之后每经过一次Minor GC，对象年龄加一，直到达到阈值，对象进入老年区</li><li>动态判断对象的年龄，如果Survivor区中相同年龄的虽有对象大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象可以直接进入老年代。</li><li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小<ul><li>如果这个值大于老年区的剩余值，则进行一次FULL GC，</li><li>如果小于，则检查HandlePromotionFailure设置，如果为true，则只进行Monitor GC，如果为false，则进行FULL GC</li></ul></li></ul>              </div>            </details><h1 id="说说Java对象创建过程"><a href="#说说Java对象创建过程" class="headerlink" title="说说Java对象创建过程"></a>说说Java对象创建过程</h1><details class="folding-tag" cyan><summary> 说说Java对象创建过程 </summary>              <div class='content'>              <ul><li>Java对象的创建过程可以概括为以下几个步骤<ol><li><code>类加载</code>：JVM会先检查类是否已经被加载了，如果没有则通过类加载器加载类的class文件，并将类的信息存储到方法区中</li><li><code>内存分配</code>：当类被加载后，JVM会为该类的对象分配内存，根据Java对象的特点，内存大小是在编译时就已经确定的，因此内存分配可以通过一些简单的算法来实现，例如<code>指针碰撞</code>和<code>空闲列表</code>等</li><li><code>初始化</code>：内存分配完成后，JVM会对对象进行默认初始化，即将对象的成员变量赋上默认值。基本类型的默认值是0或false，引用类型的默认值是null</li><li><code>构造函数</code>：默认初始化后，JVM会调用该对象的构造函数，进行对象的属性初始化和一些其他操作</li><li><code>返回地址</code>：构造函数执行完毕后，JVM会将对象的引用返回给调用者，此时对象创建过程完毕</li></ol></li></ul>              </div>            </details><h1 id="知道类的生命周期吗"><a href="#知道类的生命周期吗" class="headerlink" title="知道类的生命周期吗"></a>知道类的生命周期吗</h1><details class="folding-tag" cyan><summary> 知道类的生命周期吗 </summary>              <div class='content'>              <ul><li>类的生命周期包括：加载、链接、初始化、使用和卸载<ol><li><code>加载</code>：查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li><code>链接</code>：链接分为三个阶段，验证、准备、初始化<ul><li><code>验证</code>：确保Class文件符合当前虚拟机的要求，不会危害到虚拟机自身安全（前面的文章中修改魔数cafebabe之后，验证就失败了）</li><li><code>准备</code>：进行内存分配，为static修饰的类变量分配内存，并设置初始值(0或null)，不包含final修饰的静态变量，因为final变量在编译时就分配好了</li><li><code>解析</code>：将常量池中的符号引用替换为直接引用的过程，直接引用为直接指向目标的指针或者相对偏移量等</li></ul></li><li><code>初始化</code>：为类的静态变量赋予正确的初始值</li><li><code>使用</code>：new出对象在程序中使用</li><li><code>卸载</code>：当该类不再被引用时，执行垃圾回收</li></ol></li></ul>              </div>            </details><h1 id="简述Java对象结构"><a href="#简述Java对象结构" class="headerlink" title="简述Java对象结构"></a>简述Java对象结构</h1><details class="folding-tag" cyan><summary> 简述Java对象结构 </summary>              <div class='content'>              <ul><li>Java对象由三个部分组成：对象头、实例数据、对其填充<ol><li><code>对象头</code>：对象头由两部分组成<ul><li>第一部分存储对象自身运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）</li><li>第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象投中还有一部分用来记录数组长度</li></ul></li><li><code>实例数据</code>：用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</li><li><code>对齐填充</code>：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）</li></ol></li></ul>              </div>            </details><h1 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h1><details class="folding-tag" cyan><summary> 如何判断对象可以被回收 </summary>              <div class='content'>              <ul><li>判断对象是否存活一般有两种方式<ol><li><code>引用计数</code>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1。计数为0时可以回收，此方法较为简单，无法解决对象循环引用的问题</li><li>可达性分析：从GC Roots开始向下搜索，搜索所走过的路径成为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，即为不可达对象，可以被回收</li></ol></li></ul>              </div>            </details><h1 id="你知道哪些垃圾回收算法"><a href="#你知道哪些垃圾回收算法" class="headerlink" title="你知道哪些垃圾回收算法"></a>你知道哪些垃圾回收算法</h1><details class="folding-tag" cyan><summary> 你知道哪些垃圾回收算法 </summary>              <div class='content'>              <ul><li>GC最基础的算法有三种：标记-清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法<ol><li><code>标记-清除算法</code>：首先标记出所有仍然使用的对象，在标记完成后清理掉未被标记的垃圾对象。它的主要缺点是会产生内存碎片。</li><li><code>复制算法</code>：将堆内存分为两个区域，每次只使用其中一块。当着一块用完之后，将所有存活的对象复制到另一块未使用的区域，同时将这一块整个清空。这种算法的缺点是需要耗费两倍的内存空间，适用于对象存活率比较低的情况</li><li><code>标记-压缩算法</code>：标记过程与标记清除算法一样，但后续的步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向同一端移动，然后清理掉端边界以外的内存。它的主要缺陷是需要大量的对象移动操作，影响性能</li><li><code>分代收集算法</code>：根据对象的特征和存活周期，将堆内存划分为不同的区域，一般分为新生代和老年代。不同的区域使用不同的垃圾收集算法和参数设置。例如年轻代通常采用复制算法，老年代采用标记整理算法或分块整理等</li><li><code>G1收集器</code>：它是一个面向服务端应用的垃圾收集器，采用分代收集算法，将堆内存划分为多个region，并动态做垃圾回收。G1适用于大型、多核、高并发应用下的垃圾回收</li></ol></li></ul>              </div>            </details><h1 id="你知道哪些JVM诊断和监控工具"><a href="#你知道哪些JVM诊断和监控工具" class="headerlink" title="你知道哪些JVM诊断和监控工具"></a>你知道哪些JVM诊断和监控工具</h1><details class="folding-tag" cyan><summary> 你知道哪些JVM诊断和监控工具 </summary>              <div class='content'>              <ul><li>JVM调优命令大多数都是针对HotSpot虚拟机的。以下列举了一些常见的JVM调优命令：</li></ul><ol><li><p>jps（JVM Process Status Tool）：用于显示指定系统内所有的HotSpot虚拟机进程。</p></li><li><p>jstat（JVM statistics Monitoring）：用于监视虚拟机运行时状态信息的命令，可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p></li><li><p>jmap（JVM Memory Map）：用于生成虚拟机Heap dump文件。</p></li><li><p>jhat（JVM Heap Analysis Tool）：与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。</p></li><li><p>jstack：用于生成Java虚拟机当前时刻的线程快照。</p></li><li><p>jinfo（JVM Configuration info）：实时查看和调整虚拟机运行参数。</p></li><li><p>Java VisualVM：基于图形界面的虚拟机监控和分析工具，可以显示系统中运行的多个JVM实例，并提供强大的信息收集和可视化功能。</p></li><li><p>Java Mission Control (JMC)：商业级别的JVM监控和管理工具，提供更高级和精细的诊断和调试能力。</p></li><li><p>GCViewer：用于分析和可视化JVM垃圾收集数据的开源工具。</p></li><li><p>JConsole：Java GUI工具，可以连接到JVM进程并显示重要的性能指标和变量值。</p></li><li><p>Perf：Linux平台上常用的性能监控工具，其中包含针对JVM应用程序的性能测量工具。</p></li></ol>              </div>            </details><h1 id="Minor-GC和Full-GC分别发生在什么时候"><a href="#Minor-GC和Full-GC分别发生在什么时候" class="headerlink" title="Minor GC和Full GC分别发生在什么时候"></a>Minor GC和Full GC分别发生在什么时候</h1><details class="folding-tag" cyan><summary> Minor GC和Full GC分别发生在什么时候 </summary>              <div class='content'>              <ul><li>在新生代垃圾收集时，年轻代中的Eden区满了就会触发Minor GC。此外，还有一种情况是，当对象经过多次Minor GC后仍然存活并且无法放入Survivor区域时，它们就会被晋升到老年代。如果老年代空间也不够用，就会出现Full GC。</li></ul>              </div>            </details><h1 id="你知道哪些JVM性能调优参数"><a href="#你知道哪些JVM性能调优参数" class="headerlink" title="你知道哪些JVM性能调优参数"></a>你知道哪些JVM性能调优参数</h1><details class="folding-tag" cyan><summary> 你知道哪些JVM性能调优参数 </summary>              <div class='content'>              <ol><li><p><code>-Xms</code>：设置JVM堆最小值，如-Xms2g表示堆的最小值为2GB。</p></li><li><p><code>-Xmx</code>：设置JVM堆最大值，如-Xmx4g表示堆的最大值为4GB。</p></li><li><p><code>-XX:NewRatio</code>：设置年轻代与老年代的比例，默认为2，如-XX:NewRatio=3表示年轻代与老年代的比例为3:1。</p></li><li><p><code>-XX:MaxPermSize</code>：设置永久代的最大大小，如-XX:MaxPermSize=256m表示设置最大永久代大小为256MB。</p></li><li><p><code>-XX:+UseParallelGC</code>：启用并行垃圾回收器，适用于多核服务器环境。</p></li><li><p><code>-XX:+UseConcMarkSweepGC</code>：启用CMS垃圾回收器，适用于在用户线程不可中断的情况下执行垃圾收集。</p></li><li><p><code>-XX:+UseG1GC</code>：启用G1垃圾回收器，适用于大内存和高并发环境。</p></li><li><p><code>-verbose:gc</code>：开启JVM堆垃圾回收的详细输出，以便分析GC行为和性能瓶颈。</p></li><li><p><code>-XX:+HeapDumpOnOutOfMemoryError</code>：在内存溢出错误发生时自动转储此时的堆内存内容，方便后续分析错误原因。</p></li></ol>              </div>            </details><h1 id="对象一定分配在堆中吗？有没有了解逃逸分析技术"><a href="#对象一定分配在堆中吗？有没有了解逃逸分析技术" class="headerlink" title="对象一定分配在堆中吗？有没有了解逃逸分析技术"></a>对象一定分配在堆中吗？有没有了解逃逸分析技术</h1><details class="folding-tag" cyan><summary> 对象一定分配在堆中吗？有没有了解逃逸分析技术 </summary>              <div class='content'>              <ul><li>对象不一定分配在堆中，JVM会对对象进行<code>逃逸分析</code>，即分析对象是否会被<code>方法外</code>的其他代码使用，如果不会，则可以将对象的内存<code>分配在栈</code>上，从而提升性能。</li><li>逃逸分析(Escape Analysis)是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，<code>Java Hotspot</code>编辑器能够分析出一个新的对象的引用的适用范围，从而决定是否要将该对象分配到堆上</li><li>逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸（Escape）。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，我们就成长股对象的指针发生了逃逸</li><li>逃逸分析的好处<ol><li>栈上分配：可以降低垃圾收集器运行的频率</li><li>同步消除：如果发现某个对象只能从一个线程访问，那么在这个度向上的操作可以不需要同步</li><li>标量替换：把对象分解为一个个基本模型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有：减少内存使用，因为不用生成对象头；程序内存回收效率高，并且GC频率也会减少</li></ol></li></ul>              </div>            </details><h1 id="虚拟机为什么使用元空间替换了永久代"><a href="#虚拟机为什么使用元空间替换了永久代" class="headerlink" title="虚拟机为什么使用元空间替换了永久代"></a>虚拟机为什么使用元空间替换了永久代</h1><details class="folding-tag" cyan><summary> 虚拟机为什么使用元空间替换了永久代 </summary>              <div class='content'>              <ul><li>移除永久代主要是解决了几个问题：</li></ul><ol><li><p>内存溢出问题。永久代的大小是固定的，当加载的类和方法等元数据超出了其大小的限制，就会出现OutOfMemoryError。而元空间的大小是动态变化的，取决于运行时的需求和系统内存大小，因此更加灵活，可以避免因为加载的类和方法等元数据过多而造成的内存溢出问题。</p></li><li><p>内存回收效率问题。永久代的内存回收效率非常低，常常需要进行Full GC来回收垃圾，导致程序的性能下降。而元空间采用的是基于标记清除算法的内存回收方式，由于其内存大小的动态变化，所以可以分阶段进行内存回收，避免了Full GC的发生，因此能够更加高效地回收垃圾。</p></li><li><p>元数据共享问题。在永久代中，每个虚拟机都有一份私有的永久代，即便是加载相同的类和方法，也会占用不同的内存空间。而在元空间中，可以实现元数据的共享，避免了重复加载相同的类和方法等元数据，节约了内存空间。</p></li></ol>              </div>            </details><h1 id="什么是Stop-The-World？什么是OopMap？什么是安全点"><a href="#什么是Stop-The-World？什么是OopMap？什么是安全点" class="headerlink" title="什么是Stop The World？什么是OopMap？什么是安全点"></a>什么是Stop The World？什么是OopMap？什么是安全点</h1><details class="folding-tag" cyan><summary> 什么是Stop The World？什么是OopMap？什么是安全点 </summary>              <div class='content'>              <ol><li><p><code>Stop The World</code>指的是在Java虚拟机（JVM）中，为了进行垃圾回收或其他一些必须操作，而暂停所有应用程序线程的状态。这种状态的出现是由于垃圾回收器只能在应用程序线程暂停时访问内存。当应用程序线程暂停时，所有线程都被挂起，无法继续执行，直到垃圾回收完成并且内存管理完成。</p></li><li><p><code>OopMap</code>是指<code>对象指针映射</code>（Object Oriented Pointer Maps）的简称。在HotSpot虚拟机中，当进行垃圾回收时，需要扫描堆内存中的对象，使用OopMap可以更快地确定哪些对象是可达的。</p></li><li><p><code>安全点</code>（Safepoint）是指在应用程序的执行过程中，合适的位置，安全地停止应用程序，在这个位置上应用程序的堆栈和寄存器信息都是可知的。在这个点上，JVM可以停止所有应用程序线程，以便执行垃圾回收或其他操作。在安全点上停止应用程序线程对应用程序的执行是透明的，并且返回应用程序恢复执行的速度会很快。</p></li></ol>              </div>            </details><h1 id="说一下JVM的主要组成部分及其作用"><a href="#说一下JVM的主要组成部分及其作用" class="headerlink" title="说一下JVM的主要组成部分及其作用"></a>说一下JVM的主要组成部分及其作用</h1><details class="folding-tag" cyan><summary> 说一下JVM的主要组成部分及其作用 </summary>              <div class='content'>              <ul><li>JVM包含两个子系统和两个组件<ol><li>类加载器子系统(Class Loader)：负责将.class文件中的二进制字节码加载到内存中，并生成对应的Class对象。</li><li>执行引擎子系统(Execution Engine)：负责解释执行字节码或者运行时动态生成的本地代码，是JVM最核心的部分。</li><li>运行时数据区组件(Runtime Data Areas)：包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等。其中，方法区用于存储类的信息、常量池、静态变量、即时编译器编译后的代码等；堆用于存储创建的对象实例；虚拟机栈和本地方法栈用于存储方法执行过程中的局部变量表、操作数栈、方法出口等信息；程序计数器用于记录线程执行位置的指针。</li><li>本地方法接口组件(Native Interface)：与C/C++等语言交互的接口，可以调用底层系统提供的库函数。</li></ol></li></ul>              </div>            </details><h1 id="什么是指针碰撞"><a href="#什么是指针碰撞" class="headerlink" title="什么是指针碰撞"></a>什么是指针碰撞</h1><details class="folding-tag" cyan><summary> 什么是指针碰撞 </summary>              <div class='content'>              <ul><li>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的内存都被放到一边，空闲内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配的内存仅仅是把那个空闲指针向空闲方向挪动一段与对象大小相等的实例，这种分配方式就是指针碰撞<br><img src="https://s1.ax1x.com/2023/04/16/p99aVQe.png" alt=""></li></ul>              </div>            </details><h1 id="什么是空闲列表"><a href="#什么是空闲列表" class="headerlink" title="什么是空闲列表"></a>什么是空闲列表</h1><details class="folding-tag" cyan><summary> 什么是空闲列表 </summary>              <div class='content'>              <ul><li>如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞。虚拟机必须维护一个列表，记录哪些内存是可用的，再分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表</li></ul>              </div>            </details><h1 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a>什么是TLAB</h1><details class="folding-tag" cyan><summary> 什么是TLAB </summary>              <div class='content'>              <ul><li><code>TLAB</code>(Thraed-Local Allocation Buffer)是Java虚拟机针对线程私有对象内存分配的而设计的一种优化手段。他是在Java堆内存中划分出每个线程私有的缓存区域，线程可以在这个缓存区中分配内存，无需同步，从而避免了多线程竞争和同步带来的性能开销。通过VM参数<code>-XX:+UseTLAB</code>来启用</li></ul>              </div>            </details><h1 id="对象头具体包含哪些内容"><a href="#对象头具体包含哪些内容" class="headerlink" title="对象头具体包含哪些内容"></a>对象头具体包含哪些内容</h1><details class="folding-tag" cyan><summary> 对象头具体包含哪些内容 </summary>              <div class='content'>              <ul><li>对象头包含以下两部分内容<ol><li><code>Mark Word</code>：标记字段包含一些标记位和哈希码信息。<ul><li>其中标记位包含对象的锁状态、GC状态、偏向锁线程ID等信息</li><li>哈希码是为了提高JVM在哈希表等数据结构中查找对象的效率而添加的，可以提高查找速度的同时不会涉及到对象的内容</li></ul></li><li><code>Class Pointer</code>：类指针指向该对象的类元数据信息，JVM通过该指针可以确定对象所属的类，进而获取类的类型信息和方法信息</li></ol></li></ul>              </div>            </details><h1 id="你知道哪些JVM调优参数"><a href="#你知道哪些JVM调优参数" class="headerlink" title="你知道哪些JVM调优参数"></a>你知道哪些JVM调优参数</h1><details class="folding-tag" cyan><summary> 你知道哪些JVM调优参数 </summary>              <div class='content'>              <ul><li><code>堆栈内存相关</code><ul><li>-Xms 设置初始堆的大小</li><li>-Xmx 设置最大堆的大小</li><li>-Xmn 设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</li><li>-Xss 每个线程的堆栈大小</li><li>-XX:NewSize 设置年轻代大小(for 1.3/1.4)</li><li>-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)</li><li>-XX:NewRatio 年轻代与年老代的比值(除去持久代)</li><li>-XX:SurvivorRatio Eden区与Survivor区的的比值</li><li>-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</li><li>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</li></ul></li><li><code>垃圾收集器相关</code> <ul><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</li><li>-XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul></li><li><code>辅助信息相关</code><ul><li>-XX:+PrintGCDetails 打印GC详细信息</li><li>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照，排查问题用</li><li>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FULL GC造成问题.</li><li>-XX:+PrintTLAB 查看TLAB空间的使用情况</li></ul></li></ul>              </div>            </details><h1 id="说一下JVM有哪些垃圾回收器"><a href="#说一下JVM有哪些垃圾回收器" class="headerlink" title="说一下JVM有哪些垃圾回收器"></a>说一下JVM有哪些垃圾回收器</h1><details class="folding-tag" cyan><summary> 说一下JVM有哪些垃圾回收器 </summary>              <div class='content'>              <ol><li><p>Serial收集器（复制算法）：</p><ul><li>新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li></ul></li><li><p>ParNew收集器 (复制算法)：</p><ul><li>新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li></ul></li><li><p>Parallel Scavenge收集器 (复制算法)：</p><ul><li>新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li></ul></li><li><p>Serial Old收集器 (标记-整理算法)：</p><ul><li>老年代单线程收集器，Serial收集器的老年代版本；</li></ul></li><li><p>Parallel Old收集器 (标记-整理算法)：</p><ul><li>老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li></ul></li><li><p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：</p><ul><li>老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li></ul></li><li><p>G1(Garbage First)收集器 (标记-整理算法)：</p><ul><li>Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆（包括新生代，老年代），而前六种收集器回收的范围仅限于新生代或老年代。</li></ul></li><li><p>ZGC (Z Garbage Collector)：</p><ul><li>是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在 JDK 11 新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。优点：低停顿，高吞吐量，ZGC 收集过程中额外耗费的内存小。缺点：浮动垃圾。</li></ul></li></ol>              </div>            </details><h1 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h1><details class="folding-tag" cyan><summary> 如何选择垃圾收集器 </summary>              <div class='content'>              <ul><li><p>如果你的堆大小不是很大（比如 100MB），选择串行收集器一般是效率最高的。</p><ul><li>参数：-XX:+UseSerialGC。</li></ul></li><li><p>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。</p><ul><li>参数：-XX:+UseSerialGC。</li></ul></li><li><p>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。</p><ul><li>参数：-XX:+UseParallelGC。</li></ul></li><li><p>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，</p><ul><li>那么选择 G1、ZGC、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些。</li><li>参数：<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+UseG1GC</li><li>-XX:+UseZGC </li></ul></li></ul></li><li><p>从上述出发点来看，对于 Web 服务器这样对响应性要求非常高的应用程序，CMS、G1、ZGC可能是最好的选择。对于某些定时任务，使用并行收集器则是一个合理的选择。</p></li></ul>              </div>            </details><h1 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h1><details class="folding-tag" cyan><summary> 什么是类加载器 </summary>              <div class='content'>              <ul><li><p>类加载器（Class Loader）是Java虚拟机的一个子系统，主要负责加载Java字节码文件（.class）并将其转换为运行时的Java类。当一个类被首次使用时，类加载器会将其读入内存，并生成一个对应的Class对象，用于在运行时对这个类进行访问。</p></li><li><p>类加载器是Java虚拟机中一个非常重要的机制，因为它可以实现类的动态加载，也就是说，程序在运行时可以加载之前没有预先定义的类。这个机制主要用于实现Java应用程序的插件化和动态扩展功能。</p></li><li><p>Java虚拟机本身提供了三种类加载器：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和系统类加载器（System Class Loader）。每个类加载器都有其特定的加载范围和加载方式，并且对于同一个类，不同的类加载器可能会产生不同的实例。</p></li></ul>              </div>            </details><h1 id="什么是Tomcat类加载机制"><a href="#什么是Tomcat类加载机制" class="headerlink" title="什么是Tomcat类加载机制"></a>什么是Tomcat类加载机制</h1><details class="folding-tag" cyan><summary> 什么是Tomcat类加载机制 </summary>              <div class='content'>              <ul><li><p>Tomcat是一个Java Web应用程序服务器，其类加载机制是基于Java虚拟机（JVM）的标准类加载器体系，并在此基础上进行了一定的扩展和优化。与Java虚拟机的标准类加载器类似，Tomcat的类加载器也采用了委派机制进行类的加载。</p></li><li><p>当Tomcat需要加载一个类时，它会首先查找父类加载器是否已经加载了该类，如果没加载则会委派给父类加载器加载，直到最终是启动类加载器去加载，如果该类在父类加载器中已经被加载，则Tomcat的加载器会直接返回父类加载器所加载的类。</p></li><li><p>为了支持Web应用程序的隔离和热部署，Tomcat的类加载器体系还包括了一个专门的Web应用程序类加载器，每个Web应用程序在Tomcat中都会拥有一个独立的类加载器。Web应用程序类加载器会首先加载Web应用程序自身的类，然后委派父类加载器加载其他依赖的类。</p></li><li><p>这种基于委派机制的类加载器体系，使得Tomcat可以实现Web应用程序的隔离和动态部署，同时也保证了Web应用程序与Tomcat本身的类库不会发生冲突。</p></li></ul>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础汇总</title>
      <link href="/2023/04/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/"/>
      <url>/2023/04/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>Java语言有哪些特点<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>简单易学：Java有丰富的类库，不用手写轮子</li><li>面向对象：Java是一门面向对象的语言，支持封装、继承、多态</li><li>跨平台性：Java程序可以在不同的操作系统和硬件平台上运行，实现了<code>一次编写，到处运行的目标</code></li><li>安全性：Java具有高度的安全性，提供了注入类加载器、安全管理器和异常处理机制等安全机制<ul><li>Java类加载器采用双亲委派模式，即在加载类时先从父类加载器中查找对应的类，如果父类加载器中没有找到，则再去子类加载器中查找。这种机制可以防止对Java核心类库的篡改，并确保应用程序使用的是正确的类。如果你自己手写了一个Object类，这个手写的Object类是不会被加载的，而是会使用Java提供的Object类</li><li>如果你就是想用自己写的Object类，那么需要自定义类加载器，重写其findClass方法</li></ul></li><li>多线程：Java语言支持多线程编程，可以方便的实现并发操作</li><li>开放性：Java是一种开放性语言，具有开放的标准和规范，可以与其他语言进行交互和集成</li><li>高性能：Java的性能不断提高，特别是JIT编译器的引用使得Java程序的性能可以与C++等编译型语言媲美<ul><li>当JIT编译器发现某个方法被频繁调用时，它会将该方法的字节码转换为本地机器码来提高执行速度。这是因为字节码是一种跨平台的中间代码，其性能较低，而本地机器码是针对特定硬件平台的机器指令，其性能更高。</li></ul></li></ol>              </div>            </details></li><li>面向对象和面向过程的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>面向过程</code>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用时调用即可。性能较高，单片机、嵌入式开发一般采用面向过程开发</li><li><code>面向对象</code>：是把构成问题的事物分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有<code>封装</code>、<code>继承</code>、<code>多态</code>的特性，所以<code>易维护</code>、<code>易复用</code>、<code>易扩展</code>。可以设计出低耦合的系统，但是从性能上来说，要比面向过程要低。</li></ul>              </div>            </details></li><li>八种基本数据类型的大小，以及他们的封装类<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">大小（字节）</th><th style="text-align:center">封装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1</td><td style="text-align:center">Boolean</td></tr></tbody></table></div><ol><li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。</li><li>基本数据类型在声明时，系统会自动给它分配空间，而引用类型声明也只是分配了引用空间，必须通过实例化开辟数据空间后才可以赋值。</li><li>数组对象也是一个引用对象，将一个数组赋值给另一个数组时，只是复制了一个引用，所以通过某一个数组所做的修改，在另一个数组中也看得见<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = arr1;</span><br><span class="line">        <span class="comment">// 只改变arr2的值，输出结果中arr1和arr2的值都改变了</span></span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            System.out.print(arr2[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// arr1 和 arr2 的地址是一致的</span></span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>虽然Java语言中定义了boolean类型，但是在Java虚拟机中，没有专门的字节码指令用于处理boolean类型的值。相反，编译器将boolean类型的值编译成Java虚拟机中的int类型，其中0表示false，非0表示true。同样，boolean类型的数组在Java虚拟机中被编码为byte类型的数组。这是因为Java虚拟机的设计者们认为，使用int类型来代替boolean类型，不会对性能造成太大的影响，而且可以简化虚拟机的实现。</li></ol>              </div>            </details></li><li>标识符的命名规则<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>标识符的含义：</code>在程序中，我们自定义的内容，例如类的名字、方法名称、变量名称等，都是标识符</li><li><code>命名规则：</code>标识符可以包含英文字母、<code>0-9</code>的数字、<code>$</code>以及<code>_</code>，标识符不能以数字开头，不能是关键字</li><li><code>命名规范：</code>类名首字母大写，驼峰命名法。变量名、方法名首字母小写，后续也是驼峰命名</li></ul>              </div>            </details></li><li>instanceof关键字的作用<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>instanceof严格来说是Java中的一个双目运算符，用来测试一个对象是否为另一个对象的实例，用法如下  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj instance Class</span><br></pre></td></tr></table></figure><ul><li>其中obj为一个对象，Class表示一个类或者一个接口，当obj为Class对象，或为其子类、实现类，结果返回true，否则返回false</li></ul></li><li>注意：编译器会检查obj是否能转换为右边class类型，如果不能转换则直接报错  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> res = i <span class="keyword">instanceof</span> Integer;     <span class="comment">// 编译不通过：不可转换的类型；无法将 &#x27;int&#x27; 转换为 &#x27;java.lang.Integer&#x27;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> res = i <span class="keyword">instanceof</span> Integer;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li>JavaSE规范中对instanceof运算符的规定是：如果obj为null，那么返回结果总为false  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> res = <span class="keyword">null</span> <span class="keyword">instanceof</span> Integer;</span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li>Java自动装箱与拆箱<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>装箱就是自动将基本数据类型转换为包装类型（int -&gt; Integer）；底层调用的是Integer的valueOf(int)方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Integer i = Integer.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li>拆箱就是自动将包装类型转换为基本数据类型（Integer -&gt; int）；底层调用的是intValue()方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">int</span> j = i.valueOf(i);</span><br></pre></td></tr></table></figure></li><li><code>面试题1：</code>下面的代码会输出什么<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">100</span>;</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line">        Integer c = <span class="number">200</span>;</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li><li>为什么会出现这样的结果呢？输出表明a和b指向的是同一个对象，而c和d指向的不是同一个对象，我们来看一下Integer.valueOf()方法的底层源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>从注释中我们可以看到，此方法将始终缓存-128到127之间的值。</li><li>也就是如果数值在-128和127之间，就会返回IntegerCache.cache中已经存在的对象的引用，否则创建一个新的Integer对象。所以上面的代码中，a和b的数值为100，就是从缓存中取的已存在的对象，指向的是同一个对象，所以返回true；而c和d的值为200，并不在缓存中，所以是新建的Integer对象，所以返回false</li></ul>              </div>            </details></li><li>重载和重写的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>重载(Overload)：</code>是指在一个类中定义多个方法，它们具有相同的名称，但具有不同的参数列表（个数、类型、顺序），一边在不同的情况下可以调用不同的方法，重载方法可以在一个类中定义，也可以在不同类种定义，只要它们的方法签名不同即可</li><li>例如下面的代码定义了一个名为sum的重载方法，它可以接收不同类型和数量的参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>重写(Override)</code>：是指在子类中重新定义（覆盖）父类中已有的方法，以便实现不同的功能或适应不同的需求。重写方法必须和父类中的方法具有相同的方法名称、参数列表和返回值类型，并且访问权限不能比父类中的方法更严格<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过重写方法，我们可以在子类中实现特定的功能，同时也可以保留父类中的方法实现。重写方法通常用于实现多态性和集成特性。</li></ul>              </div>            </details></li><li>equals和==的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>==</code>比较两个对象的引用是否相同，也就是比较它们在内存中的地址是否相同，如果两个对象的引用相同，则返回true，否则返回false</li><li>例如下面代码中创建两个String类型的对象，他们的值相同但是引用不同，使用<code>==</code>比较会返回<code>false</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>equals</code>是比较两个对象的内容是否相同，也就是比较它们的值是否相同。如果两个对象的内容相同，则返回true，否则返回false。在Java中，Object类的equals()方法默认实现是使用<code>==</code>比较两个对象的引用，但可以在子类中重写该方法以实现比较对象内容的功能。</li><li>例如下面的代码中创建了两个String类型的对象，它们的值相同，所以使用<code>equals</code>比较会返回<code>true</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li>hashCode的作用<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>Java</code>的集合有两类，一类是<code>List</code>，另一类是<code>Set</code>。前者有序可重复，后者无序不可重复。当我们在<code>Set</code>中插入的时候，如何判断已经存在该元素了呢？<ul><li>可以通过<code>equals</code>方法来判断，但是如果元素太多，用这样的方法就会比较慢</li></ul></li><li>于是就有人发明了哈希算法来提高集合中查找元素的效率，这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域</li><li><code>hashCode</code>可以这样理解：它返回的是根据对象内存地址换算出的一个值。这样一来，当set需要添加新元素时，先调用这个元素的<code>hashCode</code>方法，就能一下子定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不需要再进行任何比较了；如果这个位置上已经有元素了，就调用它的<code>equals</code>方法与新元素进行比较，如果相同就不用存了，不相同就散列其他的地址。这样一来实际调用<code>equals</code>方法的次数就大大降低了。</li></ul>              </div>            </details></li><li>String、StringBuilder、StringBuffer的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>String是只读字符串，并不是基本数据类型，而是一个对象，从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改，每次对String的操作都会生成新的String对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></li><li>每次<code>+</code>操作：隐式在堆上<code>new</code>了一个跟原字符串相同的<code>StringBuilder</code>对象，再调用append方法，拼接<code>+</code>后面的字符</li><li>StringBuffer和StringBuilder都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></li><li>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuilder和StringBuffer来进行操作。</li><li>另外StringBuffer对方法加了同步锁或者对调用的方法加了同步锁（底层源码方法都加了synchronized），所以线程是安全的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">long</span> lng)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(lng);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>StringBuilder没有对方法进行加同步锁，所以是非线程安全的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">long</span> lng)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(lng);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li>ArrayList和LinkedList的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>内部实现：</code>ArrayList是基于动态数组实现的，内部使用Object[]数组来存储元素。而LinkedList是基于双向链表实现的，内部使用Node节点来存储元素</li><li><code>插入和删除操作：</code>ArrayList对于中间位置的插入和删除需要移动元素，因为它的底层是数组，需要将后面的元素往后移动，而LinkedList只需要修改节点的指针即可。因此，LinkedList在插入和删除操作方面比ArrayList效率更高</li><li><code>随机访问：</code>由于ArrayList的底层是数组，所以可以根据下标快速随机访问元素，时间复杂度为O(1)；而LinkedList是基于链表实现的，不能直接根据下标访问元素，需要从头或者从尾遍历到指定位置，时间复杂度为O(n)。</li><li><code>内存占用：</code>由于LinkedList的每个元素都需要一个额外指针来指向下一个节点，因此占用的内存空间会比ArrayList多</li></ol>              </div>            </details></li><li>HashMap和Hashtable的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>二者父类不同：</code>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了Map、Cloneable、Serializable这三个接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><code>线程安全：</code>Hashtable是线程安全的，它的所有方法都是同步的（所有方法都用synchronized修饰），即对于多个线程同时访问一个Hashtable实例时，可以保证数据的唯一性。而HashMap不是线程安全的，如果多个线程同时访问一个HashMap实例，可能会出现数据不一致的情况</li><li><code>null键和null值的支持：</code>Hashtable不允许键或值为null，否则会抛出NullPointerException异常；而HashMap可以允许null键和null值</li><li><code>初始容量和负载因子：</code>Hashtable的初始容量和负载因子是固定的，在创建Hashtable实例时必须指定；而HashMap可以在创建时指定初始容量和负载因子，也可以在运行时动态调整</li><li><code>性能：</code>因为Hashtable是线程安全的，因此在多线程环境下使用时，会存在一定的性能问题；而HashMap不是线程安全的，在单线程环境下使用时，性能要比Hashtable高</li></ol>              </div>            </details></li><li>Collection包结构，与Collections的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Java中的Collection包含了一组接口，用于表示一组对象的集合。它提供了一些通用的操作，如添加、删除、遍历等。Collection包中的主要接口有<ol><li><code>List：</code>有序集合，可以有重复元素</li><li><code>Set：</code>无序集合，不允许有重复元素</li><li><code>Queue：</code>队列，通常用于实现先进先出(FIFO)的数据结构</li><li><code>Deque：</code>双端队列，可以在队头或队尾进行插入和删除操作</li></ol></li><li>Collections是Java中的一个工具类，它包含了一组静态方法，用于操作各种集合类型。它提供了一些常用的算法和工具方法，如排序、查找、复制等。Collections类中的方法通常是针对Collection类型的实例进行操作的</li><li>简单来说，Collection是一组结构，定义了集合的基本操作和属性，而Collections是一个工具类，提供了一些常用的算法和工具方法，用于操作各种集合类型的实例</li><li><div class="note warning no-icon flat"><p>需要注意的是：Collection和Collections之间是没有继承或实现关系的，它们是两个独立的概念</p></div></li></ul>              </div>            </details></li><li>Java的四种引用，强弱软虚<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>在Java中有四种类型的引用：强引用、软引用、弱引用、虚引用<ol><li><code>强引用(Strong Reference)：</code>是最常见的引用类型，它指向一个对象，只要强引用存在，垃圾回收器就不会回收该对象，可以通过new操作符、赋值操作符或方法调用等方式创建强引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><code>软引用(Soft Reference)：</code>是一种比较灵活的引用类型，它用来描述一些还有用，但是非必须的对象。只有当内存不足时，才会回收这些对象，可以通过SoftReference类创建软引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; str = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><code>弱引用(Weak Reference)：</code>比弱引用还要弱一些，它指向的对象只要没有强引用指向它时，就会被回收。可以通过WeakReference类创建弱引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; str = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><code>虚引用(Phantom Reference)：</code>虚引用的回收机制与弱引用差不多，但是它在被回收之前，会被放入ReferenceQueue中。而其他引用是被JVM回收后才被传入ReferenceQueue中的。由于这个机制的存在，虚引用大多是被用于引用销毁前的处理工作。同时，虚引用在创建时，必须带有ReferenceQueue<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; str = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>), <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></li></ol></li></ul>              </div>            </details></li><li>泛型常用特点<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Java中的泛型是一种类型参数化机制，它可以让代码更加灵活、可读性更强，同时也可以提高代码的安全性和可维护性。泛型的常用特点包括<ol><li><code>类型安全：</code>泛型可以让编译器在编译时就检查类型是否匹配，从而避免了很多类型转换和运行时错误</li><li><code>可重用性：</code>泛型可以让同一个类或方法适用于不同的数据类型，从而提高了代码的可重用性</li><li><code>可读性：</code>泛型可以让代码更易读，因为它可以让代码更具有表现力和可理解性</li><li><code>性能优化：</code>泛型可以让代码更加高效，因为它可以避免在运行时进行类型转换，从俄提高了程序的性能</li></ol></li><li><div class="note warning no-icon flat"><p>注意：Java中的泛型是在编译时实现的，而不是在运行时实现的。在编译时，Java编译器会进行类型擦除(Type Erasure)，将泛型类型转换为普通的类型。因此，在运行时无法获取泛型类型的具体信息</p></div></li></ul>              </div>            </details></li><li>Java创建对象有几种方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li><code>使用new关键字</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用Class类的newInstance方法</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Class cls = Class.forName(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">      MyClass obj = (MyClass) cls.newInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用Constructor类的newInstance方法</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line">      MyClass obj = constructor.newInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用clone方法</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">      MyClass obj2 = (MyClass) obj1.clone();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用反序列化</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">      ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;myFile.txt&quot;</span>));</span><br><span class="line">      out.writeObject(obj1);</span><br><span class="line">      out.close();</span><br><span class="line"></span><br><span class="line">      ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;myFile.txt&quot;</span>));</span><br><span class="line">      MyClass obj2 = (MyClass) in.readObject();</span><br><span class="line">      in.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>              </div>            </details></li><li>有没有可能两个不相等的对象有相同的hashCode<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>是有可能的，这种情况被称为<code>哈希冲突(Hash Collision)</code>，也叫哈希碰撞，是哈希算法中一种常见的情况。</li><li>但是哈希冲突不是问题，因为哈希表实现了一种解决冲突的方法，当发生哈希冲突时，哈希表会在相应的桶中存储一个链表或树（红黑树），以容纳具有相同哈希码的所有元素。因此，即使练个不同对象具有相同的哈希码，他们也可以被正确的插入和检索</li></ul>              </div>            </details></li><li>深拷贝和浅拷贝的区别是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>深拷贝：</code>是指将一个对象复制到另一个对象，新对象与原对象<code>不共享</code>引用类型属性（如数组、集合、对象等），也就是说，新对象和原对象的引用类型属性指向的是不同的地址，修改其中一个对象中的引用类型属性，不会影响另一个对象中的属性值。</li><li><code>浅拷贝：</code>是指将一个对象复制到另一个对象，新对象与原对象<code>共享</code>引用类型属性，也就是说，新对象与原对象中的引用类型属性指向的是同一个地址，修改器中一个对象的引用类型属性，会影响到另一个对象的属性值，Java中的Object类提供了clone方法来实现浅拷贝</li></ul>              </div>            </details></li><li>final有哪些用法<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>final是Java中的关键字，可以用来修饰类、方法、变量等，它的主要作用是用于定义常量、防止继承、防止重写方法等<ol><li><code>定义常量：</code>使用final关键字定义的变量称为常量，它的值在定以后就不能被修改。常量命名规范一般是大写字母加下划线，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">99999</span>;</span><br></pre></td></tr></table></figure></li><li><code>用于防止继承：</code>使用final关键字修饰的类不能被继承，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>防止重写方法：</code>使用final关键字修饰的方法不能被子类重写，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>优化性能：</code>使用final关键字可以优化代码性能。被final修饰的方法和变量在编译时就已经确定了值，因此在运行时不需要进行计算，可以减少运行时的开销，提高程序的执行效率。同时，被final修饰的方法，JVM会尝试将其内联，以提高运行效率</li><li><code>优化代码可读性：</code>在代码中使用final关键字可以使代码更易读。通过将变量声明为final，可以明确其含义，使代码更易于理解和维护<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看到这个 MAX_VALUE 我就知道这个变量是干嘛的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">99999</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul>              </div>            </details></li><li>static有哪些用法<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>static是Java中的关键字，可以用来修饰类、方法、变量等，它的主要作用是创建静态成员，可以通过类名直接访问，而不需要实例化对象<ol><li><code>用于创建静态变量：</code>使用static关键字定义的变量称为静态变量，它的值与所有该类的对象共享，并且可以直接通过类名访问<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Tmp.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>用于创建静态方法：</code>使用static关键字定义的方法称为静态方法，同样可以直接通过类名调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tmp.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>用于创建静态代码块：</code>使用static关键字定义的代码块称为静态代码块，它在类加载时执行，且只执行一次，一般用于初始化静态变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; myStaticList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 从文件中加载数据并进行解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;mydata.txt&quot;</span>);</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">            String line;</span><br><span class="line">            myStaticList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                myStaticList.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My static list contains: &quot;</span> + myStaticList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>创建静态内部类：</code>使用static关键字定义的内部类被称为静态内部类，它与外部类的对象无关，可以直接访问外部类的静态成员<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> instanceVar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 静态内部类可以直接访问外部类的静态变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;StaticVar from inner class: &quot;</span> + staticVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要创建OuterClass实例，但是可以直接创建StaticInnerClass实例，并且使用它访问外部类的静态成员</span></span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">        staticInnerClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>              </div>            </details></li><li><code>3 * 0.1 == 0.3</code>的返回值是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>由于浮点数在计算机中的存储方式和计算方式的特殊性，导致浮点数的运算结果可能与预期不符，故此表达式的返回值为false</li></ul>              </div>            </details></li><li><code>a = a + b</code>和<code>a += b</code>有什么区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>+=</code>操作会进行隐式自动类型转换，例如这里的 <code>a += b</code>会隐式的将加操作的结果类型强制转换为持有结果的类型，而a = a + b则不会自动进行类型转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个byte类型的变量相加时，结果会被自动提升为int类型。这种类型提升被称为&quot;拓宽原始转换&quot;，它适用于所有原始类型，包括byte、short、char和int。</span></span><br><span class="line"><span class="keyword">byte</span> a = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line">a = a + b;      <span class="comment">// 编译报错：不兼容的类型。实际为 int&#x27;，需要 &#x27;byte&#x27;</span></span><br><span class="line">a += b;         <span class="comment">// a = (byte)(a + b)</span></span><br></pre></td></tr></table></figure></li><li>再来看一个小案例，以下代码是否存在错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short a = 1;</span><br><span class="line">a = a + 1;</span><br></pre></td></tr></table></figure></li><li>有错误，short类型在进行运算时，会自动提升为int类型，也就是说<code>a + 1</code>的运算结果是int类型，而a是short类型，此时编译器会报错<code>不兼容的类型。实际为 int&#39;，需要 &#39;short&#39;</code>，改成<code>+=</code>的方式就好了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short a = 1;</span><br><span class="line">a += 1;</span><br></pre></td></tr></table></figure></li></ul>              </div>            </details></li><li>try catch finally，try里有return语句，finally还会执行吗<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>无论try代码块中是否包含return语句，finally块中的代码都会被执行。无论try块中有没有抛出异常，finally快中的代码都会被执行。finally块通常用于在代码中执行清理操作，例如：释放资源、关闭文件等 </li><li>需要注意的是，如果在finally块中使用了return语句，那么这个返回值会覆盖掉try块中的返回值，因此，finally块中的返回值将成为整个方法的返回值，这种做法是不推荐的。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码将输出20</li></ul></li><li>再来看看另一种情况  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_37</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码输出<code>10</code>，编译后的字节码文件如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static int test();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=1, locals=3, args_size=0</span><br><span class="line">       0: bipush        10      // 将 10 放入栈顶</span><br><span class="line">       2: istore_0              // 10 -&gt; i</span><br><span class="line">       3: iload_0               // &lt;- i(10)</span><br><span class="line">       4: istore_1              // 将 i(10) 暂存至 slot 1，目的是为了固定返回值</span><br><span class="line">       5: bipush        20      // 将 20 放入栈顶</span><br><span class="line">       7: istore_0              // 20 -&gt; i</span><br><span class="line">       8: iload_1               // 载入 slot 1 暂存的值 (10)</span><br><span class="line">       9: ireturn               // 返回栈顶的值</span><br><span class="line">      10: astore_2</span><br><span class="line">      11: bipush        20</span><br><span class="line">      13: istore_0</span><br><span class="line">      14: aload_2</span><br><span class="line">      15: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           3     5    10   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 10: 0</span><br><span class="line">      line 12: 3</span><br><span class="line">      line 14: 5</span><br><span class="line">      line 12: 8</span><br><span class="line">      line 14: 10</span><br><span class="line">      line 15: 14</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          3      13     0     i   I</span><br><span class="line">    StackMapTable: number_of_entries = 1</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 10</span><br><span class="line">        locals = [ int ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure></li><li>虽然在 finally 块中将 i 的值修改为 20，但是这不会影响 return 语句的返回值，因为在返回之前，i 的值已经被暂存到了 slot 1 中。在 finally 块中对 i 进行的修改不会影响 slot 1 中的值，因此 ireturn 指令返回的是 slot 1 中的值，即 10。</li></ul></li><li>关于字节码技术，可以参考我的这文章<div class="tag link"><a class="link-card" title="JVM类加载与字节码技术" href="https://cyborg2077.github.io/2023/04/05/JvmPart4/"><div class="left"><img src="https://s1.ax1x.com/2023/03/06/ppZ9JIS.png"/></div><div class="right"><p class="text">JVM类加载与字节码技术</p><p class="url">https://cyborg2077.github.io/2023/04/05/JvmPart4/</p></div></a></div></li></ul>              </div>            </details></li><li>Exception和Error包结构<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Java中的异常分为两类：<code>Error</code>和<code>Exception</code>，二者都是<code>Throwale</code>类的子类。<ul><li><code>Error</code>表示虚拟机本身的错误或资源耗尽等严重情况，应用程序不应该视图去捕获这些异常，例如<code>OOM(OutOfMemoryError)</code>、<code>SOF(StackOverFlowError)</code>等</li><li><code>Exception</code>表示程序运行中的异常情况，应该对其进行捕获和处理，<code>Exception</code>又分为<code>可检查异常(Checked Exception)</code>和<code>不可检查异常(Unchecked Exception)</code><ul><li>可检查异常需要程序显式地捕获并处理，例如<code>IOException</code>、<code>SQLException</code>等</li><li>而不可检查异常一般是程序运行时遇到的无法处理的错误，如<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>等，这些异常都继承自<code>RuntimeException</code>类，也被称为运行时异常，程序不需要显式地去捕获这类异常</li></ul></li></ul></li></ul>              </div>            </details></li><li>OOM你遇到过那些情况，SOF你遇到过哪些情况<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>OOM</code>和<code>SOF</code>都是Java程序中可能遇到的异常情况<ul><li><code>OOM(OutOfMemory)</code>即内存溢出，一般是指JVM内存不足以分配新对象，导致无法继续运行程序。出现OOM的情况很多，例如<ol><li>程序中创建了太多的对象，占用了过多的内存空间</li><li>代码中存在内存泄漏，导致不再使用的对象没有被及时释放，导致内存空间被占用</li><li>虚拟机参数设置不合理，导致JVM无法分配足够的内存等</li></ol></li><li><code>SOF(StackOverFlow)</code>即栈溢出，一般是指线程请求的栈深度大于<code>JVM</code>所允许的深度，导致<code>StackOverFlowError</code>异常。出现SOF的情况也有很多，例如<ol><li>递归调用层数过多，导致栈空间被耗尽</li><li>代码中存在死循环或循环调用，导致栈空间被耗尽</li><li>虚拟机参数设置不合理，导致栈空间太小等</li></ol></li></ul></li></ul>              </div>            </details></li><li>简述线程、程序、进程的基本概念，以及他们之间的关系是什么<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>程序：</code>是指一组指令和数据的有序集合，用于完成特定的任务。程序是存储在磁盘等外部存储介质中，只有在被加载到内存中才会被执行。</li><li><code>进程：</code>是指正在执行的程序的一个实例，是操作系统进行资源分配和调度的基本单位。进程拥有独立的内存空间和系统资源，可以包含多个线程</li><li><code>线程：</code>是指进程中的一个执行单元，是操作系统进行调度的最小单位。线程与进程共享内存空间和系统资源，每个线程拥有自己的程序计数器和栈空间</li><li>进程和线程都是程序执行的基本单位，进程和线程之间的关系是一对多的关系，即一个进程可以包含多个线程。多个线程可以并发地执行，共享进程的内存空间和系统资源。</li></ul>              </div>            </details></li><li>Java序列化中如果有某些字段不想进行序列化，怎么办<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>可以使用<code>transient</code>关键字修饰不想被序列化的字段，这样在序列化过程中这些字段就会被忽略掉。在反序列化时，这些字段的值会被设置成默认值，例如数值类型会被设置成<code>0</code>，布尔类型会被设置成<code>false</code>，引用类型会被设置成<code>null</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient修饰的字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>上面的代码中，<code>Person</code>类实现了<code>Serializable</code>接口，并且<code>age</code>字段被<code>transient</code>关键字修饰，那么在序列化过程中，<code>age</code>字段会被忽略掉，在反序列化时，<code>age</code>字段会被设置为默认值<code>0</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化前: &quot;</span> + person);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;person.dat&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;person.dat&quot;</span>))) &#123;</span><br><span class="line">            Person restoredPerson = (Person) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化后: &quot;</span> + restoredPerson);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在上面的代码中，我们创建了一个<code>Person</code>对象，并将其序列化到文件<code>person.dat</code>中，然后再从文件中反序列化得到一个新的<code>Person</code>对象，运行结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化前：Person [name=John, age=30]</span><br><span class="line">序列化后：Person [name=John, age=0]</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ul><li>需要注意的是：使用<code>transient</code>修饰的字段<code>不能</code>是<code>static</code>或<code>final</code>修饰的</li></ul></div></li></ul>              </div>            </details></li><li>说说Java中的IO流<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Java中的IO流是Java提供的一种用于输入和输出数据的机制，主要分为字节流和字符流两种类型，它们可以用于读取和写入不同种类的数据源，例如文件、网络连接、内存缓冲区等。具体来说，Java中的IO流可以分为以下几种类型<ol><li><code>字节流(InputStream和OutStream)：</code>以字节为单位读写数据，适用于读写二进制文件和图片等数据</li><li><code>字符流(Reader和Writer)：</code>以字符为单位读写数据，适用于读写文本文件</li><li><code>缓冲流(BufferedInputSteam、BufferedOutputSteam、BufferedReader和BufferedWriter)：</code>在字节流和字符流的基础上增加了缓冲功能，提高读写数据的效率</li><li><code>对象流(ObjectInputSteam和ObjectOutputStream)：</code>用于序列化和反序列化Java对象，将Java对象转换为字节流进行存储和传输</li><li><code>转换流(InputStreamReader和OutputStreamWriter)：</code>将字节流转换为字符流或将字符流转换为字节流，提供了从字节流读取Unicode字符的方法</li><li><code>文件流(FileInputStream和FileOutputStream)：</code>用于读写文件，支持读写字节和字节数组</li><li><code>管道流(PipedInputStream和PipedOutputStream)：</code>用于线程之间的数据传输</li></ol></li><li>通过使用不同类型的IO流，可以很方便地完成文件的读写、网络数据的传输、对象的序列化等操作</li></ul>              </div>            </details></li><li>JavaIO和NIO的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Java中的<code>IO(Input/Output)</code>是指对数据的输入和输出操作，其中包含了许多输入输出流。Java的IO主要基于阻塞式IO模型实现的，即在读写数据时会一直阻塞，直到数据读写完成，而<code>NIO(NEW IO)</code>是Java1.4引入的一组新IO API，也成为<code>non-nlocking IO</code>。NIO主要是基于<code>非阻塞式IO模型</code>实现，可以在单个线程上进行多个IO操作，提高了IO效率</li><li>一下是Java IO和NIO的主要区别<ol><li><code>IO是面向流的，而NIO是面向缓冲区的。</code>Java的IO中，数据总是通过InputStream或OutputStream等流的形式传输，而在NIO中，数据是从通道读入缓冲区，从缓冲区写入通道</li><li><code>IO是阻塞的，而NIO是非阻塞的。</code>Java的IO读取或写入数据时，会一直阻塞当前线程，直到操作完成或发生异常，而在NIO中，可以进行异步读写操作，即一个线程可以处理多个连接</li><li><code>IO是单向的，而NIO是双向的。J</code>ava中的IO是单向的，即一个输入流只能读取数据，一个输出流只能写入数据，而在NIO中，缓冲区既可以读，也可以写</li><li><code>IO使用字节流和字符流进行操作，而NIO使用Channel和Buffer进行操作。</code>在Java的IO中，数据总是通过InputStream和OutputStream等流的形式传输，可以进行字节流和字符流的操作。而在NIO中，数据是从通道读入缓冲区，可以使用ByteBuffer、CharBuffer等缓冲区进行读写操作</li></ol></li></ul>              </div>            </details></li><li>Java反射的作用与原理<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Java反射是指在程序运行时<code>动态地获取</code>类的信息并操作类的<code>属性</code>、<code>方法</code>、<code>构造器</code>等，它允许程序在运行时动态地<code>创建对象</code>、<code>调用方法</code>、<code>获取字段值</code>等。Java反射的作用非常广泛，例如在<code>框架</code>、<code>ORM映射</code>、<code>RPC调用</code>等领域都有应用</li><li>Java反射的原理是通过Java的类加载机制，在运行时获取类的信息，包括类名、方法名、字段名、注解等，并生成类的Class对象，这个Class对象提供了操作类的各种方法和属性的API。反射可以通过Class类的一些方法来获取<code>Constructor</code>、<code>Method</code>、<code>Filed</code>等类的信息，通过这些信息可以实现对类的<code>实例化</code>、<code>调用方法</code>、<code>获取字段值</code>等操作</li><li>Java反射的主要优点是可以动态地加载类和调用类的方法、字段等，使得程序具有更高的灵活性和扩展性。不过由于反射是一种非常底层的操作，使用不当也容易导致性能问题，同时反射也存在安全隐患，因此在使用反射时需要谨慎处理</li></ul>              </div>            </details></li><li>说说List、Set、Map的区别<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>List、Set、Map是Java集合框架中最基础的三种容器，它们的区别如下<ol><li>List接口表示有序的集合，元素可以重复，每个元素都有一个索引。常用的实现类有ArrayList和LinkedList。ArrayList基于数组实现，插入、删除操作效率低，查询效率高；LinkedList基于链表实现，插入、删除效率高，查询效率低</li><li>Set接口表示无序的集合，元素不可重复。常用的实现类有HashSet、TreeSet。HashSet基于哈希表实现，查询、插入、删除效率都很高；TreeSet基于红黑树实现，元素有序，插入、删除、查询效率都很高</li><li>Map接口表示键值对集合，每个元素包含一个键和对应的值，键不可重复。常用的实现类有HashMap和TreeMap。HashMap基于哈希表实现，查询、插入、删除效率都很高；TreeMap基于红黑树实现，元素有序，插入、删除、查询效率都很高。</li></ol></li></ul>              </div>            </details></li><li>Object有哪些常用方法？大致说一下每个方法的含义<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>Object类是Java中所有类的基类，她定义了一些常用的方法，包括    <ol><li><code>equals(Object obj)：</code>判断当前对象是否与另一个对象相等，通常需要重写该方法</li><li><code>hashCode()：</code>返回当前对象的哈希码，用于哈希表等数据结构</li><li><code>toString()：</code>返回当前对象的字符串表示，通常需要重写该方法</li><li><code>getClass()：</code>返回当前对象的类类型</li><li><code>wait()：</code>使当前线程等待，直到其他线程调用该对象的notify()或notifyAll()方法</li><li><code>notify()：</code>唤醒一个等待中的线程</li><li><code>notifyAll()：</code>唤醒所有等待中的线程</li><li><code>finalize()：</code>在垃圾回收器回收对象之前调用，用于释放资源等清理工作</li></ol></li></ul>              </div>            </details></li><li>Java创建对象有几种方式<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>使用new关键字创建对象：它会在堆内存中分配一块空间，并调用对象的构造方法初始化对象</li><li>使用Class类的newInstance()方法创建对象</li><li>使用Constructor类的newInstance()方法创建对象</li><li>使用clone()方法创建对象：在一个对象上调用clone()方法可以创建一个新的对象，并将原对象的值复制到新对象中。</li><li>使用反序列化创建对象：讲对象序列化后再反序列化就可以得到一个新的对象。这种方式需要确保对象所在的类实现了Serializable接口，并且没有重写readObject()和WriteObject()方法，否则反序列化时会出错</li></ol>              </div>            </details></li><li>获取一个类Class对象的方式有哪些<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>通过对象的getClass()方法获取</li><li>通过类名.class获取</li><li>通过Class.forName()方法获取</li><li>通过ClassLoader.loadClass()方法获取</li></ol>              </div>            </details> </li><li>说一下ArrayList的特点<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>内部实现是数组，支持动态扩容。再添加元素时，如果数组已满，则会重新创建一个更大的数组，并将原来数组中的元素复制到新数组中，这会导致添加元素的时间复杂度为O(n)</li><li>支持随机访问，可以通过元素下标直接访问数组中的元素，时间复杂度为O(1)</li><li>ArrayList中的元素允许为null</li><li>ArrayList是非线程安全的，不适合在多线程环境下使用</li><li>ArrayList的默认初始化容量为10，可以在创建ArrayList时指定初始化容量，可以一定程度上提升运行效率（避免扩容复制数组）</li><li>ArrayList支持插入和删除操作，但是在插入和删除元素时，需要将插入点后的元素全部后移，时间复杂度为O(n)</li></ol>              </div>            </details></li><li>有数组了为什么还要搞个ArrayList<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ol><li>ArrayList可以动态扩容，而数组的容量是固定的</li><li>ArrayList可以直接存储对象类型，而数组则只能存储基本数据类型和对象的引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];        <span class="comment">// 数组存储基本数据类型</span></span><br><span class="line">Object[] objArray = <span class="keyword">new</span> Object[<span class="number">3</span>];  <span class="comment">// 数组存储对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList可以直接存储对象类型本身</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>ArrayList提供了一些方便的方法，如add、remove、size等，对于操作元素的需求更加灵活</li><li>ArrayList支持泛型，可以指定容器中存储的数据类型</li><li>ArrayList可以和其他集合类进行互操作，如Collection.sort等，提供了更多的使用方式</li></ol>              </div>            </details></li><li>说说什么是fail-fast<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>fail-fast是指当集合在遍历中被修改了，那么就会抛出<code>ConcurrentModificationException</code>异常，这样可以保证多个线程并发修改时能够及时发现问题，它是一种机制，可以让程序出现并发修改时，尽早发现问题并迅速报错</li><li>Java中的某些集合类，例如ArrayList、HashMap等，都不是线程安全的。在许多县城环境中，可能会发生并发修改，也就是多个线程同时对集合进行添加、删除、修改等操作，这样会破坏集合的结构，导致数据不一致。fail-fast机制的出现就是为了解决这个问题，它在多线程并发修改集合时可以快速发现问题并报错，从而避免数据不一致的问题</li></ul>              </div>            </details></li><li>HashMap中的key我们可以使用任意类作为key吗<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>可以使用任意类作为key，但是使用时我们需要保证该类实现了hashCode()和equals()方法，以确保可以正确地进行散列和查找操作。否则，可能会导致key无法正确地被存储或查找。同时，key所述的类也需要实现Serializable接口，以便在需要时可以对HashMap进行序列化和反序列化操作。</li><li>在Java中，String、Long、Integer等常见的数据类型已经实现了hashCode()和equals()方法，因此可以直接作为HashMap的key</li></ul>              </div>            </details></li><li>为什么HashMap的长度是2的N次方呢<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li><code>HashMap</code>的长度为 2 的 N 次方是为了在存储和访问数据时提高效率，并尽可能减少哈希碰撞的发生。这是通过采用位操作 &amp; 来取代取模 % 运算来实现的。</li><li>当<code>HashMap</code>的长度是 2 的幂次时，取余操作等效于与操作，即 <code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。位操作 &amp; 在运算效率上具有优势。</li><li>这样设计的目的是使数据能够均匀分布在 HashMap 的桶中，使每个链表或红黑树的长度尽可能相等。这样可以减少链表过长或红黑树过深的情况，提高数据的存取效率。</li><li>因此，选择 HashMap 的长度为 2 的 N 次方是为了在哈希表的设计中兼顾了效率和均匀性，以提供更好的性能和较低的碰撞率。</li></ul>              </div>            </details></li><li>HashMap和ConcurrentHashMap的异同<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>相似点：<ol><li>都是Map接口的实现类，底层数据结构都是哈希表（数组+链表/红黑树）</li><li>都允许存储键值对，key和value都可以为null</li><li>都支持快速的插入、删除和查找操作</li></ol></li><li>不同点<ol><li><code>线程安全型：</code>HashMap是非线程安全的，而ConcurrentHashMap是线程安全的。在多线程环境下，ConcurrentHashMap的表现更优</li><li><code>性能：</code>在并发场景下，ConcurrentHashMap要比HashMap表现更好，尤其是当写操作很多的情况下。因为ConcurrentHashMap使用了分段锁的机制，使得多线程能够同时操作不同的段，减少了线程的竞争，从而提高了并发的效率</li><li><code>扩容机制：</code>HashMap扩容时会将原来的数组复制到新的更大的数组中，然后重新计算每个元素在新数组中的位置，这个过程比较耗时。而ConcurrentHashMap在扩容时，只需要复制里面的一部分短，不需要复制整个Map，因此速度相对更快</li><li><code>null key和null value：</code>HashMap允许key和value都未null，但是ConcurrentHashMap不允许key和value为null</li></ol></li><li>总体来说，如果在多线程环境下需要使用Map，建议使用ConcurrentHashMap，否则使用HashMap即可。</li></ul>              </div>            </details></li><li>红黑树有哪几个特征<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>红黑树是一种自平衡的二叉搜索树，具有以下特征<ol><li>每个节点要么是黑色，要么是红色</li><li>根节点是黑色的</li><li>所有叶子结点都是黑色的空节点(NIL节点)</li><li>如果一个节点是红色的，则它的啷个子节点都是黑色</li><li>任意衣蛾节点到其每个叶子结点的所有路径都包含相同数目的黑色节点</li></ol></li><li>这些特征保证了红黑树在插入和三处节点时能够保持平衡，从而保证了其查找、插入、删除操作的时间复杂度都是O(log n)级别的</li></ul>              </div>            </details></li><li>说说你平时是怎样处理Java异常的<details class="folding-tag" cyan><summary>  </summary>              <div class='content'>              <ul><li>我通常遵循以下几个规则<ol><li><code>按照异常类型分类处理：</code>对于不同的异常类型，我会根据实际情况进行不同待处理。例如对于业务异常，我通常会将异常信息记录到日志中，并给出友好提示；对于系统异常，我会打印异常的堆栈信息，将异常信息记录到日志中以便排查问题</li><li><code>异常不要吞掉：</code>在处理异常时，我不会简单的将异常捕获并吞掉，而是尽可能的将异常处理完毕，避免出现未处理的异常导致系统不稳定或者出现非预期的问题</li><li><code>日志记录：</code>在处理异常时，我通常会将异常信息记录到日志中，以便后续的问题排查与分析</li><li><code>异常处理要及时：</code>及时处理异常可以避免问题的扩大和影响范围的扩大，同时也可以减轻排查问题的难度</li><li><code>代码的健壮性：</code>尽可能的在代码的设计和编写阶段考虑各种异常情况，图稿代码的健壮性，减少出现异常的可能性w</li></ol></li></ul>              </div>            </details> </li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL知识点</title>
      <link href="/2023/04/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/04/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ol><li>第一范式：列不可再分</li><li>第二范式：行可以唯一区分，主键约束</li><li>第三范式：表的非主属性不能依赖于其他表的非主属性，外键约束</li></ol><ul><li>三级范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立在第一、第二范式上</li></ul></div></details><h1 id="MySQL数据库引擎有哪些"><a href="#MySQL数据库引擎有哪些" class="headerlink" title="MySQL数据库引擎有哪些"></a>MySQL数据库引擎有哪些</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'> <div class="table-container"><table><thead><tr><th style="text-align:center">Engine</th><th style="text-align:center">Support</th><th style="text-align:center">Comment</th><th style="text-align:center">Transactions</th><th style="text-align:center">XA</th><th style="text-align:center">Savepoints</th></tr></thead><tbody><tr><td style="text-align:center">InnoDB</td><td style="text-align:center">DEFAULT</td><td style="text-align:center">Supports transactions, row-level locking, and foreign keys</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td></tr><tr><td style="text-align:center">MRG_MYISAM</td><td style="text-align:center">YES</td><td style="text-align:center">Collection of identical MyISAM tables</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">MEMORY</td><td style="text-align:center">YES</td><td style="text-align:center">Hash based, stored in memory, useful for temporary tables</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">BLACKHOLE</td><td style="text-align:center">YES</td><td style="text-align:center">/dev/null storage engine (anything you write to it disappears)</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">MyISAM</td><td style="text-align:center">YES</td><td style="text-align:center">MyISAM storage engine</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">CSV</td><td style="text-align:center">YES</td><td style="text-align:center">CSV storage engine</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">ARCHIVE</td><td style="text-align:center">YES</td><td style="text-align:center">Archive storage engine</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">PERFORMANCE_SCHEMA</td><td style="text-align:center">YES</td><td style="text-align:center">Performance Schema</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">FEDERATED</td><td style="text-align:center">NO</td><td style="text-align:center">Federated MySQL storage engine</td><td style="text-align:center">NULL</td><td style="text-align:center">NULL</td><td style="text-align:center">NULL</td></tr></tbody></table></div><ul><li>MySQL常用引擎包括：MyISAM、InnoDB、MEMORY<ol><li>InnoDB：InnoDB是MySQL的默认存储引擎。它支持事务、行级锁和外键约束等特性，适用于需要高并发、高可靠性、高可用性和数据安全性的应用场景。</li><li>MyISAM：MyISAM是MySQL的另一个常见的存储引擎，它不支持事务和行级锁，但是支持全文检索和压缩包等特性，适用于读密集、写少的应用场景。</li><li>MEMORY：MEMORY引擎是一种基于内存的存储引擎，适用于对读写速度要求非常高的应用场景，但是数据不能持久化。</li></ol></li></ul>  </div></details><h1 id="说说InnoDB和MyISAM的区别"><a href="#说说InnoDB和MyISAM的区别" class="headerlink" title="说说InnoDB和MyISAM的区别"></a>说说InnoDB和MyISAM的区别</h1><details class="folding-tag" cyan><summary></summary><div class='content'><ul><li>InnoDB和MyISAM是MySQL最常用的两种存储引擎，它们有以下几个区别<ol><li>事务和锁：InnoDB支持事务和行级锁，而MyISAM不支持事务，只支持表级锁。因此在高并发的场景下，InnoDB可以提供更好的并发性能和数据一致性，而MyISAM的锁机制可能会导致读写冲突和性能问题。</li><li>索引：InnoDB的索引是B+树索引，而MyISAM的索引是B树索引。B+树索引对于范围查询和排序等操作的性能更好，而B树索引对于等值查询的性能更好。</li><li>全文检索：MyISAM支持全文检索，而InnoDB不支持全文检索。如果需要进行全文检索，可以使用MySQL的全文检索引擎(如Sphinx)，或者使用其他支持全文检索的数据库</li><li>外键约束：InnoDB支持外键约束，而MyISAM不支持外键约束。使用外键约束可以保证数据的完整性和一致性，避免数据异常和错误。</li><li>数据安全性：InnoDB支持崩溃恢复和数据恢复，可以保证数据的安全性和完整性。而MyISAM不支持崩溃恢复和数据恢复，一旦发生崩溃，可能会导致数据丢失或不一致。</li><li>InnoDB不保存表的具体行数，执行<code>SELECT COUNT(*) FROM table</code>时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li></ol></li></ul></div></details><h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><details class="folding-tag" cyan><summary>  </summary>          <div class='content'>      <ul><li>数据库事务是指一系列数据库操作被视为一个单独的逻辑单元，要么全部成功执行，要么全部失败回滚。事务的目的是确保数据的完整性和一致性，即使在多个并发访问的情况下也保证数据的正确性。</li><li>在数据库中，事务通常由以下四个属性组成，即ACID:<ol><li>原子性(Atomicity)：事务是一个原子操作，要么全部执行，要么全部回滚，不存在部分执行的情况。</li><li>一致性(Consistency)：事务执行前后，数据库中的数据必须满足约束条件和完整性规则，即数据库中的数据必须处于一致的状态。</li><li>隔离性(Isolation)：多个事务并发执行时，每个事务都应该感觉不到其他事务的存在，每个事务的执行应该独立于其他事务的执行。</li><li>持久性(Durability)：一旦事务执行成功，它对数据库的修改应该是永久性的，即使发生系统故障或重启，数据库也应该能够恢复到事务执行成功的状态。</li></ol></li><li>通过使用事务，可以确保数据库操作的原子性和一致性，避免数据异常和错误。</li></ul></div></details><h1 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>      <ul><li>索引是一种特殊的数据结构，用于加快数据库中数据查询的速度。它类似于书中的目录，可以帮助快速查找特定的数据。</li><li>在数据库中，索引通常是在表的一列或多列上创建的。创建索引后，数据库会使用类似于二分查找的算法来查找数据，从而大大提高了数据查询的速度。</li><li>索引可以大大提高数据查询的速度，但也会增加数据修改的时间和磁盘空间的使用。因此，在选择索引时，需要根据实际情况进行权衡。一般来说，应该对经常用于查询的列或用于表之间连接的列创建索引，同时避免创建过多的索引和不必要的索引，以免对数据库性能产生负面影响。</li><li>我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织的索引。</li></ul></div></details><h1 id="SQL优化手段有哪些"><a href="#SQL优化手段有哪些" class="headerlink" title="SQL优化手段有哪些"></a>SQL优化手段有哪些</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>      <ul><li>SQL优化是指对数据库中的SQL语句进行调整和优化，以提高查询和修改数据的效率，下面是一些常用的SQL优化手段<ol><li>查询语句中不要使用<code>SELECT *</code>：使用<code>SELECT *</code>会查询出所有的列，包括可能不需要的列，这样会增加查询的数据量，影响查询的效率。在实际应用中，应该尽量指定需要查询的列。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"># 优化后</span><br><span class="line"><span class="keyword">SELECT</span> id, name, age <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li>尽量减少子查询，使用关联查询(LEFT JOIN、RIGHT JOIN、INNER JOIN)替代：子查询是指在一个查询语句中嵌套另一个查询语句。由于子查询需要进行多次查询，因此会降低查询的效率。可以使用关联查询来替代子查询，以减少查询次数。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line"><span class="keyword">SELECT</span> name, age, (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">FROM</span> salary <span class="keyword">WHERE</span> salary.user_id <span class="operator">=</span> user.id) <span class="keyword">AS</span> max_salary <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"># 优化后</span><br><span class="line"><span class="keyword">SELECT</span> user.name user.age <span class="built_in">MAX</span>(salary.salary) <span class="keyword">AS</span> max_salary</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salary <span class="keyword">ON</span> user.id <span class="operator">=</span> salary.user_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user.id, user.name, user.age;</span><br></pre></td></tr></table></figure></li><li>减少使用<code>IN</code>或<code>NOT IN</code>，使用<code>EXISTS</code>、<code>NOT EXISTS</code>或关联查询替代：<code>IN</code>和<code>NOT IN</code>查询会对列表中的每个值进行匹配，因此查询效率较低。可以使用<code>EXISTS</code>或<code>NOT EXISTS</code>查询语句或关联查询语句替代<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>)</span><br><span class="line"># 优化后</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">WHERE</span> order.user_id <span class="operator">-</span> user.id <span class="keyword">AND</span> order.status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><code>OR</code>的查询尽量使用<code>UNION</code>和<code>UNION ALL</code>代替（在确认没有重复数据或不用去重数据时，UNION ALL会更好）：<code>OR</code>查询语句会对多个条件进行匹配，而<code>UNION</code>和<code>UNION ALL</code>查询语句会将多个查询语句的结果合并。在确定没有重复数据或不需要剔除重复数据时，使用<code>UNION ALL</code>会比<code>UNION</code>更高效。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line"></span><br><span class="line"># 优化后</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>尽量避免在<code>WHERE</code>子句中使用<code>!=</code>、<code>&lt;&gt;</code>操作符，否则引擎将放弃使用索引而进行全表扫描，可以使用<code>=</code>操作符或<code>NOT</code>操作符来替代<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">18</span>;</span><br><span class="line"># 优化后</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">18</span> <span class="keyword">OR</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure></li><li>尽量避免在<code>WHERE</code>子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描，如<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"># 改为如下形式，前提是num设置默认值为<span class="number">0</span>，确保num列不会出现<span class="keyword">NULL</span>值</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol></li></ul>  </div></details><h1 id="简单说说DROP、DELETE与TRUNCATE的区别"><a href="#简单说说DROP、DELETE与TRUNCATE的区别" class="headerlink" title="简单说说DROP、DELETE与TRUNCATE的区别"></a>简单说说DROP、DELETE与TRUNCATE的区别</h1><details class="folding-tag" cyan><summary>  </summary>          <div class='content'> <ul><li>DROP、DELETE、TRUNCATE都是MySQL中用于删除数据或对象的语句，他们的区别如下 <ol><li>DROP：用于删除整个数据库、表或视图等对象，同时删除对象机器相关的约束、触发器和索引等。DROP语句是无法恢复的，一旦执行成功，对象将永久删除。</li><li>DELETE：用于删除表中的数据行，但不删除表本身或表结构。DELETE语句可以使用WHERE子句指定要删除的数据行，如果没有指定WHERE子句，将删除表中的所有数据。DELETE语句是可逆的，使用ROLLBACK语句可以撤销删除操作。</li><li>TRUNCATE：也是用于删除表中的数据行，与DELETE不同的是，TRUNCATE语句删除表中所有数据（不支持WHERE子句）。TURNCATE比DELETE更快且更有效率，同时也是无法恢复的。</li></ol></li><li>DELETE语句是DML，这个操作会放到ROLLBACK SEGEMENT中，事务提交后才生效，如果有相应的TRIGGER，执行时会被触发</li><li>DROP和TRUNCATE是DDL，操作立即生效，无法回滚，操作不触发TRIGGER</li></ul>  </div></details><h1 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>      <ul><li>视图(View)是一种虚拟的表，是从一个或多个基本表(或视图)导出的表。视图并不存储数据，而是通过查询基本表得到数据的结果集，因此视图中的数据是动态的，会根据基本表的数据变化而自动更新。</li><li>视图可以看做是一种数据过滤器或数据抽象层，可以隐藏底层表的细节，提供更加简单、直观的数据访问接口，方便用户进行查询和分析。通过视图，用户可以只看到他们需要的数据，而不需要了解底层表的具体结构和关系。</li><li>例如下面的视图从员工表中过滤出工资大于5000的员工的信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> high_salary_employee <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> emp_id, emp_name, salary</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure></li><li>通过创建这个视图，用户可以直接查询工资大于5000的员工信息，而不用每次都写出SELECT查询语句</li></ul>  </div></details><h1 id="什么是内连接、左外连接、右外链接"><a href="#什么是内连接、左外连接、右外链接" class="headerlink" title="什么是内连接、左外连接、右外链接"></a>什么是内连接、左外连接、右外链接</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>      <ul><li>内连接(Inner Join)：匹配两张表中相关联的记录</li><li>左外连接(Left Outer Join)：除了匹配两张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示</li><li>右外链接(Right Outer Join)：除了匹配两张表中相关联的记录歪，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示</li></ul>  </div></details><h1 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题"></a>并发事务带来哪些问题</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>      <ul><li>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一条数据进行操作）。并发虽然是必须的，但是同样会导致以下几个问题<ol><li>脏读(Dirty read)：当事务A正在访问数据并且对数据进行了修改，而这种修改还没有被提交到数据库中，此时事务B也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么事务B读到的数据就是<code>脏数据</code>，依据<code>脏数据</code>所做的操作可能是不正确的。</li><li>丢失修改(Lost to modify)：是指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务修改了这个数据后，第二个事务也修改了这个事务，那么就会导致第一个事务修改的结果被丢失，因此成为丢失修改。<ul><li>例如事务A读取表中的数据<code>age=10</code>，事务B也读取<code>age=10</code>，事务A修改<code>age=age+1</code>，事务B修改<code>age=age+2</code>，最终结果<code>age=12</code>，事务A的修改被丢失</li></ul></li><li>不可重复读(Unrepeatable read)：是指在一个事务内多次读取同一事务。在这个事务还没有结束时，另一个事务也访问该数据，那么在第一个事务中的两次读数据之间，由于第二个失误的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个食物内两次读到的数据是不一样的情况，因此被称为不可重复读。</li><li>幻读(Phantonm read)：幻读与不可重复读类似，它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，因此被称为幻读。</li></ol></li><li>不可重复读和幻读的区别：<ul><li>不可重复读的重点是修改：例如多次读取一条记录，发现其中某些列的值被修改了。</li><li>幻读的重点在于新增或删除：例如多次按照固定的查询语句查询记录，发现读取到的记录数增多了或是减少了</li></ul></li></ul>  </div></details><h1 id="事务隔离级别有哪些？MySQL的默认隔离级别是什么"><a href="#事务隔离级别有哪些？MySQL的默认隔离级别是什么" class="headerlink" title="事务隔离级别有哪些？MySQL的默认隔离级别是什么"></a>事务隔离级别有哪些？MySQL的默认隔离级别是什么</h1><details class="folding-tag" cyan><summary>  </summary>          <div class='content'>      <ul><li>事务隔离级别是指多个事务之间互相隔离的程度，目的是保证事务的一致性和隔离性，MySQL支持四种隔离级别，分别是<ol><li>读未提交(Read Uncommitted)：最低的隔离级别，一个事务可以读取另一个事务未提交的数据，容易出现脏读、不可重复读、幻读的问题。</li><li>读已提交(Read Committed)：一个事务只能读取另一个事务已经提交的数据，可以避免脏读问题，但是可能出现不可重复读和幻读的问题。</li><li>可重复度(Repeatable Read)：一个事务开始后，不允许其他事务修改该事物使用的数据，可以避免脏读和不可重复读的问题，但是可能出现幻读问题。</li><li>串行化(Serializable)：最高的隔离级别，完全的隔离事务，每个事务都必须等待前一个事务提交后才能执行，避免了所有并发问题。</li></ol></li></ul>  </div></details><h1 id="大表如何优化"><a href="#大表如何优化" class="headerlink" title="大表如何优化"></a>大表如何优化</h1><details class="folding-tag" cyan><summary>  </summary>          <div class='content'>      <ul><li>优化大表的性能是数据库优化的重要部分，下面是一些常用的优化方案<ol><li>垂直分隔(Vrtical Partitioning)：将大表按照业务逻辑拆分为多个表，每个表只包含特定的字段，可以减少每个表的行数和列数，提高查询效率。</li><li>水平分隔(Horizontal Partitioning)：将大表按照某个字段(如时间、地域等)进行分区，将不同的数据存储在不同的分区中，可以减少单个表的行数，提高查询效率。</li><li>数据库分库分表(Sharding)：将大表拆分为多个小表，分散在多个数据库或者表空间中，可以提高并发访问能力和数据处理能力，但是需要考虑数据的一致性和跨分区查询等问题。</li><li>索引优化：对于大表，需要特别注意索引的设计和优化，尽量避免全表扫描和索引失效等问题。</li><li>数据库优化参数调整：对于大表，需要根据实际情况适当调整数据库的一些参数，例如缓存大小、并发连接数、线程池大小等。</li><li>定期清理无用数据：对于大表，需要定期清理无用数据，以减少表的行数和提高查询效率。</li></ol></li><li>详细内容可以参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006158186">MySQL大表优化方案</a></li></ul>  </div></details><h1 id="分库分表后，id主键如何处理"><a href="#分库分表后，id主键如何处理" class="headerlink" title="分库分表后，id主键如何处理"></a>分库分表后，id主键如何处理</h1><details class="folding-tag" cyan><summary>  </summary>          <div class='content'>      <ul><li>将大表拆分为多个表后，如果每个表的主键都是从1开始累加的，这样是不对的，我们需要一个全局唯一的ID来标识</li><li>生成全局ID有下面几种方式<ol><li>UUID：不适合作为主键，太长了，并且无序不可读，查询效率低。比较适合用于生成卫衣的名字标识，例如文件名。</li><li>数据库自增id：两台数据库分别设置不同的自增补偿，生成不重复ID的策略来实现高可用。这种方式生成的ID有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li><li>利用Redis生成ID：性能比较好，灵活方便，不依赖于数据库，但是引入了新组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本</li><li>Twitter的snowflake算法（雪花算法）</li></ol></li></ul>  </div></details><h1 id="MySQL中varchar和char的区别？varchar-30-中的30代表的含义"><a href="#MySQL中varchar和char的区别？varchar-30-中的30代表的含义" class="headerlink" title="MySQL中varchar和char的区别？varchar(30)中的30代表的含义"></a>MySQL中varchar和char的区别？varchar(30)中的30代表的含义</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>varchar和char是两种不同的数据类型，它们的主要区别在于存储方式和存储空间的使用。具体来说，char是一种固定长度的字符类型，而varchar是一种可变长度的字符类型。</li><li>在char类型中，如果指定了一个长度为N的char字段，那么该字段总是占用N个字符的存储空间，即使实际存储的字符数小于N，也不会释放多余的存储空间。</li><li>在varchar类型中，如果指定了一个长度为N的varchar字段，那么改组段可以存储最多N个字符的数据，但实际存储的字符数可能会小于N，此时该字段将只占用实际存储的字符数的存储空间，而不是固定长度的存储空间</li><li>在varchar(30)中，30表示该字段可以存储的最大字符数为30，但实际存储的字符数可能小于30。如果实际使用中存储的自付超过了30，那么MySQL将自动抛出错误或者截断数据。</li></ul></div></details><h1 id="int-11-中11代表的意义"><a href="#int-11-中11代表的意义" class="headerlink" title="int(11)中11代表的意义"></a>int(11)中11代表的意义</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>在MySQL中，int(11)中的11表示字段的显示宽度，而不是字段的最大值或者存储空间。</li></ul></div></details><h1 id="为什么SELECT-COUNT-FROM-table在InnoDB比MyISAM慢"><a href="#为什么SELECT-COUNT-FROM-table在InnoDB比MyISAM慢" class="headerlink" title="为什么SELECT COUNT(*) FROM table在InnoDB比MyISAM慢"></a>为什么<code>SELECT COUNT(*) FROM table</code>在InnoDB比MyISAM慢</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>在MySQL中，执行<code>SELECT COUNT(*) FROM table</code>语句时，会对表中的每一行进行一次计数操作，因此需要遍历整个表。</li><li>对于MyISAM表来说，表中保存了行数的计数器，因此在执行<code>SELECT COUNT(*) FROM table</code>时，只需要读取计数器的值，而不需要遍历整个表，因此执行速度非常快。</li><li>但是在InnoDB中，由于数据存储的特殊性质和实现方式，没有类似于MyISAM的计数器来保存表中的行数，因此MySQL需要遍历整个表来进行计数操作。</li></ul></div></details> <h1 id="MySQL索引类型有哪些"><a href="#MySQL索引类型有哪些" class="headerlink" title="MySQL索引类型有哪些"></a>MySQL索引类型有哪些</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MySQL支持多种类型的索引，包括以下几种<ol><li>B树索引：这是MySQL中最基本的索引类型，采用B树结构存储数据，适用于查找单个值的场景。</li><li>B+树索引：B+树是B树的一种变体，在B树的基础上增加了叶子结点的指针。形成一个链表，适用于范围查找和排序的场景。</li><li>哈希索引：这种索引采用哈希算法来快速定位数据，适用于等值查询场景，但不支持范围查询和排序。</li><li>全文索引：这种索引用于全文搜索，适用于对文本进行模糊匹配和搜索的场景。</li></ol></li></ul></div></details><h1 id="什么时候不要使用索引"><a href="#什么时候不要使用索引" class="headerlink" title="什么时候不要使用索引"></a>什么时候不要使用索引</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>索引虽然可以加快查询速度，但是在某些情况下也会带来额外的性能消耗，甚至会降低查询效率。以下是不适合使用索引的情况<ol><li>数据量非常小：对于非常小的数据集，索引可能不会带来显著的性能提升，反而会增加额外的开销。</li><li>经常进行插入、删除或修改操作：对表进行更新操作时，索引也需要更新和维护，会导致额外的性能开销。如果对表的更新操作比较频繁，那么使用索引可能会影响性能。</li><li>有大量重复的列：如果某个列存在大量重复的值，就算这个列没有唯一性约束，也不建议对其建立索引。因为索引的目的是帮助数据库加速数据的查找和匹配，而如果一个列存在大量重复的值，建立索引反而会降低查询的效率。</li></ol></li></ul></div></details><h1 id="说说什么是MVCC"><a href="#说说什么是MVCC" class="headerlink" title="说说什么是MVCC"></a>说说什么是MVCC</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MVCC(Multi-Version Concurrency Control, 多版本并发控制)是一种用于保证数据库并发性的技术。</li><li>在传统的数据库并发控制机制中，锁定是控制并发访问的主要手段。当多个事务同时访问同一行数据时，系统会对该行数据进行锁定，直到其中一个事务完成操作并释放锁之后，其他事务才能访问该行数据。这种方式虽然可以确保数据的一致性和安全性，但是会引入许多问题，如死锁、性能瓶颈等。</li><li>MVCC采用了一种不同的方式来控制并发访问。在MVCC中，每个事务都可以看到一个<code>版本</code>（或者说是快照）的数据，不同的事务之间使用不同的版本来避免冲突。当一个事务更新某个数据时，系统会创建一个新的版本，并在事务提交时将其写入磁盘。其他事务继续使用旧版本的数据，直到它们提交或回滚事务，然后再使用新版本的数据。这样可以避免锁定和死锁等问题，并提高并发访问的效率。</li></ul></div></details><h1 id="MVCC可以为数据库解决什么问题"><a href="#MVCC可以为数据库解决什么问题" class="headerlink" title="MVCC可以为数据库解决什么问题"></a>MVCC可以为数据库解决什么问题</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MVCC可以解决数据库中并发性和一致性的问题。数据库中的并发性问题包括了读写冲突、死锁等，而MVCC通过采用乐观锁的方式，允许多个事务同时读取一个数据，同时又能够保证数据的一致性。</li><li>具体来说，MVCC实现了以下特性<ol><li>可重复度：通过使用每个事物的独立版本快照来避免数据被其他并发事务修改而导致的读取不一致的问题。</li><li>非阻塞读：读操作不会阻塞写操作，写操作也不会阻塞读操作。</li><li>无锁写：MVCC使用CAS(Compare-And-Swap)操作来实现乐观锁，避免了传统锁机制的瓶颈和缺陷。</li><li>避免死锁：MVCC不使用传统锁机制，避免了传统锁机制中可能发生的死锁的问题。</li><li>高并发：MVCC通过提供并发事务的独立快照来保证读取的一致性，从而提高了数据库的并发性能。</li></ol></li><li>总之，MVCC能够使数据库在高并发的情况下保持一致性和可靠性，使得多个事务可以同时访问同一个数据库，从而提高了数据库的并发性能。</li></ul></div></details><h1 id="说说MVCC的实现原理"><a href="#说说MVCC的实现原理" class="headerlink" title="说说MVCC的实现原理"></a>说说MVCC的实现原理</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MVCC的实现原理主要包括版本号、快照、回滚段、多版本索引等技术。<ol><li>版本号：每个数据行都有一个版本号，用来标识该行数据的版本。在MySQL中，InnoDB存储引擎使用一个6字节的事务ID和一个7字节的递增计数器来表示版本号。</li><li>快照：每个事务在开始执行时，会建立一个快照(Snapshot)，用来记录当前时间点的数据库状态。这个快照可以看做是一个事务的<code>视图</code>，反映了它所能看到的数据状态。在查询时，系统会根据事务的快照，返回相应版本的数据。</li><li>回滚段：在MVCC中，每个事务都会创建一个回滚段(Rollback Segment)，用来保存该事物所做的修改。如果事务需要回滚，系统就可以利用回滚段中的信息来回复数据的原始状态。</li><li>多版本索引：为了支持MVCC，数据库通常会使用多版本索引(Multi-Version Index)来记录数据的版本信息。多版本索引包含多个版本的数据，每个版本都有自己的版本号和快照信息。当事务执行查询时，系统会根据事务的快照，返回相应版本的数据。</li></ol></li><li>MVCC的实现原理可以概括为：每个事务都有自己的快照，用来记录当前时间点的数据状态。在查询时，系统会根据事务的快照，返回相应版本的数据。当事务需要回滚时，系统会创建一个新的版本，并将旧版本标记为<code>已删除</code>。如果事务需要回滚，系统就可以利用回滚段中的信息，恢复数据的原始状态。多版本索引用于记录数据的版本信息，以便系统能够快速地找到相应版本的数据。这些技术相互配合，实现了MVCC的高效并发控制。</li></ul></div></details><h1 id="说说MySQL数据库的锁"><a href="#说说MySQL数据库的锁" class="headerlink" title="说说MySQL数据库的锁"></a>说说MySQL数据库的锁</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MySQL数据库中的锁分为共享锁(Shared Lock)和排它锁(Exclusive Lock)两种。<ol><li>共享锁：也被称为读锁，允许多个事务同时读取同一份数据，但不允许任何事物对数据进行修改，找到所有共享锁都被释放。</li><li>排他锁：也被称为写锁，只允许一个事务对数据进行修改，其他事务无法读取或修改数据，直到排他锁被释放。</li></ol></li><li>MySQL还支持表级锁行级锁两种粒度的锁<ol><li>表级锁：是对整张表的锁，可以锁定整个表，避免其他事务对该表进行任何操作。表级锁的优点是简单，系统开销小，适用于对表进行全局性操作；缺点是粒度太大，会导致并发性能下降。MyISAM使用表级锁。</li><li>行级锁：是针对单个数据行的锁，只锁定需要修改的数据行，避免其他事务对该数据进行操作。行级锁的优点是粒度小，发生冲突概率低，可以提高并发性能；缺点是实现复杂，需要维护锁定的数据行和事务的状态，容易出现死锁。InnoDB支持行锁（必须有索引才能实现，否则会自动锁全表，变成表级锁）</li></ol></li></ul></div></details><h1 id="什么是锁升级"><a href="#什么是锁升级" class="headerlink" title="什么是锁升级"></a>什么是锁升级</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'>      <ul><li>锁升级是指将行级锁升级为表级锁的过程。MySQL中默认使用的是行级锁，在一些特殊情况下，需要使用表级锁，但是如果表上已经存在行级锁，就需要将行级锁升级为表级锁，从而保证数据的一致性和完整性。</li><li>锁升级一般会在以下情况发生：<ol><li>当前会话需要更新的行数太多，导致获取行级锁的时间过长，从而影响系统的并发性能，此时可以将行级锁升级为表级锁。</li><li>当前会话需要执行的操作已经涉及到整张表的数据，比如对表进行TRUNCATE、DROP等操作，此时需要将行级锁升级为表级锁。</li></ol></li><li>锁升级的过程是自动的，由MySQL内部的锁管理器来控制，具体实现细节可以参考MySQL的官方文档。需要注意的是，锁升级会对系统的性能产生一定的影响，因此在实际的应用中需要谨慎使用，尽量避免锁升级的情况。</li></ul>  </div></details><h1 id="说说悲观锁和乐观锁"><a href="#说说悲观锁和乐观锁" class="headerlink" title="说说悲观锁和乐观锁"></a>说说悲观锁和乐观锁</h1><details class="folding-tag" cyan><summary>  </summary>          <div class='content'>      <ul><li>悲观锁和乐观锁是两种常见的并发控制方式。<ol><li>悲观锁的思想是：假设并发访问的情况下，数据很可能会被其他用户修改，因此在访问数据前就会加锁，防止其他用户对数据进行修改。悲观锁的实现方式一般是通过数据库的锁机制来实现的，例如行级锁、表级锁等。</li><li>乐观锁的思想是：假设并发访问的情况下，数据很少会发生冲突，因此在访问数据前不会加锁，而是通过在数据上增加版本号等机制来判断数据是否被修改。乐观锁的实现方式一般是通过在数据表中增加一个版本号或时间戳等字段，每次修改数据时都会更新这个版本号，如果读取数据是发现版本号与预期的不一致，则说明数据已经被其他用户修改，需要重新读取数据。</li></ol></li></ul></div></details><h1 id="怎样尽量避免死锁的出现"><a href="#怎样尽量避免死锁的出现" class="headerlink" title="怎样尽量避免死锁的出现"></a>怎样尽量避免死锁的出现</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>死锁是指多个事务在互相等待对方释放资源而无法继续执行的情况，这种情况下需要DBMS的干预才能解除死锁。下面是一些尽量避免死锁的方法：<ol><li>尽量减少事务持有资源的时间，比如避免在事务中进行大量计算和逻辑处理。</li><li>尽量在事务开始时就确定需要访问的数据，避免在事务中根据条件动态检索数据。</li><li>避免长时间占用多个资源，比如对多个表进行更新操作。</li><li>尽量使用较短的事务，这样锁的等待时间会减少。</li><li>优化SQL语句，尽量避免全表扫描或索引失效等情况。</li></ol></li><li>如果死锁无法避免，那么可以使用以下方式作为保底手段解除死锁：<ol><li>设置等待超时机制：当一个事务在一定时间内无法获得锁，就主动放弃等待并结束事务，然后再重试。</li><li>死锁检测：DBMS定时检测系统中的死锁情况，并将其解除。这种方法会消耗一定的系统资源，所以不适合在高并发的环境中使用。</li></ol></li></ul></div></details><h1 id="使用MySQL的索引时需要注意什么"><a href="#使用MySQL的索引时需要注意什么" class="headerlink" title="使用MySQL的索引时需要注意什么"></a>使用MySQL的索引时需要注意什么</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>使用MySQL的索引时需要注意以下几点<ol><li>应尽量避免在<code>WHERE</code>子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符，否则将引擎放弃用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数，因此需要查询该表的所有行。</li><li>应尽量避免在<code>WHERE</code>子句中用<code>OR</code>来连接条件，否则将导致引擎放弃使用索引而进行全表扫猫，如: <code>SELECT id FROM t WHERE num = 10 OR num = 20</code></li><li>应尽量避免在<code>WHERE</code>子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描.</li><li>应尽量避免在<code>WHERE</code>子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描.</li><li>不要在<code>WHERE</code>子句中的<code>=</code>左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li><li>复合索引遵循最左前缀原则。</li><li>如果<code>MySQL</code>评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。</li><li>列类型是字符串类型，查询时一定要给值加引号，否则索引失效.</li><li>LIKE 的模糊查询可能会导致无法使用索引。原因是 LIKE 语句中的通配符（% 或 _）使得索引失效。如果需要模糊匹配，可以使用全文索引引擎（例如ElasticSearch）</li><li>表字段为NULL，也不可以使用索引的 </li></ol></li></ul> </div></details><h1 id="主键和候选键有什么区别"><a href="#主键和候选键有什么区别" class="headerlink" title="主键和候选键有什么区别"></a>主键和候选键有什么区别</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>主键和候选键都是用来唯一标识一张表中每个行的键，但是它们之间有一些区别<ol><li>主键必须是非空、唯一的。</li><li>候选键也是唯一标识一张表中每个行的键，但不是必须非空的，在一个表中可以有多个候选键，也可以没有候选键。</li><li>主键是一种特殊的候选键，它是表的主要标识，用于保证表中的每个行的唯一性。如果没有指定主键，则可以选择一个合适的候选键作为主键。候选键可以是多个，但只有一个可以成为主键。</li></ol></li></ul></div></details><h1 id="主键和索引有什么区别"><a href="#主键和索引有什么区别" class="headerlink" title="主键和索引有什么区别"></a>主键和索引有什么区别</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>主键和索引都可以用来唯一标识一张表中的记录，但它们有一些区别<ol><li>主键是一种唯一性约束，保证表中每一行数据的唯一性。而索引知识一种辅助数据结构，用于提高查询效率。</li><li>主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键。</li><li>主键不允许为空值，唯一索引列允许为空值。</li><li>一个表只能有一个主键，但是可以有多个唯一索引。</li><li>主键可以被其他表引用为外键，唯一索引列不可以。</li></ol></li></ul></div></details><h1 id="MySQL如何做到高可用方案"><a href="#MySQL如何做到高可用方案" class="headerlink" title="MySQL如何做到高可用方案"></a>MySQL如何做到高可用方案</h1><details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MySQL的高可用方案可以通过以下几种方式实现：<ol><li>主从复制：将一个MySQL实例作为主节点，其余MySQL实例作为从节点，主节点上的操作会被自动同步到从节点上，从而达到高可用的目的。当主节点出现故障时，可以将其中一个从节点提升为新的主节点，从而保证系统的可用性。</li><li>数据库集群：将多个MySQL实例组成一个集群，每个示例都可以处理请求，当其中一个实例出现故障时，其他实例会自动接管请求，从而保证系统的可用性。</li><li>数据库代理：通过引入数据库代理层，将多个MySQL实例进行统一管理，提供负载均衡、故障转移、自动切换等功能，从而达到高可用的目的。</li><li>数据库备份和恢复：通过定期备份数据库，将备份数据存储到其他位置，当出现故障时，可以通过备份数据进行快速恢复，从而达到高可用的目的。</li></ol></li></ul></div></details><h1 id="面试模拟"><a href="#面试模拟" class="headerlink" title="面试模拟"></a>面试模拟</h1><ul><li>面试官：了解过索引吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'>              <ul><li>索引在项目中还是比较常见的，它是帮助MySQL高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的IO成本，同时通过索引列对数据进行排序，降低数据排序的成本，也能降低CPU的消耗</li></ul>              </div></details></li><li>面试官：索引底层的数据结构了解过吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>MySQL现在默认的存储引擎是InnoDB，它采用的是B+树的数据结构来存储索引，选择B+树的主要原因是<ol><li>阶数（树杈）更多，路径更短</li><li>磁盘读写代价更低，飞叶子节点只存储指针，叶子结点存储数据</li><li>B+树便于扫库和去检查询，因为叶子结点是一个双向链表<br><img src="https://s1.ax1x.com/2023/07/23/pCqI5qK.png" alt=""></li></ol></li><li>使用二叉树或者红黑树效率都不高，二叉树在不平衡的情况下，会退化为链表。红黑树虽然能保证平衡性来降低树的高度，但是红黑树只是二叉树，阶数低，如果遇到庞大的数据量，二叉树也会很高，效率也是不如B+树<br><img src="https://s1.ax1x.com/2023/07/23/pCq5S6P.png" alt=""></li><li>B树的非叶子结点和叶子结点都会存放数据，范围查询效率低，并且不太稳定<br><img src="https://s1.ax1x.com/2023/07/23/pCqo9Ig.png" alt=""></li></ul></div></details></li>​         <li>面试官：什么是聚簇索引？什么是非聚簇索引？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'><ul><li>聚簇索引有且只有一个，主要是指数据与索引放到一块，B+树的叶子结点保存了整行数据，一般情况下都是主键作为聚簇索引的</li><li>非聚簇索引指的是数据与索引分开存储，B+树的叶子结点保存对应的主键，可以有多个，一般我们自定义的索引都是非聚簇索引<br><img src="https://s1.ax1x.com/2023/07/23/pCqoHmV.png" alt=""></li></ul></div></details></li><li>面试官：知道什么是回表查询吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>    <div class='content'>              <ul><li>这个和刚刚介绍的聚簇索引和非聚簇索引有很大关系的，回表的意思是，通过非聚簇索引找到数据对应的主键值，然后通过主键值去聚簇索引中查找出整行的数据，这个过程就是回表。<br><img src="https://s1.ax1x.com/2023/07/23/pCq76IS.png" alt=""></li></ul>              </div>           </details></li><li>面试官：知道什么叫覆盖索引吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'>          <ul><li>覆盖索引值的是select查询语句使用了索引，返回的列必须能在索引中全部找到，如果我们使用id查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</li><li>如果按照非聚集索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，所以尽量避免使用<code>SELECT *</code>，尽量在返回的列中都包含添加索引的字段</li></ul>          </div><p>​           </details></p></li><li>面试官：MySQL超大分页怎么处理？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>超大分页一般都是在数据量比较大的时候，我们使用limit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行该命令，会先排序前900010条数据，仅返回后10条记录，查询的代价非常大</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_stu limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li>先分页查询数据的id字段，确定了id之后，再使用子查询来过滤，只查询这个id列表中的数据就可以了，因为查询id的时候，走的是覆盖索引，这样效率就会提升很多<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> tb_stu t, (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb_stu <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">9000000.</span> <span class="number">10</span>) a</span><br><span class="line"><span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id</span><br></pre></td></tr></table></figure></li></ul>​              </div>​           </details></li><li>面试官：索引创建原则有哪些？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>嗯，这个情况有很多，不过都有一个大前提，首先表中的数据要超过10万条以上，我们才会去创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是作为查询条件、排序字段或者分组字段这些。其次就是，我们通常创建索引的时候都是使用复合索引来创建，一条SQL的返回值，尽量使用覆盖索引。</li></ul>​              </div>​           </details></li><li>面试官：什么情况下索引会失效？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>嗯，这个情况比较多<ul><li>比如索引在使用的时候没有遵循最左匹配原则，举例说明：假设有一个复合索引idx_name_age，包含两列：name和age。下面是一些查询条件和它们是否符合最左匹配原则的判断：<ol><li>查询条件：WHERE name = ‘John’。<ul><li>符合最左匹配原则，因为从复合索引的最左侧列name开始进行匹配。</li></ul></li><li>查询条件：WHERE age &gt; 30。<ul><li>不符合最左匹配原则，因为复合索引的第一列是name，而age不是从最左侧开始进行匹配的。</li></ul></li><li>查询条件：WHERE name = ‘John’ AND age &gt; 30。<ul><li>符合最左匹配原则，因为从复合索引的最左侧列name开始进行匹配，然后紧接着匹配age。</li></ul></li><li>查询条件：WHERE age &gt; 30 AND name = ‘John’。<ul><li>不符合最左匹配原则，虽然涵盖了复合索引的所有列，但是列的顺序并没有从最左侧开始连续匹配。</li></ul></li></ol></li><li>模糊查询的时候，如果%在前面也会导致索引失效。<ul><li>例如 <code>LIKE &#39;%John&#39;</code> 会失效，而 <code>LIKE &#39;John%&#39;</code>则不会</li></ul></li><li>在添加索引的字段上进行了运算操作或者类型转换也会导致索引失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 进行了运算操作</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">3</span>,<span class="number">2</span>) <span class="operator">=</span><span class="string">&#x27;科技&#x27;</span></span><br><span class="line"><span class="comment">-- 字符串不加单引号，也会造成索引失效，因为此时要进行类型转换</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>​              </div>​           </details></li><li>面试官：有SQL的优化经验吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'>          <ul><li>嗯，这个还是比较常见的，可以从这几方面来考虑<ol><li>建表的时候选择合适的类型</li><li>使用索引</li><li>SQL语句的编写</li><li>主从复制</li><li>读写分离</li></ol></li></ul>          </div><p>​           </details></p></li><li>面试官：那你在建表的时候，是如何进行优化的呢？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'>          <ul><li>这个主要参考阿里开发手册，就比如再定义字段的时候，需要结合字段的内容来选择合适的类型，如果是字符串，需要结合存储的内容来选择是使用char还是varchar或者text类型。用户名邮箱之类的，可以用varchar，文章内容这种可以用text，邮编之类的定长字符串可以用char</li></ul>          </div><p>​           </details></p></li><li>面试官：那你在使用索引的时候，是如何优化的呢？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>首先表中的数据要超过10万条以上，我们才会去创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是作为查询条件、排序字段或者分组字段这些。其次就是，我们通常创建索引的时候都是使用复合索引来创建，一条SQL的返回值，尽量使用覆盖索引。</li></ul>​              </div>​           </details></li><li>面试官：你平时对SQL语句做了哪些优化呢？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>嗯，这个也有很多，比如SELECT语句务必指明字段名称，不要直接使用SELECT *，还有就是需要注意避免索引失效的写法，如果是聚合查询，尽量使用UNION ALL来替代UNION，因为UNION会多一次过滤，效率相对较低。如果是表关联的话，尽量使用INNER JOIN，必要时用LEFT JOIN或RIGHT JOIN，如果非要用的话，一定要以小表作为驱动。</li></ul>​              </div>​           </details></li><li>面试官：事务的特性是什么？可以详细说一下吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>事务的特性指的是ACID属性，分别是原子性、一致性、隔离性、持久性。我举个例子吧，就比如转账这种场景<ol><li>A向B转账500，转账成功，A扣除500元，B增加500元。原子性体现在要么都成功，要么都失败。</li><li>在转账过程中，A扣除了500元，那么B必须增加500元，需要保证数据的一致性。</li><li>隔离性体现在，A向B转账，不能受到其他事务的干扰</li><li>持久性体现在，转账成功后，需要将数据持久化。</li></ol></li></ul>​              </div>​           </details></li><li>面试官：并发事务带来哪些问题？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>第一是脏读，当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，此时另一个事务也来访问了这个数据，由于这个数据还没有提交，那么另一个事务读取到的数据就是脏数据，根据脏数据所做的操作可能是不正确的。</li><li>第二个是不可重复读，比如在一个事务内多次读同一数据，在这个事务还没有结束时，另一个事务也来访问该数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，因此称为不可重复读。</li><li>第三个是幻读：幻读跟不可重复读类似，它是发生在一个事务读取了几行数据，接着另一个事务插入了一些数据，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录。</li></ul>​              </div>​           </details></li><li>面试官：那么怎么解决这些问题呢？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>解决方案是对事务进行隔离，MySQL支持四种隔离级别<ol><li>读未提交：它解决不了刚刚的所有问题，一般项目里也不用这个</li><li>读已提交：它能解决脏读问题，但是解决不了不可重复读和幻读</li><li>可重复读：他能解决脏读和不可重复读，但是解决不了幻读，同时它也是MySQL的默认隔离级别</li><li>串行化：它可以解决刚刚提出的所有问题，但是由于是让事务串行执行的，性能比较低。所以项目中一般用的都是MySQL的默认隔离级别：可重复读。</li></ol></li></ul>​              </div>​           </details></li><li>面试官：undo log和redo log的区别</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；</li><li>redo log保证了事务的持久性，undo log保证了事务的原子性和一致性</li></ul>​              </div>​           </details></li><li>面试官：事务中的隔离性是如何保证的？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary>​              <div class='content'>​              <ul><li>隔离性是由锁和MVCC实现的。</li><li>MVCC是多版本并发控制，指维护一个数据的多个版本，使得读写操作没有冲突，它的底层实现主要是分为了三个部分，第一个是隐藏字段，第二个是undo log日志，第三个是readView视图</li><li>隐藏字段是指在MySQL中给每个表都设置了隐藏字段，有一个是trx_id（事务id），记录每一次操作的事务id，是递增的，另一个是roll_pointer（回滚指针），指向上一个版本的事务地址</li><li>undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</li><li>readView解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问哪个版本的数据，不同的隔离级别快照读是不一样的，最终的访问结果也不一样。如果是读已提交隔离级别，每一次执行快照读时生成ReadView，如果是可重复度隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用</li></ul>​              </div>​           </details></li><li>面试官：MySQL主从同步原理知道吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary><div class='content'>          <ul><li>MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：<ol><li>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>从库重做中继日志中的事件，将改变反映它自己的数据</li></ol></li></ul>          </div><p>​           </details></p></li><li>面试官：MySQL主从同步原理知道吗？</li><li>候选人：<details class="folding-tag" cyan><summary>  </summary></p>          <div class="content">              <ul><li>MySQL主从复制的核心就是二进制日志(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：<ol><li>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>从库重做中继日志中的事件，将改变反映它自己的数据</li></ol></li></ul>              </div>  </details></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
