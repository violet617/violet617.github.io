<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM系列(3) | violet617</title><meta name="author" content="violet617"><meta name="copyright" content="violet617"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="如何判断对象可以回收引用计数法 当一个对象被引用是，就当引用对象的值+1，当引用对象的值为0时，则说明该对象没有被引用，那么就可以被垃圾回收器回收 当一个对象被引用是，就当引用对象的值+1，当引用对象的值为0时，则说明该对象没有被引用，那么就可以被垃圾回收器回收 这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM系列(3)">
<meta property="og:url" content="http://example.com/2023/04/25/JVMPart/JVM_3/index.html">
<meta property="og:site_name" content="violet617">
<meta property="og:description" content="如何判断对象可以回收引用计数法 当一个对象被引用是，就当引用对象的值+1，当引用对象的值为0时，则说明该对象没有被引用，那么就可以被垃圾回收器回收 当一个对象被引用是，就当引用对象的值+1，当引用对象的值为0时，则说明该对象没有被引用，那么就可以被垃圾回收器回收 这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/650478a5661c6c8e54c6ca3f.jpg">
<meta property="article:published_time" content="2023-04-25T08:16:54.000Z">
<meta property="article:modified_time" content="2023-09-20T04:28:38.368Z">
<meta property="article:author" content="violet617">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/650478a5661c6c8e54c6ca3f.jpg"><link rel="shortcut icon" href="/img/door_open.png"><link rel="canonical" href="http://example.com/2023/04/25/JVMPart/JVM_3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM系列(3)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-20 12:28:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/layout.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/big-counter.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web-bg"><div id="default-bg" style="background:url(https://pic.imgdb.cn/item/6518118dc458853aef5c01c4.jpg);"></div><div id="dark-bg" style="background:url(https://pic.imgdb.cn/item/6518118dc458853aef5c01c4.jpg);"></div><div id="mobile-bg" style="background:url(https://pic.imgdb.cn/item/6518118dc458853aef5c01c4.jpg);"></div><div id="mobile-dark-bg" style="background:url(https://pic.imgdb.cn/item/6518118dc458853aef5c01c4.jpg);"></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/suolong.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-compass"></i><span> 动态</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw fas fa-music"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/650478a5661c6c8e54c6ca3f.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="violet617"><span class="site-name">violet617</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-compass"></i><span> 动态</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw fas fa-music"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM系列(3)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-25T08:16:54.000Z" title="发表于 2023-04-25 16:16:54">2023-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-20T04:28:38.368Z" title="更新于 2023-09-20 12:28:38">2023-09-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM%E5%8E%9F%E7%90%86/">JVM原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM系列(3)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><h1 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul></p>
<p><li>当一个对象被引用是，就当引用对象的值<code>+1</code>，当引用对象的值为<code>0</code>时，则说明该对象没有被引用，那么就可以被垃圾回收器回收</li></p>
<p><li>当一个对象被引用是，就当引用对象的值<code>+1</code>，当引用对象的值为<code>0</code>时，则说明该对象没有被引用，那么就可以被垃圾回收器回收</li></p>
<p><li>这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这两个对象都无法被释放<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/ppWDSuq.png" alt=""></li><br>&lt;/ul&gt;</p>
<p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><ul></p>
<p><li>JVM垃圾回收机制的可达性分析算法，是一种基于引用的垃圾回收算法。其基本思想是通过一系列被称为”GC Roots”的根对象作为起点，寻找所有被根对象直接或间接引用的对象，将这些对象称为”可达对象”，而没有被找到的对象则被视为”不可达对象”，需要被回收。<div class="note info no-icon flat"><ul></p>
<p><li>形象一点理解就是我有一串葡萄，我把这串葡萄拿起来，连在根上的葡萄就是可达对象，而掉在盘子里的葡萄就是不可达对象，需要被回收</li><br>&lt;/ul&gt;<br>&lt;/div&gt;&lt;/li&gt;</p>
<p><li>在JVM中，有四种类型的GC Roots对象：<ol></p>
<p><li><code>虚拟机栈中引用的对象</code>：虚拟机栈是用于存储方法调用和执行的栈空间。当一个方法被调用时，会在栈中创建一个栈帧，用于存储该方法的局部变量、参数和返回值等信息。如果栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li></p>
<p><li><code>方法区中类静态属性引用的对象</code>：方法区是用于存储类信息、常量池、静态变量等信息的内存区域。当一个类被加载到方法区时，其中的静态属性会被分配在方法区中，如果这些静态属性中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li></p>
<p><li><code>方法区中常量引用的对象</code>：常量池是方法区的一部分，用于存储常量。如果常量池中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li></p>
<p><li><code>本地方法栈中JNI引用的对象</code>：JNI是Java Native Interface的缩写，用于在Java程序中调用本地方法（即由C或C++等语言编写的方法）。当本地方法被调用时，会在本地方法栈中创建一个栈帧，如果该栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;</p>
<p><li>可达性分析算法基于这些GC Roots对象，通过遍历所有的引用链，找到所有可达对象，将它们标记为存活对象，而没有被找到的对象则被视为不可达对象，需要被回收。</li></p>
<p><li>可达性分析算法的主要优点是可以处理复杂的引用结构，例如循环引用、交叉引用等情况，能够识别出所有可达对象，从而准确地进行垃圾回收。但是，它也有一些缺点，例如需要耗费较多的时间进行垃圾回收、可能会出现漏标和误标等问题。为了解决这些问题，JVM中还采用了其他的垃圾回收算法，如标记-清除算法、复制算法、标记-整理算法等，以提高垃圾回收的效率和准确性。</li><br>&lt;/ul&gt;</p>
<p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul></p>
<p><li>在Java中，对象不仅可以被正常引用，还可以被特殊的引用类型引用。这些引用类型决定了垃圾回收器如何对对象进行回收。</li></p>
<p><li>JVM中共有五种引用类型，它们分别是<ol></p>
<p><li><code>强引用（Strong Reference）：</code>是最常见的引用类型，也是默认的引用类型。如果一个对象具有强引用，那么即使内存空间不足，垃圾回收器也不会回收它。只有当该对象的所有强引用都失效时，对象才会被回收</li></p>
<p><li><code>软引用（Soft Reference）：</code>是一种比强引用弱一些的引用类型。如果一个对象<code>只具有</code>软引用，那么当内存空间不足时，垃圾回收器可能会回收它。软引用通常用于实现内存敏感的缓存<ul></p>
<p><li>可以配合引用队列来释放软引用自身</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>弱引用（Weak Reference）：</code>是一种比软引用更弱一些的引用类型。如果一个对象<code>只具有</code>弱银用，那么垃圾回收器在下一次运行时，无论内存空间是否足够，都会回收该对象。若引用通常用于实现在对象可用时进行操作的场景<ul></p>
<p><li>可以配合引用队列来释放软引用自身</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>虚引用（Phantom Reference）：</code>是最弱的一种引用类型。如果一个对象只具有虚引用，那么在任何时候都可能被垃圾回收器回收。虚引用通常用于追踪对象被垃圾回收的状态<ul></p>
<p><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>终结器引用（Final Reference）：</code>是一种特殊的弱引用类型，它只在对象被回收时被添加到引用队列中。当垃圾回收器准备回收一个对象时，会先执行对象的finallize()方法，如果finalize()方法中没有重新让对象与其他对象建立联系，那么这个对象就会被回收，并且它的Final引用会被加入到引用队列中。Final引用通常用于对象回收后的清理工作</li><br>&lt;/ol&gt;<br>&lt;/li&gt;</p>
<p><li>软引用、弱引用和虚引用则是用于管理一些比较特殊的对象。使用引用队列可以方便地跟踪这些特殊对象的垃圾回收状态，帮助我们及时释放对象占用的资源。</li></p>
<p><li>使用引用队列来管理这些特殊对象的方式是，在创建这些对象时，同时指定一个引用队列。当垃圾回收器回收这些对象时，会自动将其添加到与之关联的引用队列中。我们可以在某个时刻检查引用队列中是否有特殊对象，并对其进行处理，比如将其从相应的数据结构中删除，以便释放特殊对象占用的资源。</li><br>&lt;/ul&gt;</p>
<p><h3 id="软引用应用"><a href="#软引用应用" class="headerlink" title="软引用应用"></a>软引用应用</h3><ul></p>
<p><li>前面说软引用通常用于实现内存敏感的缓存，那现在我们来演示一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加VM参数-Xmx20m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_18</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></p>
<p><li>上面的代码中，由于我们设置堆内存为20M，而代码中5次循环也需要20M的内存，所以到最后肯定会报内存溢出的错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at com.demo.Demo_18.main(Demo_18.java:20)</span><br></pre></td></tr></table></figure></li></p>
<p><li>强引用会报堆内存错误，那我们来试试弱引用，前面说弱引用会在内存不足时被垃圾回收器回收，那我们额外添加两个VM参数，监测垃圾回收情况<code>-XX:+PrintGCDetails</code>、<code>-verbose:gc</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示软引用</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_18</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">/*        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 15; i++) &#123;</span></span><br><span class="line"><span class="comment">            list.add(new byte[_4MB]);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        soft();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB]);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></p>
<p><li>运行结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[B@27c170f0</span><br><span class="line">1</span><br><span class="line">[B@5451c3a8</span><br><span class="line">2</span><br><span class="line">[B@2626b418</span><br><span class="line">3</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(6144K)] 14495K-&gt;13153K(19968K), 0.0031771 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] </span><br><span class="line">[B@5a07e868</span><br><span class="line">4</span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4704K-&gt;4704K(6144K)] 17362K-&gt;17378K(19968K), 0.0012234 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4704K-&gt;4500K(6144K)] [ParOldGen: 12673K-&gt;12634K(13824K)] 17378K-&gt;17135K(19968K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0054571 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4500K-&gt;4500K(6144K)] 17135K-&gt;17167K(19968K), 0.0007514 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4500K-&gt;0K(6144K)] [ParOldGen: 12666K-&gt;733K(8704K)] 17167K-&gt;733K(14848K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0063756 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[B@76ed5528</span><br><span class="line">5</span><br><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li></p>
<p><li>我们来分析一下运行结果<ul></p>
<p><li>前三次循环时内存充足，没有触发垃圾回收。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[B@27c170f0</span><br><span class="line">1</span><br><span class="line">[B@5451c3a8</span><br><span class="line">2</span><br><span class="line">[B@2626b418</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li></p>
<p><li>但是第四次循环时，内存已经很紧张了，所以回收了一些新生代的内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(6144K)] 14495K-&gt;13153K(19968K), 0.0031771 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] </span><br><span class="line">[B@5a07e868</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li></p>
<p><li>第五次循环时，一次垃圾回收后，内存空间仍然不足，然后又触发了一次垃圾回收，回收了大部分新生代和老年代的内存<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4704K-&gt;4704K(6144K)] 17362K-&gt;17378K(19968K), 0.0012234 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4704K-&gt;4500K(6144K)] [ParOldGen: 12673K-&gt;12634K(13824K)] 17378K-&gt;17135K(19968K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0054571 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4500K-&gt;4500K(6144K)] 17135K-&gt;17167K(19968K), 0.0007514 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4500K-&gt;0K(6144K)] [ParOldGen: 12666K-&gt;733K(8704K)] 17167K-&gt;733K(14848K), [Metaspace: 3361K-&gt;3361K(1056768K)], 0.0063756 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[B@76ed5528</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></p>
<p><li>其代价就是将前四个byte数组占据的内存释放掉了，只保留了第五次循环时的byte数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li>软连接在内存敏感的程序下的好处，当内存空间比较有限时，一些不重要的对象可以用软连接去管理它，当空间紧张时，就可以将它释放掉</li><br>&lt;/ul&gt;</p>
<p><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><ul></p>
<p><li>前面说软引用可以配合引用队列来释放软引用自身，用下面的代码来演示一下（其实就是上面的代码修改了一下），注意添加VM参数<code>-Xmx20m -XX:+PrintGCDetails -verbose:gc</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示软引用, 配合引用队列, VM参数：-Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_19</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _4MB = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============下面输出引用队列中的软引用对象============&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">            System.out.println(reference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></p>
<p><li>运行上面的代码，结果如下，软引用对象只剩一个，符合我们的预期<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[B@27c170f0</span><br><span class="line">1</span><br><span class="line">[B@5451c3a8</span><br><span class="line">2</span><br><span class="line">[B@2626b418</span><br><span class="line">3</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2207K-&gt;496K(6144K)] 14495K-&gt;13087K(19968K), 0.0011815 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[B@5a07e868</span><br><span class="line">4</span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4704K-&gt;4704K(6144K)] 17296K-&gt;17352K(19968K), 0.0008897 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 4704K-&gt;4549K(6144K)] [ParOldGen: 12647K-&gt;12585K(13824K)] 17352K-&gt;17135K(19968K), [Metaspace: 3359K-&gt;3359K(1056768K)], 0.0051949 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 4549K-&gt;4549K(6144K)] 17135K-&gt;17183K(19968K), 0.0007508 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 4549K-&gt;0K(6144K)] [ParOldGen: 12633K-&gt;733K(8704K)] 17183K-&gt;733K(14848K), [Metaspace: 3359K-&gt;3359K(1056768K)], 0.0058980 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[B@76ed5528</span><br><span class="line">5</span><br><span class="line">============下面输出引用队列中的软引用对象==============</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure></li></p>
<p><li>但如果我们不移除队列中无用的引用对象，那么输出结果是这样的，队列中存储的null会占据存储空间，最终可能会导致内存泄漏，所以我们一定要记得手动移除队列中无用的引用对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">============下面输出引用队列中的软引用对象===========</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@76ed5528</span><br></pre></td></tr></table></figure>
</li><br>&lt;/ul&gt;</p>
<p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><ul></p>
<p><li><p>标记清除是一种常见的垃圾回收算法之一，其工作原理如下：</p></p>
<p><ol></p>
<p><li><code>标记阶段（Mark）</code>：从根对象开始遍历内存中的所有对象，将所有能够被访问到的对象做上标记，表示这些对象是活动的。</li></p>
<p><li><code>清除阶段（Sweep）</code>：遍历整个内存空间，将未被标记的对象视为垃圾，将其占用的内存资源进行回收。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;</p>
<p><li><p>标记清除算法的优点在于它简单易用，可以快速地回收大量的垃圾对象。但是，它也存在一些缺点，例如在清除和压缩阶段中可能会产生较大的内存碎片，从而影响后续的内存分配效率。此外，标记清除算法无法处理循环引用的情况，需要借助其他算法来处理循环引用问题，例如标记-压缩算法和复制算法等。</p>
</li><br>&lt;/ul&gt;</p>
<p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/ppflgm9.png" alt=""></p></p>
<p><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><ul></p>
<p><li>在标记整理算法中，标记和清除阶段和标记清除算法是一样的，只有在内存整理阶段不同。在整理阶段，标记整理算法会将所有存活的对象向内存的一端移动，之后将移动后的内存末尾地址作为堆的新起始地址，之前的地址空间被标记为空闲，可以用来分配新的对象。</li></p>
<p><li>需要注意的是，标记整理算法的整理阶段可能会比较耗时，因为它需要移动对象，这也是它的一个缺点。但是，由于它可以消除内存碎片，提高内存利用率，所以在需要长时间运行的应用程序中，标记整理算法通常比标记清除算法更加适用。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/ppf1MnJ.png" alt=""></li><br>&lt;/ul&gt;</p>
<p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul></p>
<p><li>复制算法是一种基于内存分区的垃圾回收算法，它将内存分成两个区域：From空间和To空间。在正常情况下，所有的对象都被分配在From空间中。当需要进行垃圾回收时，算法会扫描From空间中的所有对象，并将存活的对象复制到To空间中。复制完成后，From空间中的对象都可以被视为垃圾，并可以被回收。</li></p>
<p><li>接下来，详细介绍一下复制算法的工作原理：<ol></p>
<p><li><code>内存分配：</code>在程序运行过程中，对象的内存分配只在From空间中进行。当From空间快要用完时，算法会触发一次垃圾回收操作。</li></p>
<p><li><code>扫描存活对象：</code>在进行垃圾回收时，算法会遍历From空间中的所有对象，并标记存活的对象。为了标记存活对象，复制算法使用了一种叫做<code>可达性分析</code>的技术，这个技术可以判断一个对象是否是存活对象。与标记清除算法和标记整理算法不同的是，复制算法并不需要进行标记和清除的分离过程，因为复制算法是将存活对象复制到To空间中，所以只要扫描完From空间中的所有对象，并将存活对象复制到To空间中，就可以直接清除From空间了。</li></p>
<p><li><code>复制存活对象：</code>在扫描存活对象之后，算法会将所有存活对象从From空间复制到To空间。复制的过程是按照对象的存活顺序进行的，也就是说，如果对象A引用了对象B，那么对象B会被先复制到To空间中。复制完成后，To空间的使用量会变得很满，From空间的使用量则变得很少。</li></p>
<p><li><code>交换空间：</code>在复制完所有存活对象之后，From空间中剩余的对象都可以视为垃圾，并可以被回收。为了保证下一次的内存分配，To空间和From空间会进行交换，也就是说，To空间成为了新的From空间，From空间成为了新的To空间。这样一来，内存分配就可以在新的From空间中进行了。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/ppf18tx.png" alt=""></p></p>
<p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul></p>
<p><li>总结一下这三种垃圾回收算法的优缺点<ol></p>
<p><li><code>标记清除：</code>速度较快，但会产生内存碎片</li></p>
<p><li><code>标记整理：</code>速度较慢，但是不会产生内存碎片</li></p>
<p><li><code>复制：</code>不会产生内存碎片，但是需要占用双倍内存空间</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><ul></p>
<p><li>JVM（Java虚拟机）的分代垃圾回收是一种优化内存回收的技术。它利用对象的生命周期来将堆（heap）分为不同的区域，然后针对不同区域的特点采用不同的垃圾回收算法。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/ppf8hYq.png" alt=""></li></p>
<p><li>对象首先分配在伊甸园区域</li></p>
<p><li>新生代空间不足时，触发<code>minor gc</code>，<code>伊甸园</code>和<code>from</code>存活的对象使用<code>copy</code>复制到<code>to</code>中，存活的对象年龄<code>+1</code>并且交换<code>from</code>和<code>to</code></li></p>
<p><li><code>minor gc</code>会引发<code>stop the world（砸瓦鲁多！！）</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></p>
<p><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15<ul></p>
<p><li>Java中的对象头中确实分配了一定的字节用来记录对象的年龄，而这个字节的位数是4，因此其二进制最大值为1111，即十进制的15</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li>当老年代空间不足，会先尝试触发<code>minor gc</code>，如果之后空间仍不足，那么触发<code>full gc</code>，STW的时间更长</li><br>&lt;/ul&gt;</p>
<p><h2 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h2><div class="table-container"></p>
<p><table></p>
<p><thead></p>
<p><tr></p>
<p><th style="text-align:center">含义</th></p>
<p><th style="text-align:center">参数</th><br>&lt;/tr&gt;<br>&lt;/thead&gt;</p>
<p><tbody></p>
<p><tr></p>
<p><td style="text-align:center">堆初始大小</td></p>
<p><td style="text-align:center">-Xms</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">堆最大大小</td></p>
<p><td style="text-align:center">-Xmx 或 -XX:MaxHeapSize=size</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">新生代大小</td></p>
<p><td style="text-align:center">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">幸存区比例（动态）</td></p>
<p><td style="text-align:center">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">幸存区比例</td></p>
<p><td style="text-align:center">-XX:SurvivorRatio=ratio</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">晋升阈值</td></p>
<p><td style="text-align:center">-XX:MaxTenuringThreshold=threshold</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">晋升详情</td></p>
<p><td style="text-align:center">-XX:+PrintTenuringDistribution</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">GC 详情</td></p>
<p><td style="text-align:center">-XX:+PrintGCDetails -verbose:gc</td><br>&lt;/tr&gt;</p>
<p><tr></p>
<p><td style="text-align:center">Full GC 前 Minor GC</td></p>
<p><td style="text-align:center">-XX:+ScavengeBeforeFullGC</td><br>&lt;/tr&gt;<br>&lt;/tbody&gt;<br>&lt;/table&gt;<br>&lt;/div&gt;</p>
<p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="串行收集器（Serial收集器）"><a href="#串行收集器（Serial收集器）" class="headerlink" title="串行收集器（Serial收集器）"></a>串行收集器（Serial收集器）</h2><ul></p>
<p><li>这是最简单的垃圾回收器，它通过一个单线程进行垃圾回收，因此它的优点是简单高效，但缺点是在大型应用程序中可能会出现停顿时间过长的问题。</li></p>
<p><li>串行收集器的缺点主要是单线程执行垃圾回收操作，不能充分利用多核CPU的计算能力，同时垃圾回收操作会阻塞应用程序的运行，可能会导致长时间的停顿。因此，在大型的、多线程的应用程序中，通常不适合使用串行收集器进行垃圾回收。</li></p>
<p><li><p>对应的VM参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></p>
</li></p>
<p><li><p>下图中，其他CPU需要等待<code>CPU 2</code>执行完垃圾回收后，才能继续运行<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/ppfDKTf.png" alt=""></p>
</li><br>&lt;/ul&gt;</p>
<p><h2 id="吞吐量优先收集器（Parallel收集器）"><a href="#吞吐量优先收集器（Parallel收集器）" class="headerlink" title="吞吐量优先收集器（Parallel收集器）"></a>吞吐量优先收集器（Parallel收集器）</h2><ul></p>
<p><li>JDK 1.8 默认采用的就是这种垃圾回收器</li></p>
<p><li>它是一种基于多线程并行执行的垃圾回收器，它的主要目标是提高应用程序的吞吐量，即在单位时间内处理更多的请求。</li></p>
<p><li>相关VM参数<ol></p>
<p><li><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC：</code><ul></p>
<p><li>这两个参数分别用于开启并行垃圾回收器和并行老年代垃圾回收器。其中，-XX:+UseParallelGC用于开启并行垃圾回收器，-XX:+UseParallelOldGC用于开启并行老年代垃圾回收器。使用这两个参数可以开启Parallel收集器。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:+UseAdaptiveSizePolicy：</code><ul></p>
<p><li>这个参数用于自适应地调整Java堆大小和垃圾收集器的参数，以达到更好的垃圾回收效果。当开启该参数时，JVM会自动调整Eden区、Survivor区、老年代的大小以及垃圾回收线程的数量等参数，以达到更高的垃圾回收效率。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:GCTimeRatio=ratio：</code><ul></p>
<p><li>这个参数用于设置垃圾回收所占用CPU时间和应用程序运行时间的比率。默认值是99，表示垃圾回收时间最多可以占用1%的CPU时间，计算公式为<code>1/(1 + ratio)</code></li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:MaxGCPauseMillis=ms：</code><ul></p>
<p><li>这个参数用于设置最大垃圾回收暂停时间。默认值是200ms。如果设置该参数，JVM会尽可能地控制垃圾回收暂停的时间不超过该值。如果需要更短的垃圾回收暂停时间，则可以将该值设置为较小的数值。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:ParallelGCThreads=n：</code><ul></p>
<p><li>这个参数用于设置垃圾回收线程的数量。默认值是CPU核心数的1/4。可以根据应用程序的需求和硬件环境来调整该参数的值，以达到更好的垃圾回收效果。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pphfXnO.png" alt=""></p></p>
<p><h2 id="CMS收集器（响应时间优先）"><a href="#CMS收集器（响应时间优先）" class="headerlink" title="CMS收集器（响应时间优先）"></a>CMS收集器（响应时间优先）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul></p>
<p><li>CMS（Concurrent Mark Sweep）是一种垃圾回收算法，它的设计目标是在最短的停顿时间内回收垃圾。它通过在一个线程中进行垃圾回收并在应用程序线程中同时运行，从而减少停顿时间。下面详细介绍CMS垃圾收集器的工作原理和优缺点。</li><br>&lt;/ul&gt;</p>
<p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul></p>
<p><li>CMS垃圾收集器的工作可以分为以下几个阶段：<ol></p>
<p><li>初始标记阶段（Initial Marking）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且在内存中标记出所有被直接引用的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li></p>
<p><li>并发标记阶段（Concurrent Marking）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时标记出所有被间接引用的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li></p>
<p><li>重新标记阶段（Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发标记阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li></p>
<p><li>并发清除阶段（Concurrent Sweeping）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时清除所有标记为垃圾的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li></p>
<p><li>最终标记阶段（Final Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发清除阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pph4Ca4.png" alt=""></p></p>
<p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul></p>
<p><li><p>优点</p></p>
<p><ol></p>
<p><li>可以在最短的停顿时间内回收垃圾，不会出现长时间的停顿现象，因此适合响应时间比较敏感的应用程序。</li></p>
<p><li>采用并发的垃圾收集方式，能够与应用程序并发执行，不会阻塞应用程序的执行，因此对于需要保证应用程序响应性能的场景非常适用。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;</p>
<p><li><p>缺点</p></p>
<p><ol></p>
<p><li>对 CPU 的使用比较敏感，在高负载情况下可能会影响应用程序的性能。</li></p>
<p><li>由于并发清除阶段无法整理内存，可能会出现内存碎片化的问题，导致后续垃圾回收过程需要更多的时间。</li></p>
<p><li>在处理大量的垃圾时可能会导致应用程序的性能下降，因为需要占用一定的 CPU 资源。</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><h3 id="相关VM参数-1"><a href="#相关VM参数-1" class="headerlink" title="相关VM参数"></a>相关VM参数</h3><ol></p>
<p><li><code>-XX:ParallelGCThreads=n：</code><ul></p>
<p><li>指定并行垃圾回收器的线程数。默认值是处理器核心数。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:ConcGCThreads=threads：</code><ul></p>
<p><li>指定并发垃圾回收器的线程数。默认值是处理器核心数的<code>1/4</code>。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:CMSInitiatingOccupancyFraction=percent：</code><ul></p>
<p><li>指定 CMS 垃圾回收器开始执行垃圾回收的阈值。当老年代空间使用达到指定百分比时，CMS 垃圾回收器会开始执行垃圾回收。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;</p>
<p><li><code>-XX:+CMSScavengeBeforeRemark：</code><ul></p>
<p><li>启用 CMS 垃圾回收器在进行重新标记之前执行新生代的垃圾回收。这可以减少重新标记的时间，从而减少应用程序暂停的时间。</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ol&gt;</p>
<p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul></p>
<p><li>G1（Garbage-First）是一种现代化的垃圾回收器，它在<code>JDK 7</code>中首次引入，并在<code>JDK 9</code>中被标记为默认垃圾回收器。<ul></p>
<p><li>与之前的垃圾回收器相比，G1的最大优势在于它可以更好地处理占据大量堆内存的Java应用程序，从而避免了传统垃圾回收器在大内存情况下可能出现的停顿</li><br>&lt;/ul&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul></p>
<p><li>G1采用了一种不同于传统垃圾回收器的回收方式，它将内存划分为大小相等的多个区域（Region），每个区域的大小通常为<code>1MB</code>到<code>32MB</code>。G1将这些区域分为新生代和老年代，其中新生代通常占整个堆内存的5%到10%，老年代则占90%到95%。</li></p>
<p><li>G1将堆内存划分为多个区域后，它就可以对每个区域分别进行垃圾回收，从而避免了FULL GC带来的长时间停顿。</li><br>&lt;/ul&gt;</p>
<p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ul></p>
<p><li>G1的垃圾回收流程如下  <ol></p>
<p><li><code>初始标记（Initial Mark）：</code>G1在此阶段会扫描堆内存中的根对象，并标记所有的根对象，以便后续回收时可以快速定位到这些根对象</li></p>
<p><li><code>并发标记（Concurrent Mark）：</code>在此阶段，G1会与应用程序并发的执行，扫描堆内存中的所有存活对象，并标记这些对象。在整个过程中，应用程序可以继续执行，因此在这个阶段不会产生长时间的停顿</li></p>
<p><li><code>确定标记（Remark）：</code>在并发标记结束后，G1需要在一个短暂的停顿期间重新扫描堆内存，以便确定所有的存活对象已经被标记</li></p>
<p><li><code>清除（Cleanup）：</code>在确定标记阶段结束后，G1会对未标记的区域进行回收，并将回收得到的空闲区域加入到空闲列表中，以便下次回收内存时使用</li><br>&lt;/ol&gt;<br>&lt;/li&gt;<br>&lt;/ul&gt;</p>
<p><h3 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h3><ul></p>
<p><li><p>在G1垃圾回收器中，垃圾回收的过程可以分为三种阶段：<code>Young Collection</code>、<code>Young Collection + Concurrent Mark</code>（简称Young Collection + CM）和<code>Mixed Collection</code>。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pphHKdf.png" alt=""></p>
</li></p>
<p><li><p>下面我们分别介绍一下这三种垃圾回收阶段和特点：</p></p>
<p><ol></p>
<p><li><p><code>Young Collection</code>（年轻代垃圾回收）</p></p>
<ul>
<li>Young Collection是指对年轻代（Young Generation）的垃圾回收。在G1垃圾回收器中，年轻代通常是由几个连续的Region组成的。在年轻代垃圾回收期间，G1垃圾回收器会扫描年轻代内的所有对象，并标记那些被引用的对象。然后，它会将未被引用的对象回收掉，并将被引用的对象移动到下一个垃圾回收周期的存活区域（Survivor Region）中。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pphH2ex.png" alt=""></li>
</ul>
</li>
<li><p><code>Young Collection + Concurrent Mark</code>（年轻代垃圾回收 + 并发标记）</p>
<ul>
<li>Young Collection + CM是：指在<code>Young GC</code>时会进行<code>GC Root</code>的初始标记，当老年代占用堆空间比例达到阈值时，对整个堆内存进行并发标记。由下面的VM参数决定<ul>
<li>-XX:InitiatingHeapOccupancyPercent=percent （默认45%）</li>
</ul>
</li>
<li>在并发标记过程中，G1垃圾回收器会扫描所有的可达对象，并标记它们。并发标记可以与应用程序并行进行，不会停顿应用程序的线程。当并发标记完成后，G1垃圾回收器就可以知道哪些对象是存活的，哪些对象是垃圾了。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pphHWTK.png" alt=""></li>
</ul>
</li>
<li><p><code>Mixed Collection</code>（混合垃圾回收）</p>
<ul>
<li>Mixed Collection是指对整个堆内存进行垃圾回收，包括年轻代和老年代（Old Generation）的垃圾回收。在Mixed Collection期间，G1垃圾回收器会尽可能地回收那些垃圾占用空间较大的Region，并将它们标记为”空闲”状态，以便在以后的内存分配中使用。与Young Collection不同，Mixed Collection不仅回收年轻代的对象，还回收老年代的对象，因此它需要更长的停顿时间。同时，Mixed Collection也会和并发标记一起执行，以最小化应用程序的停顿时间。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pphH4YD.png" alt=""></li>
</ul>
</li>
</ol>
</li>
<li><p>新生代内存不足发生的垃圾收集：minor gc</p>
</li>
<li>当G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发FULL GC。</li>
</ul>
<h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><ul>
<li>当进行新生代垃圾回收时，需要找到新生代对象的跟对象来确定哪些对象是存活的，那些对象需要被回收。然而根对象中可能有一部分存活在老年代中，如果每次都要遍历老年代来查找这些根对象，将会导致效率低下</li>
<li>为了解决这个问题，G1垃圾回收器采用了一种卡表技术，将老年代划分为多个区域，并将每个区域划分为一组成为<code>卡</code>的块。每个卡的大小约为512KB，如果老年代中的一个对象引用了新生代中的对象，那么该卡就被标记为脏卡</li>
<li>在新生代对象引用发生变化时，使用post-write barrier和dirty card queue技术来更新卡表，将引用变更信息添加到Remembered Set中，标记为脏卡</li>
<li>在进行新生代垃圾回收时，只需要扫描这些脏卡中的对象，即可找到所有的跨代引用对象，避免了对整个老年代进行遍历的开销，提高了垃圾回收的效率。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pp4XhcD.png" alt=""></li>
</ul>
<h3 id="重新标记阶段"><a href="#重新标记阶段" class="headerlink" title="重新标记阶段"></a>重新标记阶段</h3><ul>
<li>在G1垃圾回收器的remark阶段中，它使用三色标记法来标记存活对象，并结合SATB和写屏障来跟踪对象的引用关系，以便在标记阶段中更准确地标记存活对象。</li>
<li>remark阶段开始时，G1垃圾回收器会将所有被标记为灰色的对象加入到处理队列中，然后开始遍历处理队列中的对象。对于每个灰色对象，G1垃圾回收器会扫描其所有引用域，并将任何未被标记为黑色的引用加入到SATB中，以便在后续标记阶段中更准确地跟踪引用关系。</li>
<li>同时，在遍历处理队列中的对象时，G1垃圾回收器会将灰色对象的引用对象标记为灰色，将灰色对象标记为黑色，并将其从处理队列中移除。这个过程会一直持续，直到处理队列中不再有灰色对象。</li>
<li>在remark阶段中，SATB写屏障起到了重要作用。当程序在运行时修改一个对象的引用时，SATB写屏障会记录这个修改，并将相关信息保存到一个记录缓存中。在remark阶段中，G1垃圾回收器会遍历记录缓存中所有被标记为脏的对象，并遍历这些对象的引用域，以确定它们所引用的对象是否需要被标记为灰色。</li>
<li>通过三色标记法、SATB和写屏障的结合使用，G1垃圾回收器可以更准确地标记存活对象，并且在标记阶段中只标记那些需要被标记的对象，从而提高垃圾回收器的性能和效率。</li>
</ul>
<h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><ul>
<li><p>当新生代中的对象被晋升到老年代时，如果这些对象是字符串类型，那么会将它们放入一个特殊的队列中，而不是直接将它们放入老年代中。这个队列称为String Deduplication Queue，可以理解为字符串去重队列。</p>
</li>
<li><p>G1垃圾回收器在remark阶段中会扫描String Deduplication Queue中的所有字符串，检查是否有重复的字符串。如果发现有重复的字符串，就会让它们引用同一个<code>char[]</code>，以达到字符串去重的目的。需要注意的是，这里去重的对象是<code>char[]</code>，而不是String对象本身，与<code>String.intern()</code>不同。</p>
</li>
<li><p>为了实现这一功能，G1垃圾回收器内部维护了一个字符串表，用来存储所有已经去重的<code>char[]</code>。当遍历String Deduplication Queue时，G1垃圾回收器会将每个字符串的<code>char[]</code>进行哈希，然后在字符串表中查找是否存在相同哈希值的<code>char[]</code>，如果存在，就会比较这两个<code>char[]</code>的内容是否相同，从而确定是否是同一个字符串。如果是同一个字符串，就将这个字符串对象的引用指向字符串表中的<code>char[]</code>，从而达到字符串去重的目的。</p>
</li>
<li><p>总之，G1垃圾回收器的字符串去重功能可以大幅度减少堆内存中的重复字符串，从而降低垃圾回收器的内存占用和垃圾回收的开销，提高程序的性能。</p>
<ul>
<li>优点：节省大量内存</li>
<li>缺点：稍微多占用了CPU时间，新生代回收时间略微增加</li>
</ul>
</li>
</ul>
<h3 id="并发标记类卸载"><a href="#并发标记类卸载" class="headerlink" title="并发标记类卸载"></a>并发标记类卸载</h3><ul>
<li>在 G1 垃圾回收器进行并发标记后，它可以识别出哪些类不再被使用。当一个类加载器的所有类都不再被使用时，就可以卸载该类加载器所加载的所有类。</li>
<li>G1 垃圾回收器默认开启了类卸载功能，可以通过 <code>JVM</code> 参数 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 显式启用。</li>
</ul>
<h3 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h3><ul>
<li>对象大小超过了G1 Heap中的Region大小的一半时，被称为巨型对象（Huge Object）。</li>
<li>G1不会将巨型对象分配到Region中，而是直接分配在Humongous区域中。Humongous区域是一组连续的Region，大小为2的幂次方倍。如果一个巨型对象的大小超过了Humongous区域的大小，则会跨越多个Humongous区域。</li>
<li>在标记阶段，G1会优先处理巨型对象，以便在回收过程中更好地利用它们的空间。这样可以避免因巨型对象被其他对象占用而导致的内存浪费。</li>
<li>在G1中，老年代中所有的incoming引用会被跟踪，如果某个巨型对象的incoming引用计数为0，说明该对象不再被其他对象引用，可以直接被回收。这个过程发生在新生代回收之前，可以帮助释放空间。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/violet617/ImgBed@main/JavaBase/JVMpart/pp4zsxK.png" alt=""></li>
</ul>
<h3 id="并发表及起始时间调整"><a href="#并发表及起始时间调整" class="headerlink" title="并发表及起始时间调整"></a>并发表及起始时间调整</h3><ul>
<li>前面说如果G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发<code>FULL GC</code>。</li>
<li>并发标记阶段是 G1 垃圾回收的一个重要阶段，需要在堆空间占满之前完成，否则就会退化为 FullGC。为了避免这种情况的发生，JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数来手动设置并发标记的触发阈值（默认为45%），以确保在这个阈值之前就完成并发标记。而在 JDK 9 及以后的版本中，可以根据实际情况动态调整并发标记的触发阈值，以避免 <code>Full GC</code> 的发生。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数用于设置并发标记的初始触发阈值，但是 G1 在进行并发标记时会进行数据采样，并根据采样数据动态调整并发标记的触发阈值，以确保并发标记可以在堆空间不被填满的情况下完成。同时，G1 还会在堆空间中留出一定的安全空档空间，以避免因为堆空间占满而触发 <code>Full GC</code>。</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：<ol>
<li><code>分区回收：</code>G1将堆内存划分为多个区域，并对每个区域分别进行回收，从而避免<code>FULL GC</code>带来的长时间停顿</li>
<li><code>并发回收：</code>G1在标记和清除阶段都可以与应用程序并发执行，从而避免了长时间的停顿</li>
<li><code>预测性停顿：</code>G1可以根据应用程序的内存使用情况预测合适需要进行<code>FULL GC</code>，从而在垃圾回收过程中尽可能地减少停顿时间</li>
<li><code>空间整合：</code>G1可以在回收过程中对空间进行整合，从而可以更好的利用堆内存</li>
<li><code>可预测性：</code>G1可以设置预期的停顿时间，以便开发人员可以更好地控制应用程序的性能</li>
</ol>
</li>
<li>缺点<ol>
<li>初始标记和确定标记阶段需要短暂的停顿时间，虽然停顿时间短暂，但是仍然可能影响应用程序的性能</li>
<li>G1需要更多的CPU资源来完成垃圾回收，因为它需要同时处理多个分区</li>
<li>对于小型应用程序，G1可能会产生过多的内存分配和垃圾回收开销，从而导致应用程序性能下降</li>
</ol>
</li>
</ul>
<h1 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ol>
<li>掌握GC相关的VM参数，会基本的空间调整</li>
<li>掌握相关工具<ul>
<li><code>jsp</code></li>
<li><code>jmap</code></li>
<li><code>jconsole</code></li>
<li><code>jvisualvm</code></li>
</ul>
</li>
<li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则，都是具体情况具体分析</li>
</ol>
<h2 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h2><ul>
<li>JVM的GC调优是Java应用程序性能调优的一个重要方面。在进行GC调优之前，需要先确定应用程序的性能瓶颈，通常可以从内存、锁竞争、CPU占用和IO等方面入手进行调优。</li>
</ul>
<ol>
<li><code>内存调优</code><ul>
<li>内存调优主要是针对JVM的堆内存和非堆内存进行调优。在Java应用程序中，大部分的对象都是分配在堆内存中的。因此，对于堆内存的调优非常重要。</li>
<li>如果堆内存的大小设置过小，就会频繁地进行垃圾回收，导致应用程序的性能下降。如果堆内存的大小设置过大，就会浪费系统资源。</li>
<li>对于非堆内存，可以考虑调整JVM的元空间大小来减少元数据的内存占用。</li>
</ul>
</li>
<li><p><code>锁竞争调优</code></p>
<ul>
<li>Java中的锁机制是实现并发的重要手段，但是锁的竞争会导致应用程序的性能下降。因此，锁竞争调优是Java应用程序性能调优的一个重要方面。</li>
<li>可以通过使用synchronized关键字和Lock接口来进行锁竞争调优。synchronized关键字是Java中实现锁的一种简单方式，但是在高并发场景下，由于锁粒度较大，容易导致锁竞争。</li>
<li>因此，在高并发场景下，可以考虑使用Lock接口来实现锁。Lock接口支持更细粒度的锁，并且可以控制锁的获取和释放。</li>
</ul>
</li>
<li><p><code>CPU占用调优</code></p>
<ul>
<li>CPU占用调优是指通过优化代码来减少CPU的占用率，提高应用程序的性能。</li>
<li>可以通过以下方式来进行CPU占用调优：<ol>
<li><code>减少线程数：</code>线程数过多会导致CPU占用率上升，因此可以通过减少线程数来降低CPU占用率。</li>
<li><code>避免无用循环：</code>无用循环会导致CPU占用率上升，因此可以通过优化代码来减少无用循环的出现。</li>
<li><code>避免递归调用：</code>递归调用会导致CPU占用率上升，因此可以通过优化代码来避免递归调用的出现。</li>
</ol>
</li>
</ul>
</li>
<li><code>IO调优</code><ul>
<li>IO调优是指通过优化IO操作来提高应用程序的性能。</li>
<li>可以通过以下方式来进行IO调优：<ol>
<li><code>减少IO操作：</code>减少IO操作可以减少IO调用的次数，从而提高应用程序的性能。</li>
<li><code>使用缓存：</code>缓存可以减少IO调用的次数，从而提高应用程序的性能。</li>
<li><code>使用异步IO：</code>异步IO可以在IO操作期间释放CPU资源，从而提高应用程序的性能。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><ul>
<li>我们首先要清楚我们的应用程序是干什么的，即确定一个垃圾回收的目标<ul>
<li>如果是做一些科学运算、批量处理，那么追求的就是高吞吐量，延长一点点响应时间对我们没有太大影响</li>
<li>如果是做一些互联网、金融、电子商务项目，那么响应时间就是一个非常重要的指标了，如果每次垃圾回收都延长了响应时间，就会给用户造成不好的体验</li>
</ul>
</li>
<li>确定了目标以后，我们再来选择合适的垃圾回收器<ul>
<li>对于高吞吐量的应用程序，通常可以选择 <code>Parallel GC</code> 等并行垃圾回收器来实现高效的垃圾回收。</li>
<li>而对于需要低延迟、高响应时间的应用程序，可以选择 <code>CMS</code>、<code>G1</code>、<code>ZGC</code>、<code>Zing</code> 等低延迟垃圾回收器来实现。</li>
</ul>
</li>
</ul>
<h2 id="最快的GC"><a href="#最快的GC" class="headerlink" title="最快的GC"></a>最快的GC</h2><ul>
<li>最快的GC是不发生GC，即尽可能减少内存分配和回收的次数。因此，建议在代码中尽量避免频繁地创建和销毁对象，或者使用不必要的大型数据结构。</li>
<li>查看<code>FULL GC</code>前后的内存占用，考虑以下几个问题<ol>
<li>数据是不是太多？<ul>
<li>例如下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 大表</span><br></pre></td></tr></table></figure></li>
<li>查询大表时，如果数据量太大，会占用大量的内存空间，导致频繁的GC，甚至可能直接内存溢出，建议在查询时加上限制条件（如limit）来减小数据量。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 大表 LIMIT n</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数据表示是否太臃肿？<ul>
<li>如果数据结构过于庞大，例如包含大量不必要的字段或者对象引用，也会占用大量内存空间。</li>
<li>例如在Java中，Integer是一个对象，而int是一个基本数据类型。因此，当我们使用Integer时，实际上是创建了一个对象来存储整数值。相对地，使用int时，只需要直接在栈上分配一个内存空间来存储整数值，不需要再创建对象，因此内存占用更小。<ul>
<li>Integer对象占用的内存空间包含了对象头、对象的值等信息，一般需要占据16个字节</li>
<li>而int类型只需要占用4个字节的内存空间。</li>
</ul>
</li>
</ul>
</li>
<li>是否存在内存泄露？<ul>
<li>例如我们创建一个静态的Map对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li>一直向静态Map中存储数据，会导致静态Map中的内存占用越来越大，可能导致频繁的GC和内存溢出。因为静态变量属于类，不会被垃圾回收器自动释放。这种情况可以使用软引用或弱引用来引用该对象，以便在内存不足时自动释放缓存数据。</li>
<li>但还是不建议使用Java来实现缓存，而是推荐使用第三方缓存实现，例如Redis等</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><ul>
<li>在新生代调优之前，我们先来回顾一下新生代的特点<ol>
<li>所有的new操作的内存分配都非常廉价，即分配速度很快。</li>
<li>死亡对象的回收：Java虚拟机有自动垃圾回收机制，用于回收不再被使用的对象。在新生代中，回收死亡对象的代价为零，因为它们可以很容易地被回收。</li>
<li>大部分对象用过即死：大部分对象的生命周期很短，使用一次就被丢弃了，这是因为Java中的对象通常用于执行一些特定的任务，而不是被持续使用。</li>
<li>Minor GC：Java虚拟机会周期性地进行垃圾回收操作，其中一种是Minor GC，用于回收新生代中的对象。由于新生代中的对象生命周期短，因此Minor GC的时间通常比Full GC（用于回收老年代中的对象）短很多。</li>
</ol>
</li>
<li><p>调优参数：<code>-Xmn</code>设置新生代大小</p>
<ul>
<li>那么是设置的越大越好吗？不是的，官方文档中给出的解释如下<div class="note info no-icon flat"><ul>
<li>-Xmn<ul>
<li>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC isperformed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</li>
<li>设置新生代堆的初始大小和最大大小（以字节为单位）。垃圾回收在新生代中比其他区域更频繁地进行。如果新生代的大小过小，则会执行很多次<code>Minor GC</code>。如果大小过大，则只执行<code>FULL GC</code>，这可能需要很长时间才能完成。Oracle 建议您将新生代的大小保持在总堆大小的 25% 以上且低于 50%。</li>
</ul>
</li>
</ul>
</div>
</li>
</ul>
</li>
<li><p>新生代大小最好能容纳所有<code>并发量 * (请求-响应)</code>的数据</p>
<ul>
<li>例如一次请求响应需要<code>512KB</code>内存，并发量为<code>10000</code>，那么差不多就是<code>5GB</code></li>
</ul>
</li>
<li>幸存区要大到能够保留<code>当前活跃的对象 + 需要晋升的对象</code>    <ul>
<li>如果幸存区过小，JVM会灵活调整晋升的阈值，从而可能导致某些对象被提前晋升到老年代，从而将其从幸存区释放。当幸存区不足以容纳所有存活的对象时，垃圾回收器会选择将一部分对象直接晋升到老年代，而不是等待这些对象达到晋升的阈值再晋升。</li>
<li>这样做的问题在于，新生代中的对象通常比老年代中的对象生命周期短，如果过早地将这些对象晋升到老年代，可能会导致老年代中存在许多生命周期很短的对象，从而增加垃圾回收的压力，甚至导致堆内存溢出。</li>
<li>因此，为了变过早地将对象晋升到老年代，通常建议将幸存区设置的足够大，以便能够<code>容纳当前活跃对象与需要晋升对象的总和</code>。这也可以减少对象直接晋升到老年代的情况，提高了年轻代的空间利用率，并减轻垃圾回收的压力。</li>
</ul>
</li>
<li>晋升阈值也要配置得当<ul>
<li>调整晋升阈值是为了让存活时间较长的对象能尽早进入老年代，这样可以减少在幸存区进行复制操作的次数和数量。</li>
<li>相关VM参数：<ul>
<li>调整最大晋升阈值：<code>-XX:MaxTenuringThreshold=threshold</code></li>
<li>垃圾回收时打印存活对象详情：<code>-XX:+PrintTenuringDistribution</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size 48286924 bytes, new threshold 10 (max 10)</span><br><span class="line">- age 1: 28992024 bytes, 28992024 total</span><br><span class="line">- age 2: 1366864 bytes, 30358888 total</span><br><span class="line">- age 3: 1425912 bytes, 31784800 total</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h2><ul>
<li>以CMS为例<ul>
<li>CMS的老年代内存越大越好</li>
<li>先不进行调优，如果没有发生FULL GC，那么说明程序运行良好，应该先尝试新生代调优</li>
<li>观察发生FULL GC时老年代内存占用，将老年代内存预设增加 1/4 ~ 1/3。<ul>
<li>然后逐步调整-XX:CMSInitiatingOccupancyFraction参数的值，找到一个合适的设置值。</li>
<li>一般来说，可以将该参数设置在75% ~ 85%之间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><div class="note info no-icon flat"><ul>
<li><code>Full GC</code> 和 <code>Minor GC</code> 频繁</li>
</ul>
</div>
<ul>
<li>如果 <code>Full GC</code> 和 <code>Minor GC</code> 频繁发生<ul>
<li>那么可能就是我们之前提到过的，幸存区过小，导致某些短生命周期对象晋升到了老年代</li>
</ul>
</li>
<li>可以尝试调整内存分配比例<ul>
<li>通过调整新生代和老年代的内存分配比例来减少 <code>Minor GC</code> 和 <code>Full GC</code> 的频率。</li>
<li>一般情况下，新生代的大小应该比老年代小，可以尝试逐步增加新生代的大小，减少老年代的大小</li>
</ul>
</li>
</ul>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><div class="note info no-icon flat"><ul>
<li>请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</li>
</ul>
</div>
<ul>
<li>首先我们来分析一下具体是哪部分耗时较长，由于我们采用的是CMS收集器，在 CMS 收集器中，重新标记阶段通常是导致单次暂停时间变长的主要因素之一。</li>
<li>如果我们在重新标记之前进行一次新生代的垃圾回收，可以减少堆中对象的数量，从而减少重新标记的时间。</li>
<li>具体使用 <code>-XX:+CMSScavengeBeforeRemark</code> 参数，可以让 CMS 在重新标记之前进行一次新生代的垃圾回收。</li>
</ul>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><ul>
<li>老年代充裕情况下，发生 Full GC （CMS jdk1.7）</li>
</ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">violet617</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/25/JVMPart/JVM_3/">http://example.com/2023/04/25/JVMPart/JVM_3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">violet617</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/650478a5661c6c8e54c6ca3f.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/25/JVMPart/JVM_2/" title="JVM系列(2)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/650478a3661c6c8e54c6c697.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM系列(2)</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/JVMPart/JVM_4/" title="JVM系列(4)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/650478a5661c6c8e54c6ca08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM系列(4)</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/suolong.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">violet617</div><div class="author-info__description">violet617的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">总有人间一两风</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">如何判断对象可以回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">软引用应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">引用队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">2.1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">标记整理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">分代垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3VM%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">相关VM参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Serial%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">串行收集器（Serial收集器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Parallel%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">吞吐量优先收集器（Parallel收集器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">CMS收集器（响应时间优先）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3VM%E5%8F%82%E6%95%B0-1"><span class="toc-number">4.3.4.</span> <span class="toc-text">相关VM参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1"><span class="toc-number">4.4.</span> <span class="toc-text">G1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.4.3.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">4.4.4.</span> <span class="toc-text">垃圾回收阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8"><span class="toc-number">4.4.5.</span> <span class="toc-text">跨代引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">4.4.6.</span> <span class="toc-text">重新标记阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">4.4.7.</span> <span class="toc-text">字符串去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">4.4.8.</span> <span class="toc-text">并发标记类卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.9.</span> <span class="toc-text">回收巨型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%A1%A8%E5%8F%8A%E8%B5%B7%E5%A7%8B%E6%97%B6%E9%97%B4%E8%B0%83%E6%95%B4"><span class="toc-number">4.4.10.</span> <span class="toc-text">并发表及起始时间调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">4.4.11.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98"><span class="toc-number">5.</span> <span class="toc-text">垃圾回收调优</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E9%A2%86%E5%9F%9F"><span class="toc-number">5.2.</span> <span class="toc-text">调优领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="toc-number">5.3.</span> <span class="toc-text">确定目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%BF%AB%E7%9A%84GC"><span class="toc-number">5.4.</span> <span class="toc-text">最快的GC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">5.5.</span> <span class="toc-text">新生代调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">5.6.</span> <span class="toc-text">老年代调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">5.7.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1"><span class="toc-number">5.7.1.</span> <span class="toc-text">案例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2"><span class="toc-number">5.7.2.</span> <span class="toc-text">案例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3"><span class="toc-number">5.7.3.</span> <span class="toc-text">案例3</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/24/JVMPart/JVM_1/" title="JVM系列(1)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65047880661c6c8e54c6bab5.jpg" alt="JVM系列(1)"></a><div class="content"><a class="title" href="/2023/04/24/JVMPart/JVM_1/" title="JVM系列(1)">JVM系列(1)</a><time datetime="2023-04-24" title="发表于 2023-04-24">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/06/IQList/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/" title="JVM知识点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65047898661c6c8e54c6c0ca.jpg" alt="JVM知识点"></a><div class="content"><a class="title" href="/2023/05/06/IQList/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/" title="JVM知识点">JVM知识点</a><time datetime="2023-05-06" title="发表于 2023-05-06">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/27/JVMPart/JVM_5/" title="JVM系列(5)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6504789e661c6c8e54c6c2d2.jpg" alt="JVM系列(5)"></a><div class="content"><a class="title" href="/2023/04/27/JVMPart/JVM_5/" title="JVM系列(5)">JVM系列(5)</a><time datetime="2023-04-27" title="发表于 2023-04-27">2023-04-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By violet617</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-lac-one.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-lac-one.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('/js/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://varcel-jdrttcshu-violet617.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('/css/waline.min.css').then(() => {
      getScript('/js/waline.min.js').then(initWaline)
    })
  }
}

if ('Twikoo' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script src="/js/jquery.min.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script src="/js/myTitle.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="music"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/01/10/hello-world/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/650478a3661c6c8e54c6c6bd.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/01/10/hello-world/&quot;);" href="javascript:void(0);" alt="">Hello World</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/01/10/hello-world/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2021/11/16/LinuxNotes/Linux/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/65047890661c6c8e54c6be0a.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-11-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2021/11/16/LinuxNotes/Linux/&quot;);" href="javascript:void(0);" alt="">Linux 常用命令</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2021/11/16/LinuxNotes/Linux/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>