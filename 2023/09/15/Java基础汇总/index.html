<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础汇总 | violet617</title><meta name="author" content="violet617"><meta name="copyright" content="violet617"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java语言有哪些特点                                简单易学：Java有丰富的类库，不用手写轮子面向对象：Java是一门面向对象的语言，支持封装、继承、多态跨平台性：Java程序可以在不同的操作系统和硬件平台上运行，实现了一次编写，到处运行的目标安全性：Java具有高度的安全性，提供了注入类加载器、安全管理器和异常处理机制等安全机制Java类加载器采用双亲委派模">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础汇总">
<meta property="og:url" content="http://example.com/2023/09/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="violet617">
<meta property="og:description" content="Java语言有哪些特点                                简单易学：Java有丰富的类库，不用手写轮子面向对象：Java是一门面向对象的语言，支持封装、继承、多态跨平台性：Java程序可以在不同的操作系统和硬件平台上运行，实现了一次编写，到处运行的目标安全性：Java具有高度的安全性，提供了注入类加载器、安全管理器和异常处理机制等安全机制Java类加载器采用双亲委派模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/suolong.jpeg">
<meta property="article:published_time" content="2023-09-15T09:26:21.000Z">
<meta property="article:modified_time" content="2023-09-15T09:27:24.286Z">
<meta property="article:author" content="violet617">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/suolong.jpeg"><link rel="shortcut icon" href="/img/door_open.png"><link rel="canonical" href="http://example.com/2023/09/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础汇总',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-09-15 17:27:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/layout.css"><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/big-counter.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/suolong.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-compass"></i><span> 动态</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="violet617"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/door_open.png"/><span class="site-name">violet617</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-compass"></i><span> 动态</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-15T09:26:21.000Z" title="发表于 2023-09-15 17:26:21">2023-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-15T09:27:24.286Z" title="更新于 2023-09-15 17:27:24">2023-09-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ol>
<li>Java语言有哪些特点<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li>简单易学：Java有丰富的类库，不用手写轮子</li><li>面向对象：Java是一门面向对象的语言，支持封装、继承、多态</li><li>跨平台性：Java程序可以在不同的操作系统和硬件平台上运行，实现了<code>一次编写，到处运行的目标</code></li><li>安全性：Java具有高度的安全性，提供了注入类加载器、安全管理器和异常处理机制等安全机制<ul><li>Java类加载器采用双亲委派模式，即在加载类时先从父类加载器中查找对应的类，如果父类加载器中没有找到，则再去子类加载器中查找。这种机制可以防止对Java核心类库的篡改，并确保应用程序使用的是正确的类。如果你自己手写了一个Object类，这个手写的Object类是不会被加载的，而是会使用Java提供的Object类</li><li>如果你就是想用自己写的Object类，那么需要自定义类加载器，重写其findClass方法</li></ul></li><li>多线程：Java语言支持多线程编程，可以方便的实现并发操作</li><li>开放性：Java是一种开放性语言，具有开放的标准和规范，可以与其他语言进行交互和集成</li><li>高性能：Java的性能不断提高，特别是JIT编译器的引用使得Java程序的性能可以与C++等编译型语言媲美<ul><li>当JIT编译器发现某个方法被频繁调用时，它会将该方法的字节码转换为本地机器码来提高执行速度。这是因为字节码是一种跨平台的中间代码，其性能较低，而本地机器码是针对特定硬件平台的机器指令，其性能更高。</li></ul></li></ol>
              </div>
            </details></li>
<li>面向对象和面向过程的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>面向过程</code>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用时调用即可。性能较高，单片机、嵌入式开发一般采用面向过程开发</li><li><code>面向对象</code>：是把构成问题的事物分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有<code>封装</code>、<code>继承</code>、<code>多态</code>的特性，所以<code>易维护</code>、<code>易复用</code>、<code>易扩展</code>。可以设计出低耦合的系统，但是从性能上来说，要比面向过程要低。</li></ul>
              </div>
            </details></li>
<li>八种基本数据类型的大小，以及他们的封装类<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">大小（字节）</th><th style="text-align:center">封装类</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1</td><td style="text-align:center">Boolean</td></tr></tbody></table></div><ol><li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。</li><li>基本数据类型在声明时，系统会自动给它分配空间，而引用类型声明也只是分配了引用空间，必须通过实例化开辟数据空间后才可以赋值。</li><li>数组对象也是一个引用对象，将一个数组赋值给另一个数组时，只是复制了一个引用，所以通过某一个数组所做的修改，在另一个数组中也看得见<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = arr1;</span><br><span class="line">        <span class="comment">// 只改变arr2的值，输出结果中arr1和arr2的值都改变了</span></span><br><span class="line">        arr2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            System.out.print(arr2[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// arr1 和 arr2 的地址是一致的</span></span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>虽然Java语言中定义了boolean类型，但是在Java虚拟机中，没有专门的字节码指令用于处理boolean类型的值。相反，编译器将boolean类型的值编译成Java虚拟机中的int类型，其中0表示false，非0表示true。同样，boolean类型的数组在Java虚拟机中被编码为byte类型的数组。这是因为Java虚拟机的设计者们认为，使用int类型来代替boolean类型，不会对性能造成太大的影响，而且可以简化虚拟机的实现。</li></ol>
              </div>
            </details></li>
<li>标识符的命名规则<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>标识符的含义：</code>在程序中，我们自定义的内容，例如类的名字、方法名称、变量名称等，都是标识符</li><li><code>命名规则：</code>标识符可以包含英文字母、<code>0-9</code>的数字、<code>$</code>以及<code>_</code>，标识符不能以数字开头，不能是关键字</li><li><code>命名规范：</code>类名首字母大写，驼峰命名法。变量名、方法名首字母小写，后续也是驼峰命名</li></ul>
              </div>
            </details></li>
<li>instanceof关键字的作用<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>instanceof严格来说是Java中的一个双目运算符，用来测试一个对象是否为另一个对象的实例，用法如下  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj instance Class</span><br></pre></td></tr></table></figure><ul><li>其中obj为一个对象，Class表示一个类或者一个接口，当obj为Class对象，或为其子类、实现类，结果返回true，否则返回false</li></ul></li><li>注意：编译器会检查obj是否能转换为右边class类型，如果不能转换则直接报错  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> res = i <span class="keyword">instanceof</span> Integer;     <span class="comment">// 编译不通过：不可转换的类型；无法将 &#x27;int&#x27; 转换为 &#x27;java.lang.Integer&#x27;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> res = i <span class="keyword">instanceof</span> Integer;     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li>JavaSE规范中对instanceof运算符的规定是：如果obj为null，那么返回结果总为false  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> res = <span class="keyword">null</span> <span class="keyword">instanceof</span> Integer;</span><br></pre></td></tr></table></figure></li></ul>
              </div>
            </details></li>
<li>Java自动装箱与拆箱<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>装箱就是自动将基本数据类型转换为包装类型（int -&gt; Integer）；底层调用的是Integer的valueOf(int)方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Integer i = Integer.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li>拆箱就是自动将包装类型转换为基本数据类型（Integer -&gt; int）；底层调用的是intValue()方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">int</span> j = i.valueOf(i);</span><br></pre></td></tr></table></figure></li><li><code>面试题1：</code>下面的代码会输出什么<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">100</span>;</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line">        Integer c = <span class="number">200</span>;</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li><li>为什么会出现这样的结果呢？输出表明a和b指向的是同一个对象，而c和d指向的不是同一个对象，我们来看一下Integer.valueOf()方法的底层源码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>从注释中我们可以看到，此方法将始终缓存-128到127之间的值。</li><li>也就是如果数值在-128和127之间，就会返回IntegerCache.cache中已经存在的对象的引用，否则创建一个新的Integer对象。所以上面的代码中，a和b的数值为100，就是从缓存中取的已存在的对象，指向的是同一个对象，所以返回true；而c和d的值为200，并不在缓存中，所以是新建的Integer对象，所以返回false</li></ul>
              </div>
            </details></li>
<li>重载和重写的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>重载(Overload)：</code>是指在一个类中定义多个方法，它们具有相同的名称，但具有不同的参数列表（个数、类型、顺序），一边在不同的情况下可以调用不同的方法，重载方法可以在一个类中定义，也可以在不同类种定义，只要它们的方法签名不同即可</li><li>例如下面的代码定义了一个名为sum的重载方法，它可以接收不同类型和数量的参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>重写(Override)</code>：是指在子类中重新定义（覆盖）父类中已有的方法，以便实现不同的功能或适应不同的需求。重写方法必须和父类中的方法具有相同的方法名称、参数列表和返回值类型，并且访问权限不能比父类中的方法更严格<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过重写方法，我们可以在子类中实现特定的功能，同时也可以保留父类中的方法实现。重写方法通常用于实现多态性和集成特性。</li></ul>
              </div>
            </details></li>
<li>equals和==的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>==</code>比较两个对象的引用是否相同，也就是比较它们在内存中的地址是否相同，如果两个对象的引用相同，则返回true，否则返回false</li><li>例如下面代码中创建两个String类型的对象，他们的值相同但是引用不同，使用<code>==</code>比较会返回<code>false</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>equals</code>是比较两个对象的内容是否相同，也就是比较它们的值是否相同。如果两个对象的内容相同，则返回true，否则返回false。在Java中，Object类的equals()方法默认实现是使用<code>==</code>比较两个对象的引用，但可以在子类中重写该方法以实现比较对象内容的功能。</li><li>例如下面的代码中创建了两个String类型的对象，它们的值相同，所以使用<code>equals</code>比较会返回<code>true</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>
              </div>
            </details></li>
<li>hashCode的作用<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>Java</code>的集合有两类，一类是<code>List</code>，另一类是<code>Set</code>。前者有序可重复，后者无序不可重复。当我们在<code>Set</code>中插入的时候，如何判断已经存在该元素了呢？<ul><li>可以通过<code>equals</code>方法来判断，但是如果元素太多，用这样的方法就会比较慢</li></ul></li><li>于是就有人发明了哈希算法来提高集合中查找元素的效率，这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域</li><li><code>hashCode</code>可以这样理解：它返回的是根据对象内存地址换算出的一个值。这样一来，当set需要添加新元素时，先调用这个元素的<code>hashCode</code>方法，就能一下子定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不需要再进行任何比较了；如果这个位置上已经有元素了，就调用它的<code>equals</code>方法与新元素进行比较，如果相同就不用存了，不相同就散列其他的地址。这样一来实际调用<code>equals</code>方法的次数就大大降低了。</li></ul>
              </div>
            </details></li>
<li>String、StringBuilder、StringBuffer的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>String是只读字符串，并不是基本数据类型，而是一个对象，从底层源码来看是一个final类型的字符数组，所引用的字符串不能被改变，一经定义，无法再增删改，每次对String的操作都会生成新的String对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></li><li>每次<code>+</code>操作：隐式在堆上<code>new</code>了一个跟原字符串相同的<code>StringBuilder</code>对象，再调用append方法，拼接<code>+</code>后面的字符</li><li>StringBuffer和StringBuilder都继承了AbstractStringBuilder抽象类，从AbstractStringBuilder抽象类中我们可以看到<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value is used for character storage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></li><li>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用StringBuilder和StringBuffer来进行操作。</li><li>另外StringBuffer对方法加了同步锁或者对调用的方法加了同步锁（底层源码方法都加了synchronized），所以线程是安全的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">long</span> lng)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(lng);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>StringBuilder没有对方法进行加同步锁，所以是非线程安全的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">long</span> lng)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(lng);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>
              </div>
            </details></li>
<li>ArrayList和LinkedList的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li><code>内部实现：</code>ArrayList是基于动态数组实现的，内部使用Object[]数组来存储元素。而LinkedList是基于双向链表实现的，内部使用Node节点来存储元素</li><li><code>插入和删除操作：</code>ArrayList对于中间位置的插入和删除需要移动元素，因为它的底层是数组，需要将后面的元素往后移动，而LinkedList只需要修改节点的指针即可。因此，LinkedList在插入和删除操作方面比ArrayList效率更高</li><li><code>随机访问：</code>由于ArrayList的底层是数组，所以可以根据下标快速随机访问元素，时间复杂度为O(1)；而LinkedList是基于链表实现的，不能直接根据下标访问元素，需要从头或者从尾遍历到指定位置，时间复杂度为O(n)。</li><li><code>内存占用：</code>由于LinkedList的每个元素都需要一个额外指针来指向下一个节点，因此占用的内存空间会比ArrayList多</li></ol>
              </div>
            </details></li>
<li>HashMap和Hashtable的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li><code>二者父类不同：</code>HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都实现了Map、Cloneable、Serializable这三个接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><code>线程安全：</code>Hashtable是线程安全的，它的所有方法都是同步的（所有方法都用synchronized修饰），即对于多个线程同时访问一个Hashtable实例时，可以保证数据的唯一性。而HashMap不是线程安全的，如果多个线程同时访问一个HashMap实例，可能会出现数据不一致的情况</li><li><code>null键和null值的支持：</code>Hashtable不允许键或值为null，否则会抛出NullPointerException异常；而HashMap可以允许null键和null值</li><li><code>初始容量和负载因子：</code>Hashtable的初始容量和负载因子是固定的，在创建Hashtable实例时必须指定；而HashMap可以在创建时指定初始容量和负载因子，也可以在运行时动态调整</li><li><code>性能：</code>因为Hashtable是线程安全的，因此在多线程环境下使用时，会存在一定的性能问题；而HashMap不是线程安全的，在单线程环境下使用时，性能要比Hashtable高</li></ol>
              </div>
            </details></li>
<li>Collection包结构，与Collections的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Java中的Collection包含了一组接口，用于表示一组对象的集合。它提供了一些通用的操作，如添加、删除、遍历等。Collection包中的主要接口有<ol><li><code>List：</code>有序集合，可以有重复元素</li><li><code>Set：</code>无序集合，不允许有重复元素</li><li><code>Queue：</code>队列，通常用于实现先进先出(FIFO)的数据结构</li><li><code>Deque：</code>双端队列，可以在队头或队尾进行插入和删除操作</li></ol></li><li>Collections是Java中的一个工具类，它包含了一组静态方法，用于操作各种集合类型。它提供了一些常用的算法和工具方法，如排序、查找、复制等。Collections类中的方法通常是针对Collection类型的实例进行操作的</li><li>简单来说，Collection是一组结构，定义了集合的基本操作和属性，而Collections是一个工具类，提供了一些常用的算法和工具方法，用于操作各种集合类型的实例</li><li><div class="note warning no-icon flat"><p>需要注意的是：Collection和Collections之间是没有继承或实现关系的，它们是两个独立的概念</p></div></li></ul>
              </div>
            </details></li>
<li>Java的四种引用，强弱软虚<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>在Java中有四种类型的引用：强引用、软引用、弱引用、虚引用<ol><li><code>强引用(Strong Reference)：</code>是最常见的引用类型，它指向一个对象，只要强引用存在，垃圾回收器就不会回收该对象，可以通过new操作符、赋值操作符或方法调用等方式创建强引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><code>软引用(Soft Reference)：</code>是一种比较灵活的引用类型，它用来描述一些还有用，但是非必须的对象。只有当内存不足时，才会回收这些对象，可以通过SoftReference类创建软引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;String&gt; str = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><code>弱引用(Weak Reference)：</code>比弱引用还要弱一些，它指向的对象只要没有强引用指向它时，就会被回收。可以通过WeakReference类创建弱引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; str = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><code>虚引用(Phantom Reference)：</code>虚引用的回收机制与弱引用差不多，但是它在被回收之前，会被放入ReferenceQueue中。而其他引用是被JVM回收后才被传入ReferenceQueue中的。由于这个机制的存在，虚引用大多是被用于引用销毁前的处理工作。同时，虚引用在创建时，必须带有ReferenceQueue<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; str = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>), <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br></pre></td></tr></table></figure></li></ol></li></ul>
              </div>
            </details></li>
<li>泛型常用特点<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Java中的泛型是一种类型参数化机制，它可以让代码更加灵活、可读性更强，同时也可以提高代码的安全性和可维护性。泛型的常用特点包括<ol><li><code>类型安全：</code>泛型可以让编译器在编译时就检查类型是否匹配，从而避免了很多类型转换和运行时错误</li><li><code>可重用性：</code>泛型可以让同一个类或方法适用于不同的数据类型，从而提高了代码的可重用性</li><li><code>可读性：</code>泛型可以让代码更易读，因为它可以让代码更具有表现力和可理解性</li><li><code>性能优化：</code>泛型可以让代码更加高效，因为它可以避免在运行时进行类型转换，从俄提高了程序的性能</li></ol></li><li><div class="note warning no-icon flat"><p>注意：Java中的泛型是在编译时实现的，而不是在运行时实现的。在编译时，Java编译器会进行类型擦除(Type Erasure)，将泛型类型转换为普通的类型。因此，在运行时无法获取泛型类型的具体信息</p></div></li></ul>
              </div>
            </details></li>
<li>Java创建对象有几种方式<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li><code>使用new关键字</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用Class类的newInstance方法</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Class cls = Class.forName(<span class="string">&quot;MyClass&quot;</span>);</span><br><span class="line">      MyClass obj = (MyClass) cls.newInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用Constructor类的newInstance方法</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line">      MyClass obj = constructor.newInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用clone方法</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">      MyClass obj2 = (MyClass) obj1.clone();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>使用反序列化</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MyClass obj1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">      ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;myFile.txt&quot;</span>));</span><br><span class="line">      out.writeObject(obj1);</span><br><span class="line">      out.close();</span><br><span class="line"></span><br><span class="line">      ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;myFile.txt&quot;</span>));</span><br><span class="line">      MyClass obj2 = (MyClass) in.readObject();</span><br><span class="line">      in.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>
              </div>
            </details></li>
<li>有没有可能两个不相等的对象有相同的hashCode<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>是有可能的，这种情况被称为<code>哈希冲突(Hash Collision)</code>，也叫哈希碰撞，是哈希算法中一种常见的情况。</li><li>但是哈希冲突不是问题，因为哈希表实现了一种解决冲突的方法，当发生哈希冲突时，哈希表会在相应的桶中存储一个链表或树（红黑树），以容纳具有相同哈希码的所有元素。因此，即使练个不同对象具有相同的哈希码，他们也可以被正确的插入和检索</li></ul>
              </div>
            </details></li>
<li>深拷贝和浅拷贝的区别是什么<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>深拷贝：</code>是指将一个对象复制到另一个对象，新对象与原对象<code>不共享</code>引用类型属性（如数组、集合、对象等），也就是说，新对象和原对象的引用类型属性指向的是不同的地址，修改其中一个对象中的引用类型属性，不会影响另一个对象中的属性值。</li><li><code>浅拷贝：</code>是指将一个对象复制到另一个对象，新对象与原对象<code>共享</code>引用类型属性，也就是说，新对象与原对象中的引用类型属性指向的是同一个地址，修改器中一个对象的引用类型属性，会影响到另一个对象的属性值，Java中的Object类提供了clone方法来实现浅拷贝</li></ul>
              </div>
            </details></li>
<li>final有哪些用法<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>final是Java中的关键字，可以用来修饰类、方法、变量等，它的主要作用是用于定义常量、防止继承、防止重写方法等<ol><li><code>定义常量：</code>使用final关键字定义的变量称为常量，它的值在定以后就不能被修改。常量命名规范一般是大写字母加下划线，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">99999</span>;</span><br></pre></td></tr></table></figure></li><li><code>用于防止继承：</code>使用final关键字修饰的类不能被继承，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>防止重写方法：</code>使用final关键字修饰的方法不能被子类重写，例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>优化性能：</code>使用final关键字可以优化代码性能。被final修饰的方法和变量在编译时就已经确定了值，因此在运行时不需要进行计算，可以减少运行时的开销，提高程序的执行效率。同时，被final修饰的方法，JVM会尝试将其内联，以提高运行效率</li><li><code>优化代码可读性：</code>在代码中使用final关键字可以使代码更易读。通过将变量声明为final，可以明确其含义，使代码更易于理解和维护<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看到这个 MAX_VALUE 我就知道这个变量是干嘛的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">99999</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul>
              </div>
            </details></li>
<li>static有哪些用法<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>static是Java中的关键字，可以用来修饰类、方法、变量等，它的主要作用是创建静态成员，可以通过类名直接访问，而不需要实例化对象<ol><li><code>用于创建静态变量：</code>使用static关键字定义的变量称为静态变量，它的值与所有该类的对象共享，并且可以直接通过类名访问<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Tmp.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>用于创建静态方法：</code>使用static关键字定义的方法称为静态方法，同样可以直接通过类名调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tmp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tmp.myMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>用于创建静态代码块：</code>使用static关键字定义的代码块称为静态代码块，它在类加载时执行，且只执行一次，一般用于初始化静态变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; myStaticList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 从文件中加载数据并进行解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;mydata.txt&quot;</span>);</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">            String line;</span><br><span class="line">            myStaticList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                myStaticList.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My static list contains: &quot;</span> + myStaticList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>创建静态内部类：</code>使用static关键字定义的内部类被称为静态内部类，它与外部类的对象无关，可以直接访问外部类的静态成员<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> instanceVar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 静态内部类可以直接访问外部类的静态变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;StaticVar from inner class: &quot;</span> + staticVar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不需要创建OuterClass实例，但是可以直接创建StaticInnerClass实例，并且使用它访问外部类的静态成员</span></span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">        staticInnerClass.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>
              </div>
            </details></li>
<li><code>3 * 0.1 == 0.3</code>的返回值是什么<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>由于浮点数在计算机中的存储方式和计算方式的特殊性，导致浮点数的运算结果可能与预期不符，故此表达式的返回值为false</li></ul>
              </div>
            </details></li>
<li><code>a = a + b</code>和<code>a += b</code>有什么区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>+=</code>操作会进行隐式自动类型转换，例如这里的 <code>a += b</code>会隐式的将加操作的结果类型强制转换为持有结果的类型，而a = a + b则不会自动进行类型转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个byte类型的变量相加时，结果会被自动提升为int类型。这种类型提升被称为&quot;拓宽原始转换&quot;，它适用于所有原始类型，包括byte、short、char和int。</span></span><br><span class="line"><span class="keyword">byte</span> a = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line">a = a + b;      <span class="comment">// 编译报错：不兼容的类型。实际为 int&#x27;，需要 &#x27;byte&#x27;</span></span><br><span class="line">a += b;         <span class="comment">// a = (byte)(a + b)</span></span><br></pre></td></tr></table></figure></li><li>再来看一个小案例，以下代码是否存在错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short a = 1;</span><br><span class="line">a = a + 1;</span><br></pre></td></tr></table></figure></li><li>有错误，short类型在进行运算时，会自动提升为int类型，也就是说<code>a + 1</code>的运算结果是int类型，而a是short类型，此时编译器会报错<code>不兼容的类型。实际为 int&#39;，需要 &#39;short&#39;</code>，改成<code>+=</code>的方式就好了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short a = 1;</span><br><span class="line">a += 1;</span><br></pre></td></tr></table></figure></li></ul>
              </div>
            </details></li>
<li>try catch finally，try里有return语句，finally还会执行吗<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>无论try代码块中是否包含return语句，finally块中的代码都会被执行。无论try块中有没有抛出异常，finally快中的代码都会被执行。finally块通常用于在代码中执行清理操作，例如：释放资源、关闭文件等 </li><li>需要注意的是，如果在finally块中使用了return语句，那么这个返回值会覆盖掉try块中的返回值，因此，finally块中的返回值将成为整个方法的返回值，这种做法是不推荐的。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码将输出20</li></ul></li><li>再来看看另一种情况  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_37</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码输出<code>10</code>，编译后的字节码文件如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static int test();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=1, locals=3, args_size=0</span><br><span class="line">       0: bipush        10      // 将 10 放入栈顶</span><br><span class="line">       2: istore_0              // 10 -&gt; i</span><br><span class="line">       3: iload_0               // &lt;- i(10)</span><br><span class="line">       4: istore_1              // 将 i(10) 暂存至 slot 1，目的是为了固定返回值</span><br><span class="line">       5: bipush        20      // 将 20 放入栈顶</span><br><span class="line">       7: istore_0              // 20 -&gt; i</span><br><span class="line">       8: iload_1               // 载入 slot 1 暂存的值 (10)</span><br><span class="line">       9: ireturn               // 返回栈顶的值</span><br><span class="line">      10: astore_2</span><br><span class="line">      11: bipush        20</span><br><span class="line">      13: istore_0</span><br><span class="line">      14: aload_2</span><br><span class="line">      15: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           3     5    10   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 10: 0</span><br><span class="line">      line 12: 3</span><br><span class="line">      line 14: 5</span><br><span class="line">      line 12: 8</span><br><span class="line">      line 14: 10</span><br><span class="line">      line 15: 14</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          3      13     0     i   I</span><br><span class="line">    StackMapTable: number_of_entries = 1</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 10</span><br><span class="line">        locals = [ int ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure></li><li>虽然在 finally 块中将 i 的值修改为 20，但是这不会影响 return 语句的返回值，因为在返回之前，i 的值已经被暂存到了 slot 1 中。在 finally 块中对 i 进行的修改不会影响 slot 1 中的值，因此 ireturn 指令返回的是 slot 1 中的值，即 10。</li></ul></li><li>关于字节码技术，可以参考我的这文章<div class="tag link"><a class="link-card" title="JVM类加载与字节码技术" target="_blank" rel="noopener" href="https://cyborg2077.github.io/2023/04/05/JvmPart4/"><div class="left"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s1.ax1x.com/2023/03/06/ppZ9JIS.png"/></div><div class="right"><p class="text">JVM类加载与字节码技术</p><p class="url">https://cyborg2077.github.io/2023/04/05/JvmPart4/</p></div></a></div></li></ul>
              </div>
            </details></li>
<li>Exception和Error包结构<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Java中的异常分为两类：<code>Error</code>和<code>Exception</code>，二者都是<code>Throwale</code>类的子类。<ul><li><code>Error</code>表示虚拟机本身的错误或资源耗尽等严重情况，应用程序不应该视图去捕获这些异常，例如<code>OOM(OutOfMemoryError)</code>、<code>SOF(StackOverFlowError)</code>等</li><li><code>Exception</code>表示程序运行中的异常情况，应该对其进行捕获和处理，<code>Exception</code>又分为<code>可检查异常(Checked Exception)</code>和<code>不可检查异常(Unchecked Exception)</code><ul><li>可检查异常需要程序显式地捕获并处理，例如<code>IOException</code>、<code>SQLException</code>等</li><li>而不可检查异常一般是程序运行时遇到的无法处理的错误，如<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>等，这些异常都继承自<code>RuntimeException</code>类，也被称为运行时异常，程序不需要显式地去捕获这类异常</li></ul></li></ul></li></ul>
              </div>
            </details></li>
<li>OOM你遇到过那些情况，SOF你遇到过哪些情况<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>OOM</code>和<code>SOF</code>都是Java程序中可能遇到的异常情况<ul><li><code>OOM(OutOfMemory)</code>即内存溢出，一般是指JVM内存不足以分配新对象，导致无法继续运行程序。出现OOM的情况很多，例如<ol><li>程序中创建了太多的对象，占用了过多的内存空间</li><li>代码中存在内存泄漏，导致不再使用的对象没有被及时释放，导致内存空间被占用</li><li>虚拟机参数设置不合理，导致JVM无法分配足够的内存等</li></ol></li><li><code>SOF(StackOverFlow)</code>即栈溢出，一般是指线程请求的栈深度大于<code>JVM</code>所允许的深度，导致<code>StackOverFlowError</code>异常。出现SOF的情况也有很多，例如<ol><li>递归调用层数过多，导致栈空间被耗尽</li><li>代码中存在死循环或循环调用，导致栈空间被耗尽</li><li>虚拟机参数设置不合理，导致栈空间太小等</li></ol></li></ul></li></ul>
              </div>
            </details></li>
<li>简述线程、程序、进程的基本概念，以及他们之间的关系是什么<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>程序：</code>是指一组指令和数据的有序集合，用于完成特定的任务。程序是存储在磁盘等外部存储介质中，只有在被加载到内存中才会被执行。</li><li><code>进程：</code>是指正在执行的程序的一个实例，是操作系统进行资源分配和调度的基本单位。进程拥有独立的内存空间和系统资源，可以包含多个线程</li><li><code>线程：</code>是指进程中的一个执行单元，是操作系统进行调度的最小单位。线程与进程共享内存空间和系统资源，每个线程拥有自己的程序计数器和栈空间</li><li>进程和线程都是程序执行的基本单位，进程和线程之间的关系是一对多的关系，即一个进程可以包含多个线程。多个线程可以并发地执行，共享进程的内存空间和系统资源。</li></ul>
              </div>
            </details></li>
<li>Java序列化中如果有某些字段不想进行序列化，怎么办<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>可以使用<code>transient</code>关键字修饰不想被序列化的字段，这样在序列化过程中这些字段就会被忽略掉。在反序列化时，这些字段的值会被设置成默认值，例如数值类型会被设置成<code>0</code>，布尔类型会被设置成<code>false</code>，引用类型会被设置成<code>null</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient修饰的字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>上面的代码中，<code>Person</code>类实现了<code>Serializable</code>接口，并且<code>age</code>字段被<code>transient</code>关键字修饰，那么在序列化过程中，<code>age</code>字段会被忽略掉，在反序列化时，<code>age</code>字段会被设置为默认值<code>0</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化前: &quot;</span> + person);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;person.dat&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;person.dat&quot;</span>))) &#123;</span><br><span class="line">            Person restoredPerson = (Person) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化后: &quot;</span> + restoredPerson);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在上面的代码中，我们创建了一个<code>Person</code>对象，并将其序列化到文件<code>person.dat</code>中，然后再从文件中反序列化得到一个新的<code>Person</code>对象，运行结果如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化前：Person [name=John, age=30]</span><br><span class="line">序列化后：Person [name=John, age=0]</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><ul><li>需要注意的是：使用<code>transient</code>修饰的字段<code>不能</code>是<code>static</code>或<code>final</code>修饰的</li></ul></div></li></ul>
              </div>
            </details></li>
<li>说说Java中的IO流<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Java中的IO流是Java提供的一种用于输入和输出数据的机制，主要分为字节流和字符流两种类型，它们可以用于读取和写入不同种类的数据源，例如文件、网络连接、内存缓冲区等。具体来说，Java中的IO流可以分为以下几种类型<ol><li><code>字节流(InputStream和OutStream)：</code>以字节为单位读写数据，适用于读写二进制文件和图片等数据</li><li><code>字符流(Reader和Writer)：</code>以字符为单位读写数据，适用于读写文本文件</li><li><code>缓冲流(BufferedInputSteam、BufferedOutputSteam、BufferedReader和BufferedWriter)：</code>在字节流和字符流的基础上增加了缓冲功能，提高读写数据的效率</li><li><code>对象流(ObjectInputSteam和ObjectOutputStream)：</code>用于序列化和反序列化Java对象，将Java对象转换为字节流进行存储和传输</li><li><code>转换流(InputStreamReader和OutputStreamWriter)：</code>将字节流转换为字符流或将字符流转换为字节流，提供了从字节流读取Unicode字符的方法</li><li><code>文件流(FileInputStream和FileOutputStream)：</code>用于读写文件，支持读写字节和字节数组</li><li><code>管道流(PipedInputStream和PipedOutputStream)：</code>用于线程之间的数据传输</li></ol></li><li>通过使用不同类型的IO流，可以很方便地完成文件的读写、网络数据的传输、对象的序列化等操作</li></ul>
              </div>
            </details></li>
<li>JavaIO和NIO的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Java中的<code>IO(Input/Output)</code>是指对数据的输入和输出操作，其中包含了许多输入输出流。Java的IO主要基于阻塞式IO模型实现的，即在读写数据时会一直阻塞，直到数据读写完成，而<code>NIO(NEW IO)</code>是Java1.4引入的一组新IO API，也成为<code>non-nlocking IO</code>。NIO主要是基于<code>非阻塞式IO模型</code>实现，可以在单个线程上进行多个IO操作，提高了IO效率</li><li>一下是Java IO和NIO的主要区别<ol><li><code>IO是面向流的，而NIO是面向缓冲区的。</code>Java的IO中，数据总是通过InputStream或OutputStream等流的形式传输，而在NIO中，数据是从通道读入缓冲区，从缓冲区写入通道</li><li><code>IO是阻塞的，而NIO是非阻塞的。</code>Java的IO读取或写入数据时，会一直阻塞当前线程，直到操作完成或发生异常，而在NIO中，可以进行异步读写操作，即一个线程可以处理多个连接</li><li><code>IO是单向的，而NIO是双向的。J</code>ava中的IO是单向的，即一个输入流只能读取数据，一个输出流只能写入数据，而在NIO中，缓冲区既可以读，也可以写</li><li><code>IO使用字节流和字符流进行操作，而NIO使用Channel和Buffer进行操作。</code>在Java的IO中，数据总是通过InputStream和OutputStream等流的形式传输，可以进行字节流和字符流的操作。而在NIO中，数据是从通道读入缓冲区，可以使用ByteBuffer、CharBuffer等缓冲区进行读写操作</li></ol></li></ul>
              </div>
            </details></li>
<li>Java反射的作用与原理<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Java反射是指在程序运行时<code>动态地获取</code>类的信息并操作类的<code>属性</code>、<code>方法</code>、<code>构造器</code>等，它允许程序在运行时动态地<code>创建对象</code>、<code>调用方法</code>、<code>获取字段值</code>等。Java反射的作用非常广泛，例如在<code>框架</code>、<code>ORM映射</code>、<code>RPC调用</code>等领域都有应用</li><li>Java反射的原理是通过Java的类加载机制，在运行时获取类的信息，包括类名、方法名、字段名、注解等，并生成类的Class对象，这个Class对象提供了操作类的各种方法和属性的API。反射可以通过Class类的一些方法来获取<code>Constructor</code>、<code>Method</code>、<code>Filed</code>等类的信息，通过这些信息可以实现对类的<code>实例化</code>、<code>调用方法</code>、<code>获取字段值</code>等操作</li><li>Java反射的主要优点是可以动态地加载类和调用类的方法、字段等，使得程序具有更高的灵活性和扩展性。不过由于反射是一种非常底层的操作，使用不当也容易导致性能问题，同时反射也存在安全隐患，因此在使用反射时需要谨慎处理</li></ul>
              </div>
            </details></li>
<li>说说List、Set、Map的区别<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>List、Set、Map是Java集合框架中最基础的三种容器，它们的区别如下<ol><li>List接口表示有序的集合，元素可以重复，每个元素都有一个索引。常用的实现类有ArrayList和LinkedList。ArrayList基于数组实现，插入、删除操作效率低，查询效率高；LinkedList基于链表实现，插入、删除效率高，查询效率低</li><li>Set接口表示无序的集合，元素不可重复。常用的实现类有HashSet、TreeSet。HashSet基于哈希表实现，查询、插入、删除效率都很高；TreeSet基于红黑树实现，元素有序，插入、删除、查询效率都很高</li><li>Map接口表示键值对集合，每个元素包含一个键和对应的值，键不可重复。常用的实现类有HashMap和TreeMap。HashMap基于哈希表实现，查询、插入、删除效率都很高；TreeMap基于红黑树实现，元素有序，插入、删除、查询效率都很高。</li></ol></li></ul>
              </div>
            </details></li>
<li>Object有哪些常用方法？大致说一下每个方法的含义<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>Object类是Java中所有类的基类，她定义了一些常用的方法，包括    <ol><li><code>equals(Object obj)：</code>判断当前对象是否与另一个对象相等，通常需要重写该方法</li><li><code>hashCode()：</code>返回当前对象的哈希码，用于哈希表等数据结构</li><li><code>toString()：</code>返回当前对象的字符串表示，通常需要重写该方法</li><li><code>getClass()：</code>返回当前对象的类类型</li><li><code>wait()：</code>使当前线程等待，直到其他线程调用该对象的notify()或notifyAll()方法</li><li><code>notify()：</code>唤醒一个等待中的线程</li><li><code>notifyAll()：</code>唤醒所有等待中的线程</li><li><code>finalize()：</code>在垃圾回收器回收对象之前调用，用于释放资源等清理工作</li></ol></li></ul>
              </div>
            </details></li>
<li>Java创建对象有几种方式<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li>使用new关键字创建对象：它会在堆内存中分配一块空间，并调用对象的构造方法初始化对象</li><li>使用Class类的newInstance()方法创建对象</li><li>使用Constructor类的newInstance()方法创建对象</li><li>使用clone()方法创建对象：在一个对象上调用clone()方法可以创建一个新的对象，并将原对象的值复制到新对象中。</li><li>使用反序列化创建对象：讲对象序列化后再反序列化就可以得到一个新的对象。这种方式需要确保对象所在的类实现了Serializable接口，并且没有重写readObject()和WriteObject()方法，否则反序列化时会出错</li></ol>
              </div>
            </details></li>
<li>获取一个类Class对象的方式有哪些<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li>通过对象的getClass()方法获取</li><li>通过类名.class获取</li><li>通过Class.forName()方法获取</li><li>通过ClassLoader.loadClass()方法获取</li></ol>
              </div>
            </details> </li>
<li>说一下ArrayList的特点<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li>内部实现是数组，支持动态扩容。再添加元素时，如果数组已满，则会重新创建一个更大的数组，并将原来数组中的元素复制到新数组中，这会导致添加元素的时间复杂度为O(n)</li><li>支持随机访问，可以通过元素下标直接访问数组中的元素，时间复杂度为O(1)</li><li>ArrayList中的元素允许为null</li><li>ArrayList是非线程安全的，不适合在多线程环境下使用</li><li>ArrayList的默认初始化容量为10，可以在创建ArrayList时指定初始化容量，可以一定程度上提升运行效率（避免扩容复制数组）</li><li>ArrayList支持插入和删除操作，但是在插入和删除元素时，需要将插入点后的元素全部后移，时间复杂度为O(n)</li></ol>
              </div>
            </details></li>
<li>有数组了为什么还要搞个ArrayList<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ol><li>ArrayList可以动态扩容，而数组的容量是固定的</li><li>ArrayList可以直接存储对象类型，而数组则只能存储基本数据类型和对象的引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];        <span class="comment">// 数组存储基本数据类型</span></span><br><span class="line">Object[] objArray = <span class="keyword">new</span> Object[<span class="number">3</span>];  <span class="comment">// 数组存储对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList可以直接存储对象类型本身</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>ArrayList提供了一些方便的方法，如add、remove、size等，对于操作元素的需求更加灵活</li><li>ArrayList支持泛型，可以指定容器中存储的数据类型</li><li>ArrayList可以和其他集合类进行互操作，如Collection.sort等，提供了更多的使用方式</li></ol>
              </div>
            </details></li>
<li>说说什么是fail-fast<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>fail-fast是指当集合在遍历中被修改了，那么就会抛出<code>ConcurrentModificationException</code>异常，这样可以保证多个线程并发修改时能够及时发现问题，它是一种机制，可以让程序出现并发修改时，尽早发现问题并迅速报错</li><li>Java中的某些集合类，例如ArrayList、HashMap等，都不是线程安全的。在许多县城环境中，可能会发生并发修改，也就是多个线程同时对集合进行添加、删除、修改等操作，这样会破坏集合的结构，导致数据不一致。fail-fast机制的出现就是为了解决这个问题，它在多线程并发修改集合时可以快速发现问题并报错，从而避免数据不一致的问题</li></ul>
              </div>
            </details></li>
<li>HashMap中的key我们可以使用任意类作为key吗<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>可以使用任意类作为key，但是使用时我们需要保证该类实现了hashCode()和equals()方法，以确保可以正确地进行散列和查找操作。否则，可能会导致key无法正确地被存储或查找。同时，key所述的类也需要实现Serializable接口，以便在需要时可以对HashMap进行序列化和反序列化操作。</li><li>在Java中，String、Long、Integer等常见的数据类型已经实现了hashCode()和equals()方法，因此可以直接作为HashMap的key</li></ul>
              </div>
            </details></li>
<li>为什么HashMap的长度是2的N次方呢<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li><code>HashMap</code>的长度为 2 的 N 次方是为了在存储和访问数据时提高效率，并尽可能减少哈希碰撞的发生。这是通过采用位操作 &amp; 来取代取模 % 运算来实现的。</li><li>当<code>HashMap</code>的长度是 2 的幂次时，取余操作等效于与操作，即 <code>hash % length</code> 等价于 <code>hash &amp; (length - 1)</code>。位操作 &amp; 在运算效率上具有优势。</li><li>这样设计的目的是使数据能够均匀分布在 HashMap 的桶中，使每个链表或红黑树的长度尽可能相等。这样可以减少链表过长或红黑树过深的情况，提高数据的存取效率。</li><li>因此，选择 HashMap 的长度为 2 的 N 次方是为了在哈希表的设计中兼顾了效率和均匀性，以提供更好的性能和较低的碰撞率。</li></ul>
              </div>
            </details></li>
<li>HashMap和ConcurrentHashMap的异同<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>相似点：<ol><li>都是Map接口的实现类，底层数据结构都是哈希表（数组+链表/红黑树）</li><li>都允许存储键值对，key和value都可以为null</li><li>都支持快速的插入、删除和查找操作</li></ol></li><li>不同点<ol><li><code>线程安全型：</code>HashMap是非线程安全的，而ConcurrentHashMap是线程安全的。在多线程环境下，ConcurrentHashMap的表现更优</li><li><code>性能：</code>在并发场景下，ConcurrentHashMap要比HashMap表现更好，尤其是当写操作很多的情况下。因为ConcurrentHashMap使用了分段锁的机制，使得多线程能够同时操作不同的段，减少了线程的竞争，从而提高了并发的效率</li><li><code>扩容机制：</code>HashMap扩容时会将原来的数组复制到新的更大的数组中，然后重新计算每个元素在新数组中的位置，这个过程比较耗时。而ConcurrentHashMap在扩容时，只需要复制里面的一部分短，不需要复制整个Map，因此速度相对更快</li><li><code>null key和null value：</code>HashMap允许key和value都未null，但是ConcurrentHashMap不允许key和value为null</li></ol></li><li>总体来说，如果在多线程环境下需要使用Map，建议使用ConcurrentHashMap，否则使用HashMap即可。</li></ul>
              </div>
            </details></li>
<li>红黑树有哪几个特征<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>红黑树是一种自平衡的二叉搜索树，具有以下特征<ol><li>每个节点要么是黑色，要么是红色</li><li>根节点是黑色的</li><li>所有叶子结点都是黑色的空节点(NIL节点)</li><li>如果一个节点是红色的，则它的啷个子节点都是黑色</li><li>任意衣蛾节点到其每个叶子结点的所有路径都包含相同数目的黑色节点</li></ol></li><li>这些特征保证了红黑树在插入和三处节点时能够保持平衡，从而保证了其查找、插入、删除操作的时间复杂度都是O(log n)级别的</li></ul>
              </div>
            </details></li>
<li>说说你平时是怎样处理Java异常的<details class="folding-tag" cyan><summary>  </summary>
              <div class='content'>
              <ul><li>我通常遵循以下几个规则<ol><li><code>按照异常类型分类处理：</code>对于不同的异常类型，我会根据实际情况进行不同待处理。例如对于业务异常，我通常会将异常信息记录到日志中，并给出友好提示；对于系统异常，我会打印异常的堆栈信息，将异常信息记录到日志中以便排查问题</li><li><code>异常不要吞掉：</code>在处理异常时，我不会简单的将异常捕获并吞掉，而是尽可能的将异常处理完毕，避免出现未处理的异常导致系统不稳定或者出现非预期的问题</li><li><code>日志记录：</code>在处理异常时，我通常会将异常信息记录到日志中，以便后续的问题排查与分析</li><li><code>异常处理要及时：</code>及时处理异常可以避免问题的扩大和影响范围的扩大，同时也可以减轻排查问题的难度</li><li><code>代码的健壮性：</code>尽可能的在代码的设计和编写阶段考虑各种异常情况，图稿代码的健壮性，减少出现异常的可能性w</li></ol></li></ul>
              </div>
            </details> </li>
</ol></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">violet617</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/">http://example.com/2023/09/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">violet617</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/suolong.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/15/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/" title="JVM知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM知识点</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/15/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Spring知识点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring知识点</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/suolong.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">violet617</div><div class="author-info__description">violet617的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/15/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Spring知识点">Spring知识点</a><time datetime="2023-09-15T09:28:40.000Z" title="发表于 2023-09-15 17:28:40">2023-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/15/Java%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/" title="Java基础汇总">Java基础汇总</a><time datetime="2023-09-15T09:26:21.000Z" title="发表于 2023-09-15 17:26:21">2023-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/15/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/" title="JVM知识点">JVM知识点</a><time datetime="2023-09-15T09:24:05.000Z" title="发表于 2023-09-15 17:24:05">2023-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/15/JVMPart/JVM_6/" title="JVM系列(6)">JVM系列(6)</a><time datetime="2023-09-15T09:19:19.000Z" title="发表于 2023-09-15 17:19:19">2023-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/15/JVMPart/JVM_5/" title="JVM系列(5)">JVM系列(5)</a><time datetime="2023-09-15T09:19:09.000Z" title="发表于 2023-09-15 17:19:09">2023-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By violet617</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BYQrZblZD5jDi2wc5Hc8N30F-gzGzoHsz',
      appKey: 'jtDyCBvdEgg46YOnGKW4DGA9',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="music"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>